# Traduçoes para o português do Brasil das mensagens do "textutils"
# Copyright (C) 1998 Free Software Foundation, Inc.
# Cyro Mendes De Moraes Neto <neto@conectiva.com.br>, 1998.
# Rodrigo Stulzer Lopes <rodrigo@conectiva.com.br>, 2001.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU textutils 2.0.14\n"
"POT-Creation-Date: 2002-07-29 10:41+0200\n"
"PO-Revision-Date: 2001-05-10 18:57GMT-0300\n"
"Last-Translator: Edison Assumpc,a~o Taca~o <tacao@conectiva.com.br>\n"
"Language-Team: Brazilian Portuguese <ldp-br@bazar.conectiva.com.br>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 0.8\n"

# , c-format
#: lib/argmatch.c:161
#, fuzzy, c-format
msgid "invalid argument %s for %s"
msgstr "argumento inválido %s para '%s'"

#: lib/argmatch.c:162
#, fuzzy, c-format
msgid "ambiguous argument %s for %s"
msgstr "Argumentos ambíguos %s para `%s'"

#: lib/argmatch.c:181
msgid "Valid arguments are:"
msgstr "Os argumentos válidos são:"

#: lib/c-stack.c:368
#, fuzzy
msgid "program error"
msgstr "erro de leitura"

#: lib/c-stack.c:369
msgid "stack overflow"
msgstr ""

#: lib/closeout.c:107 src/cat.c:186 src/cat.c:267 src/cat.c:320
#: src/cksum.c:267 src/head.c:152 src/head.c:195 src/tail.c:327
#: src/tail.c:1651 src/tr.c:1667 src/tr.c:1913 src/tr.c:2021
msgid "write error"
msgstr "erro de escrita"

#: lib/error.c:129 lib/error.c:157
msgid "Unknown system error"
msgstr "Erro de sistema desconhecido"

#: lib/file-type.c:42
msgid "regular empty file"
msgstr ""

#: lib/file-type.c:42
#, fuzzy
msgid "regular file"
msgstr "falha na leitura"

#: lib/file-type.c:45
msgid "directory"
msgstr ""

#: lib/file-type.c:48
#, fuzzy
msgid "block special file"
msgstr "tamanho do bloco"

#: lib/file-type.c:51
#, fuzzy
msgid "character special file"
msgstr "o offset de caracteres é zero"

#: lib/file-type.c:54
msgid "fifo"
msgstr ""

#: lib/file-type.c:57
msgid "symbolic link"
msgstr ""

#: lib/file-type.c:60
msgid "socket"
msgstr ""

#: lib/file-type.c:63
msgid "message queue"
msgstr ""

#: lib/file-type.c:66
msgid "semaphore"
msgstr ""

#: lib/file-type.c:69
msgid "shared memory object"
msgstr ""

#: lib/file-type.c:71
#, fuzzy
msgid "weird file"
msgstr "falha na leitura"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: opção `%s' está ambígua\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: opção `--%s' não permite um argumento\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: opção `%c%s' não permite um argumento\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: opção `%s' requer um argumento\n"

# , c-format
#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opção desconhecida `-%s'\n"

# , c-format
#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opção desconhecida `%c%s'\n"

# , c-format
#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opção inválida -- %c\n"

# , c-format
#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opção inválida -- %c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: opção requer um argumento --%c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: opção `-W %s' está ambígua\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: opção `-W %s' não permite um argumento\n"

#: lib/human.c:365
msgid "block size"
msgstr "tamanho do bloco"

# , c-format
#: lib/makepath.c:176
#, c-format
msgid "cannot create directory %s"
msgstr "não é possível criar o diretório %s"

#: lib/makepath.c:182 lib/makepath.c:423
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s existe, mas não é um diretório"

#: lib/makepath.c:319 lib/makepath.c:381 lib/makepath.c:442
#, c-format
msgid "cannot change owner and/or group of %s"
msgstr "não pode substituir dono e/ou grupo de %s"

# , c-format
#: lib/makepath.c:341
#, fuzzy, c-format
msgid "cannot chdir to directory %s"
msgstr "não pode executar 'chdir' sobre `%s'"

# , c-format
#: lib/makepath.c:395 lib/makepath.c:448
#, c-format
msgid "cannot change permissions of %s"
msgstr "não é possível mudar permissões de %s"

#: lib/obstack.c:494 lib/obstack.c:497 lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "memória esgotada"

#: lib/quotearg.c:270
msgid "`"
msgstr "`"

#: lib/quotearg.c:271
msgid "'"
msgstr "'"

#: lib/rpmatch.c:78
msgid "^[yY]"
msgstr "^[yY]"

#: lib/rpmatch.c:81
msgid "^[nN]"
msgstr "^[nN]"

#: lib/unicodeio.c:159
#, fuzzy
msgid "iconv function not usable"
msgstr "impossível exibir U+%04X: função iconv não utilizável"

#: lib/unicodeio.c:161
#, fuzzy
msgid "iconv function not available"
msgstr "impossível exibir U+%04X: função iconv não disponível"

# , c-format
#: lib/unicodeio.c:168
#, fuzzy
msgid "character out of range"
msgstr "U+%04X: caractere fora de faixa"

#: lib/unicodeio.c:231
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "impossível converter U+%04X para o conjunto local de caracteres"

#: lib/unicodeio.c:233
#, fuzzy, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "impossível converter U+%04X para o conjunto local de caracteres"

#: lib/userspec.c:178
msgid "invalid user"
msgstr "usuário inválido"

#: lib/userspec.c:179
msgid "invalid group"
msgstr "grupo inválido"

#: lib/userspec.c:181
msgid "cannot get the login group of a numeric UID"
msgstr "nao foi possivel obter um grupo e login de um UID numerico "

#: lib/userspec.c:183
msgid "cannot omit both user and group"
msgstr "não pode ignorar usuário e grupo"

#: lib/version-etc.c:61
#, c-format
msgid "Written by %s.\n"
msgstr "Escrito por %s.\n"

#: lib/version-etc.c:67
msgid ""
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"este e um software livre. veja o fonte para as condicoes de copia.\n"
"NÃO ha garantia nem mesmo de COMERCIALIZAÇÃO ou de APLICABILIDADE PARA UM\n"
"USO ESPACÍFICO.\n"

#: lib/xmemcoll.c:61
msgid "string comparison failed"
msgstr ""

#: lib/xmemcoll.c:62
msgid "Set LC_ALL='C' to work around the problem."
msgstr ""

#: lib/xmemcoll.c:64
#, c-format
msgid "The strings compared were %s and %s."
msgstr ""

#: src/cat.c:42 src/split.c:42
msgid "Torbjorn Granlund and Richard M. Stallman"
msgstr ""

# , c-format
#: src/cat.c:88 src/cksum.c:276 src/comm.c:69 src/csplit.c:1490 src/cut.c:163
#: src/expand.c:106 src/fmt.c:267 src/fold.c:63 src/head.c:84 src/join.c:140
#: src/md5sum.c:121 src/nl.c:172 src/od.c:287 src/paste.c:399 src/pr.c:2752
#: src/ptx.c:1855 src/sort.c:275 src/split.c:91 src/sum.c:56 src/tac.c:123
#: src/tail.c:234 src/tr.c:323 src/tsort.c:93 src/unexpand.c:371
#: src/uniq.c:130 src/wc.c:124
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Tente `%s --help' para mais informação.\n"

# , c-format
#: src/cat.c:92
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Uso: %s [OPÇÃO] [ARQUIVO]...\n"

#: src/cat.c:96
#, fuzzy
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
msgstr ""
"Concatena ARQUIVO(s), ou a entrada padrão, na saída padrão.\n"
"\n"
"  -A, --show-all          o mesmo que -vET\n"
"  -b, --number-nonblank   numera as linhas que não estão vazias\n"
"  -e                      o mesmo que -vE\n"
"  -E, --show-ends         mostra '$' no final de cada linha\n"
"  -n, --number            numera todas as linhas\n"
"  -s, --squeeze-blank     nunca mostra mais de uma linha vazia,\n"
"  -t                      equivalente a -vT\n"
"  -T, --show-tabs         mostra os caracteres de tabulação como ^I\n"
"  -u                      (sem efeito)\n"
"  -v, --show-nonprinting  utiliza a notação ^ e M-, salvo para LFD y TAB\n"
"      --help              mostra esta ajuda e finaliza\n"
"      --version           informa a versão e finaliza\n"
"\n"
"Sem 'ARQUIVO', ou quando ARQUIVO é -, lê a entrada padrão.\n"
"\n"

#: src/cat.c:106
#, fuzzy
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"Concatena ARQUIVO(s), ou a entrada padrão, na saída padrão.\n"
"\n"
"  -A, --show-all          o mesmo que -vET\n"
"  -b, --number-nonblank   numera as linhas que não estão vazias\n"
"  -e                      o mesmo que -vE\n"
"  -E, --show-ends         mostra '$' no final de cada linha\n"
"  -n, --number            numera todas as linhas\n"
"  -s, --squeeze-blank     nunca mostra mais de uma linha vazia,\n"
"  -t                      equivalente a -vT\n"
"  -T, --show-tabs         mostra os caracteres de tabulação como ^I\n"
"  -u                      (sem efeito)\n"
"  -v, --show-nonprinting  utiliza a notação ^ e M-, salvo para LFD y TAB\n"
"      --help              mostra esta ajuda e finaliza\n"
"      --version           informa a versão e finaliza\n"
"\n"
"Sem 'ARQUIVO', ou quando ARQUIVO é -, lê a entrada padrão.\n"
"\n"

#: src/cat.c:114 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/cat.c:119
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             usa escrita binária no console.\n"
"\n"

#: src/cat.c:124 src/cksum.c:291 src/comm.c:86 src/csplit.c:1532 src/cut.c:208
#: src/expand.c:131 src/fmt.c:297 src/fold.c:86 src/head.c:115 src/join.c:180
#: src/md5sum.c:157 src/nl.c:227 src/od.c:374 src/paste.c:423 src/pr.c:2864
#: src/sort.c:346 src/split.c:123 src/sum.c:76 src/tac.c:146 src/tail.c:304
#: src/tr.c:396 src/tsort.c:105 src/unexpand.c:394 src/uniq.c:169 src/wc.c:146
#, fuzzy, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Comunicar `bugs' para <bug-textutils@gnu.org>."

# , c-format
#: src/cat.c:308
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "não pode executar a função 'ioctl' sobre `%s'"

#: src/cat.c:647 src/od.c:1014
msgid "standard output"
msgstr "saída padrão"

# , c-format
#: src/cat.c:778
#, c-format
msgid "%s: input file is output file"
msgstr "%s: os arquivos de entrada e saída são os mesmos"

#: src/cksum.c:234
#, c-format
msgid "%s: file too long"
msgstr "%s: arquivo muito grande"

# , c-format
#: src/cksum.c:280
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Uso: %s [ARQUIVO]...\n"
" ou:  %s [OPÇÃO]\n"

#: src/cksum.c:285
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""

#: src/comm.c:35 src/uniq.c:38
msgid "Richard Stallman and David MacKenzie"
msgstr ""

# , c-format
#: src/comm.c:73
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "Uso: %s [OPÇÃO]... ARQUIVO1 ARQUIVO2\n"

#: src/comm.c:77
#, fuzzy
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines that appear in both files\n"
msgstr ""
"Compara os arquivos ordenados ARQUIVO1 e ARQUIVO2, linha por linha.\n"
"\n"
"  -1              suprime as linhas que só estão em ARQUIVO1\n"
"  -2              suprime as linhas que só estão em ARQUIVO2\n"
"  -3              mostra as linhas que só estão em um deles\n"
"      --help      mostra esta ajuda e finaliza\n"
"      --version   informa a versão e finaliza\n"

#: src/csplit.c:41
msgid "Stuart Kemp and David MacKenzie"
msgstr ""

#: src/csplit.c:290 src/csplit.c:1479 src/tac-pipe.c:57 src/tr.c:1609
#: src/tr.c:1712 src/tr.c:1755
msgid "read error"
msgstr "erro de leitura"

#: src/csplit.c:584
msgid "input disappeared"
msgstr "a entrada deixou de existir"

# , c-format
#: src/csplit.c:706 src/csplit.c:717
#, c-format
msgid "%s: line number out of range"
msgstr "%s: número de linha fora de tamanho"

# , c-format
#: src/csplit.c:744
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: `%s': número de linha fora de tamanho"

# , c-format
#: src/csplit.c:747 src/csplit.c:793
#, c-format
msgid " on repetition %d\n"
msgstr " repetido %d\n"

# , c-format
#: src/csplit.c:789
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: `%s': ocorrência não encontrada"

#: src/csplit.c:850 src/csplit.c:890 src/tac.c:262
msgid "error in regular expression search"
msgstr "erro na busca da expressão  regular"

# , c-format
#: src/csplit.c:993
#, c-format
msgid "write error for `%s'"
msgstr "erro em escrever `%s'"

# , c-format
#: src/csplit.c:1065
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: se esperava um `+' ou  um  `-' depois do delimitador"

# , c-format
#: src/csplit.c:1069
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: espera-se um número inteiro depois de `%c'"

# , c-format
#: src/csplit.c:1089
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: requer-se um `}' depois do número de repetições"

# , c-format
#: src/csplit.c:1099
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: entre `{' e `}' deve se especificar  um número inteiro"

# , c-format
#: src/csplit.c:1126
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: falta o delimitador de fechar `%c'"

# , c-format
#: src/csplit.c:1142
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: a expressão  regular não é válida: %s"

# , c-format
#: src/csplit.c:1175
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: padrão inválido"

# , c-format
#: src/csplit.c:1178
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: o número de linha deve ser maior que zero"

#: src/csplit.c:1184
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "número de linha `%s' é menor do que o número de linha precedente, %s"

#: src/csplit.c:1190
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "atenção: o número de linha `%s' é igual ao número de linha anterior"

#: src/csplit.c:1312
msgid "missing conversion specifier in suffix"
msgstr "especificador de conversão no sufixo perdido"

# , c-format
#: src/csplit.c:1318
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "especificador de conversão no sufixo é inválida: %c"

#: src/csplit.c:1321
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "especificador de conversão no sufixo é inválida: \\%.3o"

#: src/csplit.c:1353
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "especificador de conversão no sufixo %% perdido"

#: src/csplit.c:1356
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "muito %% especificador de conversão no sufixo"

#: src/csplit.c:1439
#, c-format
msgid "%s: invalid number"
msgstr "%s: número inválido"

#: src/csplit.c:1462
msgid "too few arguments"
msgstr "poucos argumentos"

# , c-format
#: src/csplit.c:1494
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Uso: %s [OPÇÃO]... [ARQUIVO PADRÃO]...\n"

#: src/csplit.c:1498
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""

#: src/csplit.c:1503 src/cut.c:175 src/expand.c:119 src/fmt.c:277
#: src/fold.c:76 src/head.c:98 src/nl.c:185 src/paste.c:413 src/pr.c:2765
#: src/ptx.c:1867 src/sort.c:289 src/split.c:104 src/tac.c:136 src/tail.c:248
#: src/unexpand.c:384 src/uniq.c:143
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""

#: src/csplit.c:1506
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""

#: src/csplit.c:1511
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""

#: src/csplit.c:1518
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""

#: src/csplit.c:1522
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""

#: src/cut.c:39
msgid "David Ihnat, David MacKenzie, and Jim Meyering"
msgstr ""

# , c-format
#: src/cut.c:167 src/expand.c:110 src/fold.c:67 src/head.c:88 src/nl.c:176
#: src/paste.c:403 src/pr.c:2756 src/sort.c:279 src/sum.c:60 src/tac.c:127
#: src/tail.c:238 src/unexpand.c:375 src/wc.c:128
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Uso: %s [OPÇÃO]... [ARQUIVO]...\n"

#: src/cut.c:171
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr ""

#: src/cut.c:178
#, fuzzy
msgid ""
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"Ajusta o largura das linhas em cada ARQUIVO (entrada padrão por default),\n"
"escrevendo o resultado na saída padrão\n"
"\n"
"  -b, --bytes         conta bytes em vez de colunas\n"
"  -s, --spaces        quebra nos espaços\n"
"  -w, --width=WIDTH   utiliza WIDTH colunas em vez de 80\n"
"      --help                mostra esta ajuda e finaliza\n"
"      --version             informa a versão e finaliza\n"

#: src/cut.c:183
msgid ""
"  -f, --fields=LIST       output only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""

#: src/cut.c:189
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""

#: src/cut.c:196
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/cut.c:263 src/cut.c:294 src/cut.c:354
msgid "invalid byte or field list"
msgstr "a lista de bytes ou campos não é válida"

#: src/cut.c:624 src/cut.c:633
msgid "only one type of list may be specified"
msgstr "somente um tipo de lista pode ser especificado"

#: src/cut.c:627
msgid "missing list of positions"
msgstr "faltando a lista de posições"

#: src/cut.c:636
msgid "missing list of fields"
msgstr "faltando a lista de campos"

#: src/cut.c:643
msgid "the delimiter must be a single character"
msgstr "o delimitador deve ser um só caractere"

#: src/cut.c:673
msgid "you must specify a list of bytes, characters, or fields"
msgstr "Deve-se indicar uma lista de bytes, caracteres ou campos"

#: src/cut.c:676
msgid "a delimiter may be specified only when operating on fields"
msgstr ""
"Um delimitador pode ser especificado somente quando se processam campos"

#: src/cut.c:679
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"suprimir as linhas não delimitadas somente tem sentido\n"
"\tquando se processam campos"

#: src/expand.c:114
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""

#: src/expand.c:122
msgid ""
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""

#: src/expand.c:126
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""

#: src/expand.c:173 src/unexpand.c:153
msgid "tab size contains an invalid character"
msgstr "o tamanho de tabulação contém um caractere não válido"

#: src/expand.c:191 src/unexpand.c:171
msgid "tab size cannot be 0"
msgstr "o tamanho de tabulação não pode ser 0"

#: src/expand.c:193 src/unexpand.c:173
msgid "tab sizes must be ascending"
msgstr "as posições de tabulação devem ir em ordem crescente"

# , c-format
#: src/expand.c:386
#, fuzzy
msgid "`-LIST' option is obsolete; use `-t LIST'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "Uso: %s [-DÍGITOS] [OPÇÃO]... [ARQUIVO]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
msgstr ""

#: src/fmt.c:280
#, fuzzy
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"Reformata cada parágrafo do ARQUIVO(s), escrevendo na saída padrão.\n"
"Se não se especificar um ARQUIVO ou ARQUIVO é `-', lê a entrada padrão.\n"
"\n"
"Os argumentos obrigatórios para as opções largas são também obrigatórios "
"para as opções curtas.\n"
"  -c, --crown-margin        mantém a indentação nas primeiras duas linhas\n"
"  -p, --prefix=CADEIA       associa somente as linhas que comecem com "
"CADEIA\n"
"  -s, --split-only          divide as linhas largas, mas sem quebrá-las\n"
"  -t, --tagged-paragraph    identificação da primeira linha diferente\n"
"                            da segunda linha\n"
"  -u, --uniform-spacing     coloca um espaço entre palavras, dois "
"entre                             frases\n"
"  -w, --width=NÚMERO        estabelece o largura de linha máximo "
"(por                             default,\n"
"                            75 colunas)\n"
"      --help                mostra esta ajuda e finaliza\n"
"      --version             informa a versão e finaliza\n"
"\n"
"No `-wNÚMERO' pode-se omitir a letra `w'.\n"
"\n"

#: src/fmt.c:286
#, fuzzy
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
msgstr ""
"Reformata cada parágrafo do ARQUIVO(s), escrevendo na saída padrão.\n"
"Se não se especificar um ARQUIVO ou ARQUIVO é `-', lê a entrada padrão.\n"
"\n"
"Os argumentos obrigatórios para as opções largas são também obrigatórios "
"para as opções curtas.\n"
"  -c, --crown-margin        mantém a indentação nas primeiras duas linhas\n"
"  -p, --prefix=CADEIA       associa somente as linhas que comecem com "
"CADEIA\n"
"  -s, --split-only          divide as linhas largas, mas sem quebrá-las\n"
"  -t, --tagged-paragraph    identificação da primeira linha diferente\n"
"                            da segunda linha\n"
"  -u, --uniform-spacing     coloca um espaço entre palavras, dois "
"entre                             frases\n"
"  -w, --width=NÚMERO        estabelece o largura de linha máximo "
"(por                             default,\n"
"                            75 colunas)\n"
"      --help                mostra esta ajuda e finaliza\n"
"      --version             informa a versão e finaliza\n"
"\n"
"No `-wNÚMERO' pode-se omitir a letra `w'.\n"
"\n"

#: src/fmt.c:293
msgid ""
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""

# , c-format
#: src/fmt.c:345
#, fuzzy, c-format
msgid "invalid width option: `%s'"
msgstr "tipo de cadeia inválida `%s'"

# , c-format
#: src/fmt.c:385
#, fuzzy, c-format
msgid "invalid width: `%s'"
msgstr "número de campo inválido: `%s'"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""

# , c-format
#: src/fold.c:267
#, fuzzy, c-format
msgid "`%s' option is obsolete; use `%s'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#: src/fold.c:295
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "o número de colunas não é válido: `%s'"

#: src/head.c:92
#, fuzzy
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Mostra as primeiras 10 linhas de cada ARQUIVO na saída padrão.\n"
"Se especificados vários ARQUIVO(s), mostra o nome de cada um.\n"
"Sem ARQUIVO especificado, ou ARQUIVO é `-', lê da entrada padrão.\n"
"\n"
"  -c, --bytes=TAMANHO     mostra os primeiros TAMANHO bytes\n"
"  -n, --lines=N           mostra as N primeiras linhas em vez de 10\n"
"  -q, --quiet, --silent   no mostra as início com o nome do arquivo\n"
"  -v, --verbose           mostra sempre os inícios com nomes dos arquivos\n"
"      --help              mostra esta ajuda e finaliza\n"
"      --version           informa a versão e finaliza\n"
"\n"
"TAMANHO pode ter um sufixo: `b' para 512, `k' para 1K, `m' para 1Meg.\n"
"Se -VALOR for informado como primeira opção, lê -c VALOR se um dos \n"
"sufixo bkm seguir concatenado a VALOR, ou lê -n VALOR\n"

#: src/head.c:101
msgid ""
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
msgstr ""

#: src/head.c:105
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""

#: src/head.c:111 src/split.c:119
msgid ""
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""

# , c-format
#: src/head.c:189
#, fuzzy, c-format
msgid "cannot reposition file pointer for %s"
msgstr "não é possível criar o diretório %s"

#: src/head.c:220 src/md5sum.c:334 src/md5sum.c:675 src/od.c:960 src/od.c:2000
#: src/pr.c:1166 src/pr.c:1373 src/pr.c:1495 src/tac.c:484 src/tac.c:490
#: src/tr.c:2028 src/tsort.c:585
msgid "standard input"
msgstr "entrada padrão"

#: src/head.c:255 src/tail.c:1378
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s, `%s' é tão grande que não pode ser mostrado"

#: src/head.c:256 src/tail.c:1380
msgid "number of lines"
msgstr "número de linhas"

#: src/head.c:256 src/tail.c:1381
msgid "number of bytes"
msgstr "número de bytes"

#: src/head.c:263 src/tail.c:1467
msgid "invalid number of lines"
msgstr "número de linhas inválido"

#: src/head.c:264 src/tail.c:1468
msgid "invalid number of bytes"
msgstr "número de bytes inválido"

# , c-format
#: src/head.c:340
#, c-format
msgid "unrecognized option `-%c'"
msgstr "opção não reconhecida '-%c'"

# , c-format
#: src/head.c:347
#, fuzzy, c-format
msgid "`-%s' option is obsolete; use `-%c %.*s%.*s%s'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#: src/join.c:144
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Uso: %s [OPÇÃO]... ARQUIVO1 ARQUIVO2\n"

#: src/join.c:148
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""

#: src/join.c:156
msgid ""
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""

#: src/join.c:164
#, fuzzy
msgid ""
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
msgstr ""
"Compara os arquivos ordenados ARQUIVO1 e ARQUIVO2, linha por linha.\n"
"\n"
"  -1              suprime as linhas que só estão em ARQUIVO1\n"
"  -2              suprime as linhas que só estão em ARQUIVO2\n"
"  -3              mostra as linhas que só estão em um deles\n"
"      --help      mostra esta ajuda e finaliza\n"
"      --version   informa a versão e finaliza\n"

#: src/join.c:171
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""

# , c-format
#: src/join.c:644
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "especificação do campo é inválida: `%s'"

# , c-format
#: src/join.c:658 src/join.c:771 src/join.c:807
#, c-format
msgid "invalid field number: `%s'"
msgstr "número de campo inválido: `%s'"

# , c-format
#: src/join.c:671
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "número de arquivo inválido na especificação do campo: `%s'"

# , c-format
#: src/join.c:791
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "número de campo inválido para o arquivo 1: `%s'"

# , c-format
#: src/join.c:800
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "número de campo inválido para o arquivo 2: `%s'"

#: src/join.c:832
msgid "too many non-option arguments"
msgstr "muitos argumentos"

#: src/join.c:854
msgid "too few non-option arguments"
msgstr "número de argumentos insuficiente"

#: src/join.c:865
msgid "both files cannot be standard input"
msgstr "ambos os arquivos não podem ser a entrada padrão"

#: src/md5sum.c:38
msgid "Ulrich Drepper and Scott Miller"
msgstr ""

#: src/md5sum.c:125
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/md5sum.c:134
#, c-format
msgid ""
"\n"
"  -b, --binary            read files in binary mode (default on DOS/"
"Windows)\n"
"  -c, --check             check %s sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
msgstr ""

#: src/md5sum.c:142
msgid ""
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated checksum lines\n"
"\n"
msgstr ""

#: src/md5sum.c:150
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""

# , c-format
#: src/md5sum.c:379
#, c-format
msgid "%s: %lu: improperly formatted %s checksum line"
msgstr "%s: %lu: linha de checksum %s com formato errôneo"

# , c-format
#: src/md5sum.c:401
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: FALHA na abertura ou na leitura\n"

#: src/md5sum.c:425
msgid "FAILED"
msgstr "A soma não coincide"

#: src/md5sum.c:425
msgid "OK"
msgstr "A soma coincide"

# , c-format
#: src/md5sum.c:438
#, c-format
msgid "%s: read error"
msgstr "%s: erro de leitura"

# , c-format
#: src/md5sum.c:451
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: não foram encontradas linhas de checksum %s com formato correto"

# , c-format
#: src/md5sum.c:464
#, c-format
msgid "WARNING: %d of %d listed %s could not be read"
msgstr "ATENÇÃO: %d de %d listado %s não pode ser lido"

#: src/md5sum.c:467
msgid "file"
msgstr "arquivo"

#: src/md5sum.c:467
msgid "files"
msgstr "arquivos"

# , c-format
#: src/md5sum.c:473
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "ATENÇÃO: calculado %d de %d %s não confere"

#: src/md5sum.c:476
msgid "checksum"
msgstr "soma de comprovação (checksum)"

#: src/md5sum.c:476
msgid "checksums"
msgstr "somas de comprovação (checksum)"

#: src/md5sum.c:558
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"as opções --binary e --text não tem sentido para verificar somas de "
"comprovação"

#: src/md5sum.c:566
msgid "the --string and --check options are mutually exclusive"
msgstr "as opções --string e --check são mutuamente excludentes"

#: src/md5sum.c:573
msgid "the --status option is meaningful only when verifying checksums"
msgstr "a opção --status só tem sentido para verificar somas de comprovação"

#: src/md5sum.c:580
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "a opção --warn só tem sentido para verificar somas de comprovação"

#: src/md5sum.c:590
msgid "no files may be specified when using --string"
msgstr "não é possível especificar arquivo quando se usa --string"

#: src/md5sum.c:612
msgid "only one argument may be specified when using --check"
msgstr "quando se utiliza --check só se pode especificar um argumento"

#: src/nl.c:39
msgid "Scott Bartram and David MacKenzie"
msgstr ""

#: src/nl.c:180
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""

#: src/nl.c:188
#, fuzzy
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"Escreve cada ARQUIVO na saída padrão começando pela última linha\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
"\n"
"  -b,  --before           colocar o separador antes de cada linha, em vez "
"de\n"
"                          colocar depois\n"
"  -r,  --regex            interpretar o separador como uma expressão "
"regular\n"
"  -s,  --separator=STRING usar STRING como separador, em vez de um salto de\n"
"                          linha\n"
"       --help             mostrar esta ajuda e sair\n"
"       --version          mostrar a versão e sair\n"
"\n"

#: src/nl.c:193
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""

#: src/nl.c:201
msgid ""
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""

#: src/nl.c:207
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""

#: src/nl.c:213
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""

# , c-format
#: src/nl.c:500
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "número de começo de linha inválido: `%s'"

# , c-format
#: src/nl.c:510
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "incremento de linha não válido: `%s'"

# , c-format
#: src/nl.c:523
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "número de linhas vazias inválido: `%s'"

# , c-format
#: src/nl.c:537
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "largura para o número de linha inválido: `%s'"

# , c-format
#: src/od.c:291
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"Uso: %s [OPÇÃO]... [ARQUIVO]...\n"
" ou: %s --traditional [ARQUIVO] [[+]OFFSET [[+]RÓTULO]\n"

#: src/od.c:296
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""

#: src/od.c:303
msgid "All arguments to long options are mandatory for short options.\n"
msgstr ""

#: src/od.c:306
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""

#: src/od.c:310
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""

#: src/od.c:320
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
msgstr ""

#: src/od.c:328
msgid ""
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""

#: src/od.c:336
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes may be . for octal and b for multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
msgstr ""

#: src/od.c:348
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""

#: src/od.c:355
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""

#: src/od.c:362
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  "
msgstr ""

#: src/od.c:370
msgid ""
"--string without a number implies 3.  --width without a number\n"
"implies 32.  By default, od uses -A o -t d2 -w 16.\n"
msgstr ""

# , c-format
#: src/od.c:726 src/od.c:845
#, c-format
msgid "invalid type string `%s'"
msgstr "tipo de cadeia inválida `%s'"

# , c-format
#: src/od.c:736
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"tipo de cadeia inválida `%s';\n"
"este sistema não provê um tipo de %lu bytes"

# , c-format
#: src/od.c:855
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"tipo de cadeia inválida `%s';\n"
"este sistema não dispõe de um tipo de ponto flutuante de %lu bytes"

# , c-format
#: src/od.c:918
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "caracter inválido `%c' na cadeia `%s'"

#: src/od.c:1145
msgid "cannot skip past end of combined input"
msgstr "impossível acessar além da entrada"

# msgstr ""
#: src/od.c:1398
msgid "old-style offset"
msgstr "estilo antigo de deslocamento"

# , c-format
#: src/od.c:1706
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr "endereço de saída inválido `%c'; deve ser um caracter de [doxn]"

#: src/od.c:1716
msgid "skip argument"
msgstr "argumento ignorado"

#: src/od.c:1724
msgid "limit argument"
msgstr "argumento limite"

#: src/od.c:1734
msgid "minimum string length"
msgstr "tamanho mínimo de cadeia"

#: src/od.c:1739 src/od.c:1805
#, c-format
msgid "%s is too large"
msgstr "%s é muito grande"

#: src/od.c:1803
msgid "width specification"
msgstr "especificação de largura"

#: src/od.c:1825
msgid "no type may be specified when dumping strings"
msgstr "o tipo não pode ser especificado quando se depura cadeias"

# , c-format
#: src/od.c:1873
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "segundo operando inválido em modo de compatibilidade `%s'"

#: src/od.c:1894
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr ""
"em modo de compatibilidade os dois últimos argumentos devem ser "
"deslocamentos (offsets)"

#: src/od.c:1901
msgid "compatibility mode supports at most three arguments"
msgstr "em modo de compatibilidade não deve haver mais de três argumentos"

# , c-format
#: src/od.c:1974
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#: src/od.c:1990
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: fmt=\"%s\" largura=%d\n"

#: src/paste.c:50
msgid "David M. Ihnat and David MacKenzie"
msgstr ""

#: src/paste.c:208
msgid "standard input is closed"
msgstr "a entrada padrão está fechada"

#: src/paste.c:407
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""

#: src/paste.c:416
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""

#: src/pr.c:328
msgid "Pete TerMaat and Roland Huebner"
msgstr ""

# , c-format
#: src/pr.c:805
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "`--pages' intervalo de número de páginas inválido: `%s'"

# , c-format
#: src/pr.c:817
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "`--pages' número de página inicial inválido: `%s'"

# , c-format
#: src/pr.c:829
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "`--pages' número de página final inválido: `%s'"

#: src/pr.c:836
msgid "`--pages' starting page number is larger than ending page number"
msgstr ""
"`--pages' número de página inicial é maior que o número de página final"

#: src/pr.c:913
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "`--pages=PRIMEIRA_PÁGINA[:ÚLTIMA_PÁGINA]' está faltando argumentos"

# , c-format
#: src/pr.c:924
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "`--columns=COLUNAS' o número de colunas não é válido: `%s'"

# , c-format
#: src/pr.c:978
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "`-l TAMANHO_DE_PÁGINA' número de linhas inválido: `%s'"

# , c-format
#: src/pr.c:1002
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "`-N NÚMERO' número de início de linha inválido: `%s'"

# , c-format
#: src/pr.c:1014
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "`-o MARGEM' deslocamento (offset) de linha inválido: `%s'"

# , c-format
#: src/pr.c:1055
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-w TAMANHO_DE_PÁGINA' número de caracteres inválido: `%s'"

# , c-format
#: src/pr.c:1067
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-W TAMANHO_DE_PÁGINA' número de caracteres inválido: `%s'"

#: src/pr.c:1081
msgid "%b %e %H:%M %Y"
msgstr "%b %e %H:%M %Y"

#: src/pr.c:1090
msgid "Cannot specify number of columns when printing in parallel."
msgstr ""
"Não é possível especificar o número de colunas quando imprimindo em paralelo."

#: src/pr.c:1094
msgid "Cannot specify both printing across and printing in parallel."
msgstr ""
"Não é possível especificar impressão em paralelo e transversalmente ao mesmo "
"tempo."

# , c-format
#: src/pr.c:1190
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr ""
"`-%c' caracteres extras, ou o argumento da opção `-s' não é válido : `%s'"

#: src/pr.c:1301
msgid "page width too narrow"
msgstr "largura de página muito estreita"

#: src/pr.c:2364
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr "número de página inicial é maior que o número de páginas: `%d'"

#: src/pr.c:2395
#, c-format
msgid "Page %d"
msgstr "Página %d"

#: src/pr.c:2761
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""

#: src/pr.c:2768
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""

#: src/pr.c:2776
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""

#: src/pr.c:2784
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""

#: src/pr.c:2794
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""

#: src/pr.c:2803
msgid ""
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""

#: src/pr.c:2810
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""

#: src/pr.c:2818
msgid ""
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""

#: src/pr.c:2825
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""

#: src/pr.c:2832
msgid "  -SSTRING, --sep-string[=STRING]\n"
msgstr ""

#: src/pr.c:2835
msgid ""
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
msgstr ""

#: src/pr.c:2841
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""

#: src/pr.c:2851
#, fuzzy
msgid ""
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"Compara os arquivos ordenados ARQUIVO1 e ARQUIVO2, linha por linha.\n"
"\n"
"  -1              suprime as linhas que só estão em ARQUIVO1\n"
"  -2              suprime as linhas que só estão em ARQUIVO2\n"
"  -3              mostra as linhas que só estão em um deles\n"
"      --help      mostra esta ajuda e finaliza\n"
"      --version   informa a versão e finaliza\n"

#: src/pr.c:2859
msgid ""
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""

#: src/ptx.c:410
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (para expressão regular `%s')"

# , c-format
#: src/ptx.c:1859
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Uso: %s [OPÇÃO]... [ENTRADA]...  (sem a opção -G)\n"
"  ou:  %s [OPÇÃO]... [ENTRADA [SAÍDA]]\n"

#: src/ptx.c:1863
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""

#: src/ptx.c:1870
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""

#: src/ptx.c:1876
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""

#: src/ptx.c:1883
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""

#: src/ptx.c:1891
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""

#: src/ptx.c:1898
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""

#: src/ptx.c:1978
#, fuzzy
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
msgstr ""
"Este programa é um software livre, você pode redistribuí-lo e/ou modificá-"
"lo\n"
"sobre os termos da licença pública geral GNU (GPL - General Public License)\n"
"publicada pela Free Software Foundation, versão 2 ou posteriores.\n"
"\n"

#: src/ptx.c:1985
msgid ""
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
msgstr ""

#: src/ptx.c:1992
#, fuzzy
msgid ""
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"Este programa é um software livre, você pode redistribuí-lo e/ou modificá-"
"lo\n"
"sobre os termos da licença pública geral GNU (GPL - General Public License)\n"
"publicada pela Free Software Foundation, versão 2 ou posteriores.\n"
"\n"

#: src/sort.c:53
msgid "Mike Haertel and Paul Eggert"
msgstr ""

#: src/sort.c:283
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"Ordering options:\n"
"\n"
msgstr ""

#: src/sort.c:292
#, fuzzy
msgid ""
"  -b, --ignore-leading-blanks ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"Escreve uma concatenação classificada do(s) ARQUIVO(s) na saída padrão.\n"
"\n"
"Opções de classificação:\n"
"\n"
"  -b, --ignore-leading-blanks ignora espaços precedentes\n"
"  -d, --dictionary-order      considera apenas espaços e "
"caracteres                              alfanuméricos\n"
"  -f, --ignore-case           ignora caixa\n"
"  -g, --general-numeric-sort  compara de acordo com um valor numérico geral\n"
"  -i, --ignore-nonprinting    considera apenas caracteres imprimíveis\n"
"  -M, --month-sort            compara (desconhecido) < `JAN' < ... < `DEZ'\n"
"  -n, --numeric-sort          compara de acordo com o valor númerico da "
"string\n"
"  -r, --reverse               reverte o resultado das comparações\n"
"\n"

#: src/sort.c:297
#, fuzzy
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -r, --reverse               reverse the result of comparisons\n"
"\n"
msgstr ""
"Escreve uma concatenação classificada do(s) ARQUIVO(s) na saída padrão.\n"
"\n"
"Opções de classificação:\n"
"\n"
"  -b, --ignore-leading-blanks ignora espaços precedentes\n"
"  -d, --dictionary-order      considera apenas espaços e "
"caracteres                              alfanuméricos\n"
"  -f, --ignore-case           ignora caixa\n"
"  -g, --general-numeric-sort  compara de acordo com um valor numérico geral\n"
"  -i, --ignore-nonprinting    considera apenas caracteres imprimíveis\n"
"  -M, --month-sort            compara (desconhecido) < `JAN' < ... < `DEZ'\n"
"  -n, --numeric-sort          compara de acordo com o valor númerico da "
"string\n"
"  -r, --reverse               reverte o resultado das comparações\n"
"\n"

#: src/sort.c:305
msgid ""
"Other options:\n"
"\n"
"  -c, --check               check whether input is sorted; do not sort\n"
"  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""

#: src/sort.c:315
#, c-format
msgid ""
"  -t, --field-separator=SEP use SEP instead of non- to whitespace "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c: check for strict ordering\n"
"                              otherwise: output only the first of an equal "
"run\n"
msgstr ""

#: src/sort.c:322
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""

#: src/sort.c:327
#, fuzzy
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field.  OPTS is one or more single-letter ordering options, which\n"
"override global ordering options for that key.  If no key is given, use the\n"
"entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"POS é da forma F[.C][OPÇÕES], onde F é o número do campo e C a posição do\n"
"caractere no campo, ambos contados desde um com -k, e desde zero da forma\n"
"obsoleta. OPÇÕES se compõem de uma ou mais opções (de uma letra) de\n"
"ordenação, as quais substituem as opções globais de classificação para\n"
"aquela chave. Se nenhuma chave for fornecida, usa a linha inteira como\n"
"chave.\n"
"\n"
"TAMANHO pode ser seguido pelos seguintes prefixos multiplicadores:\n"
"%% 1%% de memória, b 1, k 1024 (padrão), e assim por diante com\n"
"M, G, T, P, E, Z e Y.\n"
"\n"
"Sem ARQUIVO, ou quando ARQUIVO for -, lê da entrada padrão.\n"
"\n"
"***  ATENÇÃO ***\n"
"A localização especificada no ambiente afeta a ordem de classificação.\n"
"Defina LC_ALL=C para obter a classificação tradicional que usa valores\n"
"nativos de bytes.\n"

#: src/sort.c:336
#, c-format
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""

# , c-format
#: src/sort.c:447
msgid "cannot create temporary file"
msgstr "impossível criar arquivo temporário"

#: src/sort.c:470
msgid "open failed"
msgstr "erro abrindo arquivo"

#: src/sort.c:490 src/sort.c:2488
msgid "close failed"
msgstr "erro fechando arquivo"

#: src/sort.c:498
msgid "write failed"
msgstr "erro de escrita"

#: src/sort.c:644
msgid "sort size"
msgstr "classificar tamanho"

#: src/sort.c:718
msgid "stat failed"
msgstr "falha no stat"

#: src/sort.c:970
msgid "read failed"
msgstr "falha na leitura"

# , c-format
#: src/sort.c:1566
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: desordenado: "

# , c-format
#: src/sort.c:1570
msgid "standard error"
msgstr "erro padrão"

# , c-format
#: src/sort.c:2028
#, c-format
msgid "%s: invalid field specification `%s'"
msgstr "%s: especificação de campo inválida `%s'"

#: src/sort.c:2054
#, c-format
msgid "%s: count `%.*s' too large"
msgstr "%s: countagem `%.*s' muito grande"

# , c-format
#: src/sort.c:2060
#, c-format
msgid "%s: invalid count at start of `%s'"
msgstr "%s: contagem inválida no início de `%s'"

#: src/sort.c:2290
msgid "invalid number after `-'"
msgstr "número inválido após `-'"

#: src/sort.c:2293 src/sort.c:2339 src/sort.c:2366
msgid "invalid number after `.'"
msgstr "número inválido após `.'"

#: src/sort.c:2296 src/sort.c:2375
msgid "stray character in field spec"
msgstr "caracter perdido no campo spec"

#: src/sort.c:2330
msgid "invalid number at field start"
msgstr "número inválido no início do campo"

# , c-format
#: src/sort.c:2334 src/sort.c:2362
msgid "field number is zero"
msgstr "o número do campo é zero"

#: src/sort.c:2343
msgid "character offset is zero"
msgstr "o offset de caracteres é zero"

#: src/sort.c:2358
msgid "invalid number after `,'"
msgstr "número inválido após `.'"

# , c-format
#: src/sort.c:2403
#, c-format
msgid "multi-character tab `%s'"
msgstr "tabulação multicaracter `%s'"

#: src/sort.c:2471
#, c-format
msgid "extra operand `%s' not allowed with -c"
msgstr "operando extra `%s' não é permitido com -c"

# , c-format
#: src/split.c:95
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "Uso: %s [OPÇÃO] [ARQUIVO [PREFIXO]]\n"

#: src/split.c:99
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
msgstr ""

#: src/split.c:107
#, fuzzy, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"Divide ARQUIVO em arquivos menores de tamanho fixo e os nomeia PREFIXOaa, "
"PREFIXOab...\n"
". O PREFIXO default é x.Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da "
"entrada padrão\n"
"\n"
"  -b, --bytes=BYTES       escreve BYTES bytes em cada arquivo de saída\n"
"  -C, --line-bytes=BYTES  escreve um máximo de BYTES bytes sem quebrar "
"linhas\n"
"  -l, --lines=NÚMERO      escreve NÚMERO linhas em cada arquivo de saída\n"
"  -NÚMERO                 o mesmo que -l NÚMERO\n"
"      --verbose           mostra um diagnóstico na saída de erro padrão\n"
"                          antes de abrir cada arquivo\n"
"       --help             mostra esta ajuda e finaliza\n"
"       --version          informa a versão e finaliza\n"
"\n"
"BYTES pode ter um fator indicado com o sufixo: b para 512, k para 1k,\n"
"m para 1 mega.\n"

#: src/split.c:113
msgid ""
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
msgstr ""

#: src/split.c:170
msgid "Output file suffixes exhausted"
msgstr ""

# , c-format
#: src/split.c:188
#, c-format
msgid "creating file `%s'\n"
msgstr "criando arquivo `%s'\n"

# , c-format
#: src/split.c:407
#, fuzzy, c-format
msgid "%s: invalid suffix length"
msgstr "%s: número de linhas inválido"

#: src/split.c:416 src/split.c:432 src/split.c:448 src/split.c:474
msgid "cannot split in more than one way"
msgstr "não é possível sub-dividir em mais de uma forma"

# , c-format
#: src/split.c:423 src/split.c:456
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: número de bytes inválido"

# , c-format
#: src/split.c:439
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: número de linhas inválido"

# , c-format
#: src/split.c:499
#, fuzzy, c-format
msgid "`-%d' option is obsolete; use `-l %d'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

#: src/split.c:512
msgid "invalid number"
msgstr "número inválido"

#: src/split.c:527 src/tr.c:1849
msgid "too many arguments"
msgstr "muitos argumentos"

#: src/sum.c:36
msgid "Kayvan Aghaiepour and David MacKenzie"
msgstr ""

#: src/sum.c:64
#, fuzzy
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Mostra a soma de verificação (checksum) e o número de blocos para cada "
"ARQUIVO.\n"
"\n"
"  -r            usar o algoritmo de BSD, com blocos de 1K\n"
"  -s, --sysv    usar o algoritmo de System V, com blocos de 512 bytes\n"
"      --help    mostrar esta ajuda e sair\n"
"      --version informar a versão e sair\n"
"\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"

#: src/sys2.h:483
#, fuzzy
msgid "      --help     display this help and exit\n"
msgstr ""
"Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
"\n"
"  --help      mostra esta ajuda e finaliza\n"
"  --version   informa a versão e finaliza\n"

#: src/sys2.h:485
#, fuzzy
msgid "      --version  output version information and exit\n"
msgstr ""
"Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
"\n"
"  --help      mostra esta ajuda e finaliza\n"
"  --version   informa a versão e finaliza\n"

#: src/tac.c:54
msgid "Jay Lepreau and David MacKenzie"
msgstr ""

#: src/tac.c:131
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""

#: src/tac.c:139
#, fuzzy
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"Escreve cada ARQUIVO na saída padrão começando pela última linha\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
"\n"
"  -b,  --before           colocar o separador antes de cada linha, em vez "
"de\n"
"                          colocar depois\n"
"  -r,  --regex            interpretar o separador como uma expressão "
"regular\n"
"  -s,  --separator=STRING usar STRING como separador, em vez de um salto de\n"
"                          linha\n"
"       --help             mostrar esta ajuda e sair\n"
"       --version          mostrar a versão e sair\n"
"\n"

# , c-format
#: src/tac.c:454 src/tac.c:593
msgid "stdin: read error"
msgstr "stdin: erro de leitura"

#: src/tac.c:639
msgid "separator cannot be empty"
msgstr "o separador não pode ser nulo"

#: src/tail.c:242
#, fuzzy, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Mostra as primeiras 10 linhas de cada ARQUIVO na saída padrão.\n"
"Se especificados vários ARQUIVO(s), mostra o nome de cada um.\n"
"Sem ARQUIVO especificado, ou ARQUIVO é `-', lê da entrada padrão.\n"
"\n"
"  -c, --bytes=TAMANHO     mostra os primeiros TAMANHO bytes\n"
"  -n, --lines=N           mostra as N primeiras linhas em vez de 10\n"
"  -q, --quiet, --silent   no mostra as início com o nome do arquivo\n"
"  -v, --verbose           mostra sempre os inícios com nomes dos arquivos\n"
"      --help              mostra esta ajuda e finaliza\n"
"      --version           informa a versão e finaliza\n"
"\n"
"TAMANHO pode ter um sufixo: `b' para 512, `k' para 1K, `m' para 1Meg.\n"
"Se -VALOR for informado como primeira opção, lê -c VALOR se um dos \n"
"sufixo bkm seguir concatenado a VALOR, ou lê -n VALOR\n"

#: src/tail.c:251
msgid ""
"      --retry              keep trying to open a file even if it is\n"
"                           inaccessible when tail starts or if it becomes\n"
"                           inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
msgstr ""

#: src/tail.c:257
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""

#: src/tail.c:264
#, c-format
msgid ""
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""

#: src/tail.c:275
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
"                           (default 1) seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""

#: src/tail.c:284
msgid ""
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).\n"
"\n"
msgstr ""

#: src/tail.c:292
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""

#: src/tail.c:297
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""

#: src/tail.c:335
#, c-format
msgid "closing %s (fd=%d)"
msgstr "fechando %s (fd=%d)"

#: src/tail.c:400
#, c-format
msgid "%s: cannot seek to offset %s%s"
msgstr ""

#: src/tail.c:404
#, c-format
msgid "%s: cannot seek to relative offset %s%s"
msgstr ""

#: src/tail.c:408
#, c-format
msgid "%s: cannot seek to end-relative offset %s%s"
msgstr ""

#: src/tail.c:814
#, c-format
msgid "`%s' has become inaccessible"
msgstr "`%s' tornou-se inacessível"

#: src/tail.c:831
#, c-format
msgid "`%s' has been replaced with an untailable file; giving up on this name"
msgstr ""
"`%s' foi substituido por um arquivo que não pode ser concatenado; desistindo "
"desse nome."

#: src/tail.c:852
#, c-format
msgid "`%s' has become accessible"
msgstr "%s tornou-se acessível"

# , c-format
#: src/tail.c:860
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "%s: apareceu;  localizando o fim de um novo arquivo"

#: src/tail.c:871
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "`%s' foi substituido;  localizando o fim de um arquivo"

#: src/tail.c:996
#, c-format
msgid "%s: file truncated"
msgstr "%s: arquivo truncado"

#: src/tail.c:1016
msgid "no files remaining"
msgstr "nenhum aquivo encontrado"

#: src/tail.c:1226
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr "%s: impossivel seguir ate o final desta arquivo; desistindo deste nome"

# , c-format
#: src/tail.c:1346
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: sufixo inválido em uma opção obsoleta"

#: src/tail.c:1395
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"argumentos em excesso;  ao usar a sintaxe de opção obsoleta (%s) do tail\n"
"não pode haver mais de um argumento de arquivo. Use a opção equivalente -n "
"ou -c"

#: src/tail.c:1404
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"atenção: Não é portável usar dois ou mais argumentos de arquivos com "
"sintaxe\n"
"obsoleta (%s). Use as equivalentes -n ou -c"

# , c-format
#: src/tail.c:1413
#, fuzzy, c-format
msgid "`%s' option is obsolete; use `%s-%c %.*s'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

#: src/tail.c:1473
#, c-format
msgid "%s: is so large that it is not representable"
msgstr "%s: é tão grande que não pode ser mostrado"

#: src/tail.c:1477
#, c-format
msgid "%s is larger than the maximum file size on this system"
msgstr "%s é maior que o tamanho máximo de arquivo neste sistema"

# , c-format
#: src/tail.c:1503
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr "%s: número máximo de bytes inválido"

# , c-format
#: src/tail.c:1515
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr ""
"%s: número máximo de linhas inválido para mudanças consecutivas no tamanho"

# , c-format
#: src/tail.c:1527
#, c-format
msgid "%s: invalid PID"
msgstr "%s: PID inválido"

# , c-format
#: src/tail.c:1545
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: número de segundos inválido"

#: src/tail.c:1565
msgid "warning: --retry is useful only when following by name"
msgstr "atenção: --retry é util somente quando for localizado pelo nome"

#: src/tail.c:1569
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "atenção: PID ignorado; --pid=PID é útil somente quando localizado"

#: src/tail.c:1572
msgid "warning: --pid=PID is not supported on this system"
msgstr "atenção: --pid=PID não é suportado neste sistema"

# , c-format
#: src/tr.c:327
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Uso: %s [OPÇÃO]... CONJUNTO1 [CONJUNTO2]\n"

#: src/tr.c:331
#, fuzzy
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Traduz, comprime e/ou apaga caracteres da entrada padrão, escrevendo\n"
"o resultado na saída padrão.\n"
"\n"
"  -c,  --complement        operar sobre o complemento (sobre cada caractere\n"
"                           que no coincida) de CONJUNTO1\n"
"  -d,  --delete            remover caracteres de CONJUNTO1, não traduzindo\n"
"  -s,  --squeeze-repeats   substituir sequências de caracteres iguais por "
"uma só\n"
"  -t,  --truncate-set1     truncar CONJUNTO1 na largura de CONJUNTO2\n"
"       --help              mostrar esta ajuda e sair\n"
"       --version           mostrar a versão e sair\n"

#: src/tr.c:344
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""

#: src/tr.c:358
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""

#: src/tr.c:369
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""

#: src/tr.c:379
#, fuzzy
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  "
msgstr ""
"\n"
"A tradução é feita se -d não é dado e ambos os CONJUNTOs são informados.\n"
"-t somente pode ser usado quando se estiver traduzindo.\n"
"CONJUNTO2 é estendido à largura de CONJUNTO1, repetindo seus últimos\n"
"caracteres tantas vezes como seja necessário. Os caracteres em excesso de\n"
"CONJUNTO2 são ignorados. Somente se garante que [:lower:] e [:upper:]\n"
"sejam expandidos em ordem ascendente; se se usa em CONJUNTO2 ao traduzir,\n"
"somente se podem usar em pares, para especificar conversão para maiúsculas.\n"
"-s usa CONJUNTO1 se não se está traduzindo nem apagando; caso contrário, a\n"
"compressão usa CONJUNTO2 depois da tradução ou remoção.\n"

#: src/tr.c:385
msgid ""
"Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  "
msgstr ""

#: src/tr.c:391
#, fuzzy
msgid ""
"-s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"A tradução é feita se -d não é dado e ambos os CONJUNTOs são informados.\n"
"-t somente pode ser usado quando se estiver traduzindo.\n"
"CONJUNTO2 é estendido à largura de CONJUNTO1, repetindo seus últimos\n"
"caracteres tantas vezes como seja necessário. Os caracteres em excesso de\n"
"CONJUNTO2 são ignorados. Somente se garante que [:lower:] e [:upper:]\n"
"sejam expandidos em ordem ascendente; se se usa em CONJUNTO2 ao traduzir,\n"
"somente se podem usar em pares, para especificar conversão para maiúsculas.\n"
"-s usa CONJUNTO1 se não se está traduzindo nem apagando; caso contrário, a\n"
"compressão usa CONJUNTO2 depois da tradução ou remoção.\n"

#: src/tr.c:557
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"atenção: a sequência de escape octal ambígua \\%c%c%c\n"
"está sendo interpretada como a sequência de 2 bytes \\0%c%c, `%c'"

#: src/tr.c:566
msgid "invalid backslash escape at end of string"
msgstr "sequência de escape inválida no final da string"

# , c-format
#: src/tr.c:572
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "sequência de escape inválida `\\%c'"

# , c-format
#: src/tr.c:725
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr "os extremos do intervalo em `%s-%s' estão em ordem inversa"

# , c-format
#: src/tr.c:906
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "número de repetições `%s' inválido na especificação [c*n]"

# , c-format
#: src/tr.c:999
#, fuzzy
msgid "missing character class name `[::]'"
msgstr "classe de caracteres inválida `%s'"

#: src/tr.c:1002
msgid "missing equivalence class character `[==]'"
msgstr ""

# , c-format
#: src/tr.c:1025
#, c-format
msgid "invalid character class `%s'"
msgstr "classe de caracteres inválida `%s'"

# , c-format
#: src/tr.c:1050
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: o operador de equivalência de classe deve ser só um caractere"

#: src/tr.c:1522
msgid "the [c*] repeat construct may not appear in string1"
msgstr "o operador de repetição [c*] não pode aparecer em string1"

#: src/tr.c:1532
msgid "only one [c*] repeat construct may appear in string2"
msgstr "só um operador de repetição [c*] pode aparecer em string2"

#: src/tr.c:1540
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "as expressões [=c=] não podem aparecer em string2 ao traduzir"

#: src/tr.c:1553
msgid "when not truncating set1, string2 must be non-empty"
msgstr "se não se está truncando conjunto1, string2 deve ser não vazia"

#: src/tr.c:1562
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"ao traduzir com classes de caracteres complementares (que não coincidem),\n"
"string2 deve mapear todos os caracteres do domínio a um só"

#: src/tr.c:1569
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"quando traduzindo, as únicas classes de caracteres que podem aparecer em\n"
"string2 são 'upper' e 'lower'"

#: src/tr.c:1578
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "as expressões [c*] só podem aparecer em string2 quando traduzindo"

#: src/tr.c:1854
msgid "two strings must be given when translating"
msgstr "duas strings devem ser fornecidas quando traduzindo"

#: src/tr.c:1857
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr ""
"duas strings devem ser fornecidas quando removendo/deletando repetições"

#: src/tr.c:1871
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""
"somente uma string deve ser fornecida quando removendo sem\n"
"comprimir repetições"

#: src/tr.c:1877
msgid "at least one string must be given when squeezing repeats"
msgstr "pelo menos uma string deve ser fornecida quando se comprime repetições"

#: src/tr.c:1968
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "as construções [:upper:] e/ou [:lower:] estão desalinhadas"

#: src/tr.c:1991
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"correspondência inválida; quando se traduz, qualquer construção [:lower] ou\n"
"[:upper:] na string1 deve estar alinhada com a correspondente\n"
"construção ([:upper:] ou [:lower:], respectivamente) em string2"

#: src/tsort.c:97
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Uso: %s [OPÇÃO] [ARQUIVO]\n"
"Escreve uma lista consistente totalmente ordenada com uma ordenação parcial "
"no arquivo\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
"\n"
"  --help      mostra esta ajuda e finaliza\n"
"  --version   informa a versão e finaliza\n"

#: src/tsort.c:533
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: entrada contem um loop:"

#: src/tsort.c:575
msgid "only one argument may be specified"
msgstr "somente um argumento pode ser especificado"

#: src/unexpand.c:379
#, fuzzy
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Converte os espaços de cada ARQUIVO em tabulações, escrevendo o\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
"\n"
"  -a, --all          converter todos os espaços em branco, não só os "
"iniciais\n"
"  -t, --tabs=NÚMERO  usar N espaços em cada tabulação, em vez de 8\n"
"  -t, --tabs=LISTA   usar a LISTA de posições separadas por vírgulas para\n"
"                     definir as posições de tabulação\n"
"      --help         mostrar esta ajuda e sair\n"
"      --version      mostrar a versão e sair\n"
"\n"
"Em vez de `-t NÚMERO' ou `-t LISTA' pode se usar -NÚMERO ou -LISTA.\n"

#: src/unexpand.c:387
msgid ""
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""

# , c-format
#: src/unexpand.c:463
#, fuzzy
msgid "`-LIST' option is obsolete; use `--first-only -t LIST'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Uso: %s [OPÇÃO]... [ENTRADA [SAÍDA]]\n"

#: src/uniq.c:138
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
msgstr ""

#: src/uniq.c:146
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""

#: src/uniq.c:150
msgid ""
"  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""

#: src/uniq.c:159
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""

#: src/uniq.c:164
msgid ""
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""

# , c-format
#: src/uniq.c:377
#, c-format
msgid "error reading %s"
msgstr "erro lendo %s"

# , c-format
#: src/uniq.c:382
#, c-format
msgid "error writing %s"
msgstr "erro escrevendo %s"

#: src/uniq.c:428 src/uniq.c:445
#, fuzzy, c-format
msgid "extra operand `%s'"
msgstr "operando extra `%s' não é permitido com -c"

# , c-format
#: src/uniq.c:468 src/uniq.c:493
#, fuzzy
msgid "invalid number of fields to skip"
msgstr "número inválido de campos para ignorar: `%s'"

# , c-format
#: src/uniq.c:502
#, fuzzy
msgid "invalid number of bytes to skip"
msgstr "número inválido de caracteres para ignorar: `%s'"

#: src/uniq.c:511
#, fuzzy
msgid "invalid number of bytes to compare"
msgstr "número inválido de bytes para comparar: `%s'"

# , c-format
#: src/uniq.c:525
#, fuzzy, c-format
msgid "`-%lu' option is obsolete; use `-f %lu'"
msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

#: src/uniq.c:533
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"não faz sentido imprimir todas as linhas duplicadas e repetir contagens"

#: src/wc.c:78
msgid "Paul Rubin and David MacKenzie"
msgstr ""

#: src/wc.c:132
#, fuzzy
msgid ""
"Print byte, word, and newline counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Mostrar o número de linhas, palavras e bytes para cada ARQUIVO, e uma linha\n"
"com o total se se especificar mais de um ARQUIVO.\n"
"Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
"   -c, --bytes            mostrar o número de bytes\n"
"   -m, --chars            mostrar o número de caracteres\n"
"   -l, --lines            mostrar o número de linhas\n"
"   -L, --max-line-length  mostrar o comprimento da linha mais longa\n"
"   -w, --words            mostrar o número de palavras\n"
"       --help             mostrar esta ajuda e sair\n"
"       --version          mostrar a versão e sair\n"

#: src/wc.c:140
#, fuzzy
msgid ""
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
"\n"
"  --help      mostra esta ajuda e finaliza\n"
"  --version   informa a versão e finaliza\n"

#: src/wc.c:589
msgid "total"
msgstr "total"

#, fuzzy
#~ msgid ""
#~ "\n"
#~ "(obsolete)  If -VALUE is used as first OPTION, same as -c VALUE when one "
#~ "of\n"
#~ "multipliers bkm follows concatenated, else same as -n VALUE.\n"
#~ msgstr ""
#~ "Mostra as primeiras 10 linhas de cada ARQUIVO na saída padrão.\n"
#~ "Se especificados vários ARQUIVO(s), mostra o nome de cada um.\n"
#~ "Sem ARQUIVO especificado, ou ARQUIVO é `-', lê da entrada padrão.\n"
#~ "\n"
#~ "  -c, --bytes=TAMANHO     mostra os primeiros TAMANHO bytes\n"
#~ "  -n, --lines=N           mostra as N primeiras linhas em vez de 10\n"
#~ "  -q, --quiet, --silent   no mostra as início com o nome do arquivo\n"
#~ "  -v, --verbose           mostra sempre os inícios com nomes dos "
#~ "arquivos\n"
#~ "      --help              mostra esta ajuda e finaliza\n"
#~ "      --version           informa a versão e finaliza\n"
#~ "\n"
#~ "TAMANHO pode ter um sufixo: `b' para 512, `k' para 1K, `m' para 1Meg.\n"
#~ "Se -VALOR for informado como primeira opção, lê -c VALOR se um dos \n"
#~ "sufixo bkm seguir concatenado a VALOR, ou lê -n VALOR\n"

# , c-format
#, fuzzy
#~ msgid "warning: `od -s' is obsolete; use `od --strings'"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#, fuzzy
#~ msgid "warning: `od -w' is obsolete; use `od --width'"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#, fuzzy
#~ msgid "warning: `pr -S' is obsolete; use `pr --sep-string'"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

#, fuzzy
#~ msgid ""
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolete\n"
#~ msgstr ""
#~ "Compara os arquivos ordenados ARQUIVO1 e ARQUIVO2, linha por linha.\n"
#~ "\n"
#~ "  -1              suprime as linhas que só estão em ARQUIVO1\n"
#~ "  -2              suprime as linhas que só estão em ARQUIVO2\n"
#~ "  -3              mostra as linhas que só estão em um deles\n"
#~ "      --help      mostra esta ajuda e finaliza\n"
#~ "      --version   informa a versão e finaliza\n"

# , c-format
#, fuzzy
#~ msgid "warning: `sort -y' is obsolete; omit `-y'"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#, fuzzy
#~ msgid "warning: `tail %s' is obsolete; use -n or -c instead"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

# , c-format
#, fuzzy
#~ msgid "warning: `uniq %s' is obsolete; use `uniq -s %s' instead"
#~ msgstr "atenção: largura %lu inválida; será usado %d em seu lugar"

#, fuzzy
#~ msgid ""
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help      display this help and exit\n"
#~ "      --version   output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help                display this help and exit\n"
#~ "      --version             output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help                     display this help and exit\n"
#~ "      --version                  output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "      --help             display this help and exit\n"
#~ "      --version          output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "  --help            display this help and exit\n"
#~ "  --version         output version information and exit\n"
#~ msgstr ""
#~ "Mostra o CRC e o número de bytes de cada ARQUIVO.\n"
#~ "\n"
#~ "  --help      mostra esta ajuda e finaliza\n"
#~ "  --version   informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "Convert tabs in each FILE to spaces, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -i, --initial       do not convert TABs after non whitespace\n"
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
#~ msgstr ""
#~ "Converte as tabulações de cada ARQUIVO em espaços, escrevendo o\n"
#~ "resultado na saída padrão. Se não for informado ARQUIVO ou quando \n"
#~ "ARQUIVO é  `-', lê-se da entrada padrão.\n"
#~ "\n"
#~ "  -i, --initial       só converte as tabulações iniciais de cada linha\n"
#~ "  -t, --tabs=NÚMERO   usa N espaços em cada tabulação, em vez de 8\n"
#~ "  -t, --tabs=LISTA    usa a LISTA de posições separadas por vírgula para\n"
#~ "                      definir as posições de tabulação\n"
#~ "      --help          mostra esta ajuda e finaliza\n"
#~ "      --version       informa a versão e finaliza\n"
#~ "\n"
#~ "Em vez de `-t N' ou `-t LISTA' pode usar-se -N ou -LISTA.\n"

#, fuzzy
#~ msgid ""
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "Converte as tabulações de cada ARQUIVO em espaços, escrevendo o\n"
#~ "resultado na saída padrão. Se não for informado ARQUIVO ou quando \n"
#~ "ARQUIVO é  `-', lê-se da entrada padrão.\n"
#~ "\n"
#~ "  -i, --initial       só converte as tabulações iniciais de cada linha\n"
#~ "  -t, --tabs=NÚMERO   usa N espaços em cada tabulação, em vez de 8\n"
#~ "  -t, --tabs=LISTA    usa a LISTA de posições separadas por vírgula para\n"
#~ "                      definir as posições de tabulação\n"
#~ "      --help          mostra esta ajuda e finaliza\n"
#~ "      --version       informa a versão e finaliza\n"
#~ "\n"
#~ "Em vez de `-t N' ou `-t LISTA' pode usar-se -N ou -LISTA.\n"

#, fuzzy
#~ msgid ""
#~ "Wrap input lines in each FILE (standard input by default), writing to\n"
#~ "standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --bytes         count bytes rather than columns\n"
#~ "  -s, --spaces        break at spaces\n"
#~ "  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Ajusta o largura das linhas em cada ARQUIVO (entrada padrão por "
#~ "default),\n"
#~ "escrevendo o resultado na saída padrão\n"
#~ "\n"
#~ "  -b, --bytes         conta bytes em vez de colunas\n"
#~ "  -s, --spaces        quebra nos espaços\n"
#~ "  -w, --width=WIDTH   utiliza WIDTH colunas em vez de 80\n"
#~ "      --help                mostra esta ajuda e finaliza\n"
#~ "      --version             informa a versão e finaliza\n"

#, fuzzy
#~ msgid ""
#~ "Write lines consisting of the sequentially corresponding lines from\n"
#~ "each FILE, separated by TABs, to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
#~ "  -s, --serial            paste one file at a time instead of in "
#~ "parallel\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Escreve seqüencialmente na saída padrão cada linha de cada ARQUIVO\n"
#~ "especificado, separadas por TABs.\n"
#~ "Se ARQUIVO não especificado ou ARQUIVO é `-', lê a entrada padrão.\n"
#~ "\n"
#~ "  -d, delimiters=LISTA   usa os caracteres indicados em LISTA no lugar "
#~ "de\n"
#~ "                         tabuladores\n"
#~ "  -s, --serial           usa um arquivo de cada vez, em lugar de fazê-los "
#~ "em\n"
#~ "                         paralelo\n"
#~ "      --help             mostra esta ajuda e finaliza\n"
#~ "      --version          informa a versão e finaliza\n"
#~ "\n"

#, fuzzy
#~ msgid ""
#~ "  -NUMBER                 same as -l NUMBER\n"
#~ "      --verbose           print a diagnostic to standard error just\n"
#~ "                            before each output file is opened\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
#~ msgstr ""
#~ "Divide ARQUIVO em arquivos menores de tamanho fixo e os nomeia PREFIXOaa, "
#~ "PREFIXOab...\n"
#~ ". O PREFIXO default é x.Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da "
#~ "entrada padrão\n"
#~ "\n"
#~ "  -b, --bytes=BYTES       escreve BYTES bytes em cada arquivo de saída\n"
#~ "  -C, --line-bytes=BYTES  escreve um máximo de BYTES bytes sem quebrar "
#~ "linhas\n"
#~ "  -l, --lines=NÚMERO      escreve NÚMERO linhas em cada arquivo de saída\n"
#~ "  -NÚMERO                 o mesmo que -l NÚMERO\n"
#~ "      --verbose           mostra um diagnóstico na saída de erro padrão\n"
#~ "                          antes de abrir cada arquivo\n"
#~ "       --help             mostra esta ajuda e finaliza\n"
#~ "       --version          informa a versão e finaliza\n"
#~ "\n"
#~ "BYTES pode ter um fator indicado com o sufixo: b para 512, k para 1k,\n"
#~ "m para 1 mega.\n"

#, fuzzy
#~ msgid ""
#~ "Write each FILE to standard output, last line first.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --before             attach the separator before instead of after\n"
#~ msgstr ""
#~ "Escreve cada ARQUIVO na saída padrão começando pela última linha\n"
#~ "Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
#~ "\n"
#~ "  -b,  --before           colocar o separador antes de cada linha, em vez "
#~ "de\n"
#~ "                          colocar depois\n"
#~ "  -r,  --regex            interpretar o separador como uma expressão "
#~ "regular\n"
#~ "  -s,  --separator=STRING usar STRING como separador, em vez de um salto "
#~ "de\n"
#~ "                          linha\n"
#~ "       --help             mostrar esta ajuda e sair\n"
#~ "       --version          mostrar a versão e sair\n"
#~ "\n"

#, fuzzy
#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                           inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                           inaccessible later -- useful only with -f\n"
#~ msgstr ""
#~ "Mostra as primeiras 10 linhas de cada ARQUIVO na saída padrão.\n"
#~ "Se especificados vários ARQUIVO(s), mostra o nome de cada um.\n"
#~ "Sem ARQUIVO especificado, ou ARQUIVO é `-', lê da entrada padrão.\n"
#~ "\n"
#~ "  -c, --bytes=TAMANHO     mostra os primeiros TAMANHO bytes\n"
#~ "  -n, --lines=N           mostra as N primeiras linhas em vez de 10\n"
#~ "  -q, --quiet, --silent   no mostra as início com o nome do arquivo\n"
#~ "  -v, --verbose           mostra sempre os inícios com nomes dos "
#~ "arquivos\n"
#~ "      --help              mostra esta ajuda e finaliza\n"
#~ "      --version           informa a versão e finaliza\n"
#~ "\n"
#~ "TAMANHO pode ter um sufixo: `b' para 512, `k' para 1K, `m' para 1Meg.\n"
#~ "Se -VALOR for informado como primeira opção, lê -c VALOR se um dos \n"
#~ "sufixo bkm seguir concatenado a VALOR, ou lê -n VALOR\n"

#, fuzzy
#~ msgid ""
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "Converte os espaços de cada ARQUIVO em tabulações, escrevendo o\n"
#~ "Sem informar ARQUIVO, ou se ARQUIVO é `-', lê da entrada padrão\n"
#~ "\n"
#~ "  -a, --all          converter todos os espaços em branco, não só os "
#~ "iniciais\n"
#~ "  -t, --tabs=NÚMERO  usar N espaços em cada tabulação, em vez de 8\n"
#~ "  -t, --tabs=LISTA   usar a LISTA de posições separadas por vírgulas "
#~ "para\n"
#~ "                     definir as posições de tabulação\n"
#~ "      --help         mostrar esta ajuda e sair\n"
#~ "      --version      mostrar a versão e sair\n"
#~ "\n"
#~ "Em vez de `-t NÚMERO' ou `-t LISTA' pode se usar -NÚMERO ou -LISTA.\n"

#, fuzzy
#~ msgid ""
#~ "Output pieces of FILE separated by PATTERN(s) to files `xx01', "
#~ "`xx02', ...,\n"
#~ "and output byte counts of each piece to standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
#~ "  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
#~ "  -k, --keep-files           do not remove output files on errors\n"
#~ "  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
#~ "  -s, --quiet, --silent      do not print counts of output file sizes\n"
#~ "  -z, --elide-empty-files    remove empty output files\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ "\n"
#~ "Read standard input if FILE is -.  Each PATTERN may be:\n"
#~ "\n"
#~ "  INTEGER            copy up to but not including specified line number\n"
#~ "  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
#~ "  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
#~ "  {INTEGER}          repeat the previous pattern specified number of "
#~ "times\n"
#~ "  {*}                repeat the previous pattern as many times as "
#~ "possible\n"
#~ "\n"
#~ "A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
#~ msgstr ""
#~ "Partes de saída de ARQUIVO separadas por PADRÕE(s) para arquivos  `xx01', "
#~ "`xx02', ...,\n"
#~ "e contagem de bytes de saída de cada parate para saída padrão.\n"
#~ "\n"
#~ "  -b, --suffix-format=FORMATO use sprintf FORMAT em vez de %%d\n"
#~ "  -f, --prefix=PREFIXO       usar PREFIXO em vez de `xx'\n"
#~ "  -k, --keep-files           não remover arquivos de saída em erros\n"
#~ "  -n, --digits=DIGITOS       usar número especificado de dígitos em vez "
#~ "de 2\n"
#~ "  -s, --quiet, --silent      não imprimir contagem de tamanhos de "
#~ "arquivos de saída\n"
#~ "  -z, --elide-empty-files    remover arquivos de saída vazios\n"
#~ "      --help                 exibir esta ajuda e sair\n"
#~ "      --version              informação da versão de saída e sair\n"
#~ "\n"
#~ "Ler entrada padrão se ARQUIVO for -.  Cada PADRÃO pode ser:\n"
#~ "\n"
#~ "  INTEGER              copiar para mas sem incluir número de linha "
#~ "especificado\n"
#~ "  /REGEXP/[OFFSET]     copiar para mas não incluir uma linha que combina\n"
#~ "  %%REGEXP%%[OFFSET]   saltar para, mas não incluir uma linha que "
#~ "combina\n"
#~ "  {INTEGER}            repetir o esquema anterior especificando o número "
#~ "de vezes\n"
#~ "  {*}                  repetir o esquema anterior tantas vezes quanto "
#~ "possível\n"
#~ "\n"
#~ "Uma linha OFFSET é necessária `+' ou `-' seguida por um positivo "
#~ "inteiro.\n"

# , c-format
#, fuzzy
#~ msgid ""
#~ "Print selected parts of lines from each FILE to standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --bytes=LIST        output only these bytes\n"
#~ "  -c, --characters=LIST   output only these characters\n"
#~ "  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
#~ "  -f, --fields=LIST       output only these fields;  also print any line\n"
#~ "                            that contains no delimiter character, unless\n"
#~ "                            the -s option is specified\n"
#~ "  -n                      (ignored)\n"
#~ "  -s, --only-delimited    do not print lines not containing delimiters\n"
#~ "      --output-delimiter=STRING  use STRING as the output delimiter\n"
#~ "                            the default is to use the input delimiter\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
#~ "range, or many ranges separated by commas.  Each range is one of:\n"
#~ "\n"
#~ "  N     N'th byte, character or field, counted from 1\n"
#~ "  N-    from N'th byte, character or field, to end of line\n"
#~ "  N-M   from N'th to M'th (included) byte, character or field\n"
#~ "  -M    from first to M'th (included) byte, character or field\n"
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ msgstr ""
#~ "Exibe as partes selecionadas de cada ARQUIVO na saída padrão:\n"
#~ "\n"
#~ "  -b, --bytes=LISTA           mostra somente estes bytes\n"
#~ "  -c, --characters=LISTA      mostra somente estes caracteres\n"
#~ "  -d, --delimiter=DELIM       usa DELIM em vez de caracteres de "
#~ "tabulação\n"
#~ "                              para delimitar os campos\n"
#~ "  -f, --fields=LISTA          mostra somente estes campos; também exibe\n"
#~ "                              todas as linhas que não contenham "
#~ "caracteres\n"
#~ "                              delimitadores, a menos que a opção -s seja\n"
#~ "                              especificada\n"
#~ "  -n                          (não tem efeito)\n"
#~ "  -s, --only-delimited        não mostra as linhas que não contém\n"
#~ "                              delimitadores\n"
#~ "      --output-delimiter=STRING  usa STRING como delimitador de saída\n"
#~ "                              o padrão é usar o delimitador de entrada\n"
#~ "      --help                  mostra esta ajuda e finaliza\n"
#~ "      --version               informa a versão e finaliza\n"
#~ "\n"
#~ "Use uma e somente uma das opções -b, -c ou -f. Cada LISTA se compõe\n"
#~ "de uma ou mais faixas separadas por vírgula. Cada faixa pode ser:\n"
#~ "\n"
#~ "   N    o eNésimo byte, caractere ou campo contado desde 1\n"
#~ "   N-   A partir do eNésimo byte, caractere ou campo até o final da "
#~ "linha\n"
#~ "   N-M  Desde o byte, caractere ou campo N até o byte M\n"
#~ "   -M   desde o primeiro byte, caractere ou campo até  a posição M\n"
#~ "\n"
#~ "Se não for passado ARQUIVO, ou quando ARQUIVO é `-', lê-se da entrada "
#~ "padrão.\n"

#~ msgid ""
#~ "For each pair of input lines with identical join fields, write a line to\n"
#~ "standard output.  The default join field is the first, delimited\n"
#~ "by whitespace.  When FILE1 or FILE2 (not both) is -, read standard "
#~ "input.\n"
#~ "\n"
#~ "  -a SIDE           print unpairable lines coming from file SIDE\n"
#~ "  -e EMPTY          replace missing input fields with EMPTY\n"
#~ "  -i, --ignore-case ignore differences in case when comparing fields\n"
#~ "  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
#~ "  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
#~ "  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
#~ "  -o FORMAT         obey FORMAT while constructing output line\n"
#~ "  -t CHAR           use CHAR as input and output field separator\n"
#~ "  -v SIDE           like -a SIDE, but suppress joined output lines\n"
#~ "  -1 FIELD          join on this FIELD of file 1\n"
#~ "  -2 FIELD          join on this FIELD of file 2\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
#~ "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
#~ "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
#~ "each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
#~ "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
#~ "separated by CHAR.\n"
#~ msgstr ""
#~ "Mostra uma linha na saída padrão por cada par de linhas que contenham \n"
#~ "campos idênticos. O campo a comparar por default é o primeiro, "
#~ "delimitado\n"
#~ "por um espaço em branco. Se ARQUIVO1 o ARQUIVO2 é `-' (nunca ambos),\n"
#~ "lê a entrada padrão.\n"
#~ "\n"
#~ "  -a ARQ            mostra linhas não concatenadas do arquivo ARQ\n"
#~ "  -e VAZIO          troca campos inexistentes por VAZIO\n"
#~ "  -i, --ignore-case ignora diferença entre maiúsculas e minúsculas\n"
#~ "  -j CAMPO          (Obsoleto) equivalente a '-1 CAMPO -2 CAMPO'\n"
#~ "  -j1 CAMPO         (Obsoleto) equivalente a '-1 CAMPO'\n"
#~ "  -j2 CAMPO         (Obsoleto) equivalente a '-2 CAMPO'\n"
#~ "  -o FORMATO        utiliza FORMATO para mostrar as linhas de saída\n"
#~ "  -t CHAR           Usa CHAR como delimitador de campos, na entrada e "
#~ "saída\n"
#~ "  -v ARQ            Como -a ARQ, só que mostra as linhas concatenadas\n"
#~ "  -1 CAMPO          concatena neste campo do arquivo 1\n"
#~ "  -2 CAMPO          concatena neste campo do arquivo 2\n"
#~ "      --help        mostra esta ajuda e finaliza\n"
#~ "      --version     informa versão e finaliza\n"
#~ "\n"
#~ "Delimitadores de campos deixados em branco são ignorados, a menos que \n"
#~ "especificado -t CHAR, então campos são delimitados por CHAR. CAMPO é o\n"
#~ "número de campo contado a partir de 1. FORMATO é uma lista de elementos "
#~ "da\n"
#~ "forma `LADO.CAMPO' ou `0', separada por vírgula o por espaços em branco.\n"
#~ "FORMATO por default mostra o campo concatenado, os restantes campos do\n"
#~ "ARQUIVO1 e do ARQUIVO2, todos delimitados por CARACTERE.\n"

# , c-format
#~ msgid ""
#~ "Usage: %s [OPTION] [FILE]...\n"
#~ "  or:  %s [OPTION] --check [FILE]\n"
#~ "Print or check %s (%d-bit) checksums.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "  -b, --binary            read files in binary mode (default on DOS/"
#~ "Windows)\n"
#~ "  -c, --check             check %s sums against given list\n"
#~ "  -t, --text              read files in text mode (default)\n"
#~ "\n"
#~ "The following two options are useful only when verifying checksums:\n"
#~ "      --status            don't output anything, status code shows "
#~ "success\n"
#~ "  -w, --warn              warn about improperly formated checksum lines\n"
#~ "\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "The sums are computed as described in %s.  When checking, the input\n"
#~ "should be a former output of this program.  The default mode is to print\n"
#~ "a line with checksum, a character indicating type (`*' for binary, ` ' "
#~ "for\n"
#~ "text), and name for each FILE.\n"
#~ msgstr ""
#~ "Uso: %s [OPÇÃO] [ARQUIVO]...\n"
#~ " ou: %s [OPÇÃO] --check [ARQUIVO]\n"
#~ "Mostra ou verifica a soma de comprovação (checksum) %s (%d-bit).\n"
#~ "Sem especificação do ARQUIVO ou ARQUIVO é `-', lê da entrada padrão.\n"
#~ "\n"
#~ "  -b, --binary           lê arquivos em modo binário (padrão no DOS/"
#~ "Windows)\n"
#~ "  -c, --check            compara as somas %s com a lista dada\n"
#~ "  -t, --text             lê os arquivos em modo de texto (por padrão)\n"
#~ "\n"
#~ "As duas opções seguintes são úteis apenas para verificar somas de\n"
#~ "comprovação (checksum):\n"
#~ "      --status           não mostra nada, o valor de retorno indica o\n"
#~ "                         resultado\n"
#~ "  -w, --warn             avisa sobre linhas de comprovação de somas MD5\n"
#~ "                         que não estão corretamente formatadas\n"
#~ "\n"
#~ "      --help             mostra esta ajuda e finaliza\n"
#~ "      --version          informa versão e finaliza\n"
#~ "\n"
#~ "As somas se calculam tal e como se descreve em %s. Na verificação, a\n"
#~ "entrada deve ser um resultado anterior deste programa. Por padrão se\n"
#~ "mostra uma linha com a soma de comprovação, um caractere indicando o "
#~ "tipo\n"
#~ "do arquivo (`*' para binário, ` ' para texto), e o nome de cada ARQUIVO.\n"

#, fuzzy
#~ msgid ""
#~ "Write each FILE to standard output, with line numbers added.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
#~ "  -d, --section-delimiter=CC      use CC for separating logical pages\n"
#~ "  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
#~ "  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
#~ "  -i, --page-increment=NUMBER     line number increment at each line\n"
#~ "  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
#~ "one\n"
#~ "  -n, --number-format=FORMAT      insert line numbers according to "
#~ "FORMAT\n"
#~ "  -p, --no-renumber               do not reset line numbers at logical "
#~ "pages\n"
#~ "  -s, --number-separator=STRING   add STRING after (possible) line "
#~ "number\n"
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ "\n"
#~ "  a         number all lines\n"
#~ "  t         number only nonempty lines\n"
#~ "  n         number no lines\n"
#~ "  pREGEXP   number only lines that contain a match for REGEXP\n"
#~ "\n"
#~ "FORMAT is one of:\n"
#~ "\n"
#~ "  ln   left justified, no leading zeros\n"
#~ "  rn   right justified, no leading zeros\n"
#~ "  rz   right justified, leading zeros\n"
#~ "\n"
#~ msgstr ""
#~ "Escreve cada ARQUIVO na saída padrão, com as linhas numeradas.\n"
#~ "Se não for especificado ARQUIVO ou ARQUIVO é `-', lê a entrada padrão.\n"
#~ "\n"
#~ "  -b, --body-numbering=ESTILO   usa ESTILO para a numeração das linhas\n"
#~ "  -d, --section-delimiter=CC    usa CC para separar páginas\n"
#~ "  -f, --footer-numbering=ESTILO usa ESTILO para numerar as linhas finais\n"
#~ "  -h, --header-numbering=ESTILO usa ESTILO para numerar as linhas de "
#~ "cabeçalho\n"
#~ "  -i, --page-increment=NÚMERO   incrementa número de linha em NÚMERO "
#~ "para\n"
#~ "                                cada linha\n"
#~ "  -l, --join-blank-lines=NÚMERO um grupo de NÚMERO linhas vazias se "
#~ "contam\n"
#~ "                                como uma só\n"
#~ "  -n, --number-format=FORMATO   inseri os números de linha com FORMATO\n"
#~ "  -p, --no-renumber             não reinicializa o número de linhas "
#~ "para                                 cada página\n"
#~ "  -s, --number-separator=STRING inclui STRING depois do número de linha\n"
#~ "  -v, --first-page=NÚMERO       primeiro número de linha para cada "
#~ "página\n"
#~ "  -w, --number-width=LARGURA    usa LARGURA colunas para números de "
#~ "linha\n"
#~ "      --help                    mostra esta ajuda e finaliza\n"
#~ "      --version                 informa versão e finaliza\n"
#~ "\n"
#~ "Por default é `-v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn'. `CC' são dois\n"
#~ "caracteres delimitadores para separar páginas; se só especificado um\n"
#~ "deles, o outro se supõe:`.'\n"
#~ "Utilize \\\\ para obter \\. ESTILO pode ser um de o seguintes:\n"
#~ "\n"
#~ "  a       numera todas as linhas\n"
#~ "  t       numera só as linhas não vazias\n"
#~ "  n       não numera nenhuma linha\n"
#~ "  pEXPREG numera só as linhas que coincidem com a expressão regular "
#~ "REGEXP\n"
#~ "\n"
#~ "FORMATO é um dos seguintes:\n"
#~ "\n"
#~ "  ln       justificação a esquerda, sem zeros a  esquerda\n"
#~ "  rn       justificação a direita, sem zeros a esquerda\n"
#~ "  rz       justificação a direita, com zeros a esquerda\n"
#~ "\n"

#, fuzzy
#~ msgid ""
#~ "\n"
#~ "Write an unambiguous representation, octal bytes by default,\n"
#~ "of FILE to standard output.  With more than one FILE argument,\n"
#~ "concatenate them in the listed order to form the input.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -A, --address-radix=RADIX   decide how file offsets are printed\n"
#~ "  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
#~ "  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
#~ "  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
#~ "chars\n"
#~ "  -t, --format=TYPE           select output format or formats\n"
#~ "  -v, --output-duplicates     do not use * to mark line suppression\n"
#~ "  -w, --width[=BYTES]         output BYTES bytes per output line\n"
#~ "      --traditional           accept arguments in pre-POSIX form\n"
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ "\n"
#~ "Pre-POSIX format specifications may be intermixed, they accumulate:\n"
#~ "  -a   same as -t a,  select named characters\n"
#~ "  -b   same as -t oC, select octal bytes\n"
#~ "  -c   same as -t c,  select ASCII characters or backslash escapes\n"
#~ "  -d   same as -t u2, select unsigned decimal shorts\n"
#~ "  -f   same as -t fF, select floats\n"
#~ "  -h   same as -t x2, select hexadecimal shorts\n"
#~ "  -i   same as -t d2, select decimal shorts\n"
#~ "  -l   same as -t d4, select decimal longs\n"
#~ "  -o   same as -t o2, select octal shorts\n"
#~ "  -x   same as -t x2, select hexadecimal shorts\n"
#~ msgstr ""
#~ "Escreve uma representação inequívoca, por default em base octal, de "
#~ "ARQUIVO\n"
#~ "na saída padrão. Se não for especificado ARQUIVO ou ARQUIVO for `-', lê "
#~ "a\n"
#~ "entrada padrão.\n"
#~ "\n"
#~ "  -A, --address-radix=BASE    indica como mostrar as posições do arquivo\n"
#~ "  -N, --read-bytes=BYTES      restringe a saída a BYTES bytes por "
#~ "arquivo\n"
#~ "  -j, --skip-bytes=BYTES      descarta os primeiros BYTES bytes de cada "
#~ "arquivo\n"
#~ "  -s, --strings[=BYTES]       mostra strings de caracteres de pelo menos\n"
#~ "                              BYTES caracteres gráficos\n"
#~ "  -t, --format=TIPO           seleciona o formato de saída\n"
#~ "  -v, --output-duplicates     não usa * para indicar linhas repetidas\n"
#~ "  -w, --width[=BYTES]         mostra BYTES bytes por linha de saída\n"
#~ "      --traditional           aceita os argumentos em formato pre-POSIX\n"
#~ "      --help                  mostra esta ajuda e finaliza\n"
#~ "      --version               informa versão e finaliza\n"
#~ "\n"
#~ "As especificações de formato pre-POSIX podem estar intercalada e se "
#~ "acumularem:\n"
#~ "  -a   o mesmo que -t a,  seleciona os caracteres nomeados\n"
#~ "  -b   o mesmo que -t oC, seleciona bytes em base octal\n"
#~ "  -c   o mesmo que -t c,  seleciona caracteres ASCII ou sequências de\n"
#~ "                          escape\n"
#~ "  -d   o mesmo que -t u2, seleciona decimais curtos(shorts) sem sinal\n"
#~ "  -f   o mesmo que -t fF, seleciona números em ponto flutuante\n"
#~ "  -h   o mesmo que -t x2, seleciona hexadecimais curtos(shorts)\n"
#~ "  -i   o mesmo que -t d2, seleciona decimais curtos(shorts)\n"
#~ "  -l   o mesmo que -t d4, seleciona decimais longos(longs)\n"
#~ "  -o   o mesmo que -t o2, seleciona octais curtos(shorts)\n"
#~ "  -x   o mesmo que -t x2, seleciona hexadecimais curtos(shorts)\n"

#~ msgid ""
#~ "\n"
#~ "For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
#~ "is the pseudo-address at first byte printed, incremented when dump is\n"
#~ "progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
#~ "hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
#~ "\n"
#~ "TYPE is made up of one or more of these specifications:\n"
#~ "\n"
#~ "  a          named character\n"
#~ "  c          ASCII character or backslash escape\n"
#~ "  d[SIZE]    signed decimal, SIZE bytes per integer\n"
#~ "  f[SIZE]    floating point, SIZE bytes per integer\n"
#~ "  o[SIZE]    octal, SIZE bytes per integer\n"
#~ "  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
#~ "  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
#~ "\n"
#~ "SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
#~ "sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
#~ "sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
#~ "for sizeof(double) or L for sizeof(long double).\n"
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
#~ "with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix "
#~ "to\n"
#~ "any type adds a display of printable characters to the end of each line\n"
#~ "of output.  -s without a number implies 3.  -w without a number implies "
#~ "32.\n"
#~ "By default, od uses -A o -t d2 -w 16.\n"
#~ msgstr ""
#~ "\n"
#~ "Na sintaxe antiga, OFFSET significa -j OFFSET. ROTULO\n"
#~ "é o pseudo endereço do primeiro byte mostrado, incrementado quando o "
#~ "\"dump\"\n"
#~ "está sendo processado. Para OFFSET e LABEL, o prefixo 0x ou 0X indica\n"
#~ "hexadecimal, os sufixos poden ser . para octal e b para blocos de 512 "
#~ "bytes.\n"
#~ "\n"
#~ "TIPO é feito com uma o mais de as seguintes especificações:\n"
#~ "\n"
#~ "  a           um determinado caracter\n"
#~ "  c           caracter ASCII ou sequência de escape\n"
#~ "  d[TAMANHO]  decimal com sinal, TAMANHO bytes por cada inteiro\n"
#~ "  f[TAMANHO]  ponto flutuante, TAMANHO bytes por cada inteiro\n"
#~ "  o[TAMANHO]  octal, TAMANHO bytes por cada inteiro\n"
#~ "  u[TAMANHO]  decimal sem sinal, TAMANHO bytes por cada inteiro\n"
#~ "  x[TAMANHO]  hexadecimal, TAMANHO bytes por cada inteiro\n"
#~ "\n"
#~ "TAMANHO é um número.\n"
#~ "Para os TIPOS d o u x, TAMANHO pode ser também:\n"
#~ " C para `sizeof(char)', S para `sizeof(short)', I para `sizeof(int)' ou\n"
#~ " L para `sizeof(long)'.\n"
#~ " Se o TIPO é f, TAMANHO pode ser também:\n"
#~ " F para `sizeof(float)', D para `sizeof(double)' ou\n"
#~ " L para `sizeof(long double)'.\n"
#~ "\n"
#~ "BASE é d para decimal, o para octal, x para hexadecimal o n para "
#~ "nenhuma.\n"
#~ "BYTES é hexadecimal com 0x ou 0X como prefixo, multiplicado por 512 se o\n"
#~ "prefixo é b, por 1024 se é k e por 1048576 se é m. -s sem um número\n"
#~ "implica 3. -w sem um número indica 32. Por default usa `-A o -t d2 -w "
#~ "16'.\n"

#, fuzzy
#~ msgid ""
#~ "Paginate or columnate FILE(s) for printing.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
#~ "                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
#~ "  -COLUMN, --columns=COLUMN\n"
#~ "                    produce COLUMN-column output and print columns down,\n"
#~ "                    unless -a is used. Balance number of lines in the\n"
#~ "                    columns on each page.\n"
#~ "  -a, --across      print columns across rather than down, used together\n"
#~ "                    with -COLUMN\n"
#~ "  -c, --show-control-chars\n"
#~ "                    use hat notation (^G) and octal backslash notation\n"
#~ "  -d, --double-space\n"
#~ "                    double space the output\n"
#~ "  -D, --date-format=FORMAT\n"
#~ "                    use FORMAT for the header date\n"
#~ "  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
#~ "                    expand input CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -F, -f, --form-feed\n"
#~ "                    use form feeds instead of newlines to separate pages\n"
#~ "                    (by a 3-line page header with -F or a 5-line header\n"
#~ "                    and trailer without -F)\n"
#~ msgstr ""
#~ "Paginar ou colunar ARQUIVO(s) para impressão.\n"
#~ "\n"
#~ "  +PRIMERA_PAG[:ÚLTIMA_PAG], --pages=PRIMEIRA_PÁGINA[:ÚLTIMA_PÁGINA]\n"
#~ "                    começa [termina] a imprimir por PRIMERA_[ÚLTIMA_]PAG\n"
#~ "  -COLUNAS, --columns=COLUNA\n"
#~ "                    mostra a saída no número de colunas indicado"
#~ "(COLUNAS),\n"
#~ "                    a menos que se especifique -a. Equilibra o número de\n"
#~ "                    linhas de cada coluna em cada página.\n"
#~ "  -a, --across      cria as colunas transversalmente em vez de em "
#~ "paralelo,\n"
#~ "                    usado em conjunto com -COLUNAS\n"
#~ "  -c  --show-control-chars\n"
#~ "                    mostra os caracteres de controle com notação\n"
#~ "                    circunflexo (^G) ou sequências de escape octais\n"
#~ "  -d  --double-space\n"
#~ "                    saída com espaçamento duplo\n"
#~ "  -D, --date-format=FORMATO\n"
#~ "                    usa FORMATO para a data de cabeçalho\n"
#~ "  -e[CHAR[LARG]], --expand-tabs[CHAR[LARG]]\n"
#~ "                    expande o caractere de tabulação (ou o CHAR) para\n"
#~ "                    LARG (8) espaços\n"
#~ "  -F, -f, --form-feed\n"
#~ "                    usa form feeds em vez de newlines para separar "
#~ "páginas\n"
#~ "                    (com um header de página de 3 linhas com -f ou\n"
#~ "                    de 5 linhas e trailer sem -f)\n"

#~ msgid ""
#~ "  -h HEADER, --header=HEADER\n"
#~ "                    use a centered HEADER instead of filename in page "
#~ "header,\n"
#~ "                    -h \"\" prints a blank line, don't use -h\"\"\n"
#~ "  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
#~ "                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -J, --join-lines  merge full lines, turns off -W line truncation, no "
#~ "column\n"
#~ "                    alignment, -S[STRING] sets separators\n"
#~ "  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
#~ "                    set the page length to PAGE_LENGTH (66) lines\n"
#~ "                    (default number of lines of text 56, and with -F 63)\n"
#~ "  -m, --merge       print all files in parallel, one in each column,\n"
#~ "                    truncate lines, but join lines of full length with -"
#~ "J\n"
#~ "  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
#~ "                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
#~ "                    default counting starts with 1st line of input file\n"
#~ "  -N NUMBER, --first-line-number=NUMBER\n"
#~ "                    start counting with NUMBER at 1st line of first\n"
#~ "                    page printed (see +FIRST_PAGE)\n"
#~ "  -o MARGIN, --indent=MARGIN\n"
#~ "                    offset each line with MARGIN (zero) spaces, do not\n"
#~ "                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
#~ "  -r, --no-file-warnings\n"
#~ "                    omit warning when a file cannot be opened\n"
#~ msgstr ""
#~ "  -h  CABEÇALHO, --header=CABEÇALHO\n"
#~ "                    use um CABEÇALHO centralizado em vez do nome do "
#~ "arquivo\n"
#~ "                    no cabeçalho da página.\n"
#~ "                    -h \"\" mostra uma linha em branco, não use -h\"\"\n"
#~ "  -i[CARACTER[LARGURA]], --output-tabs[=CARACTER[LARGURA]]\n"
#~ "                    substitui os espaços com CARACTERes por LARGURA "
#~ "de                    tabulação (8)\n"
#~ "  -J, --join-lines  une linhas completas, desliga a truncagem de linha -"
#~ "W,\n"
#~ "                    sem alinhamento de colunas\n"
#~ "                    -S[STRING] configura separadores\n"
#~ "  -l COMP_PÁGINA, --length COMP_PÁGINA\n"
#~ "                    configura o comprimento da página para COMP_PÁGINA\n"
#~ "                    (66) linhas (o número padrão de linhas no texto é 56, "
#~ "e\n"
#~ "                    com -F é 63)\n"
#~ "  -m merge          mostra todos os arquivos em paralelo em cada uma "
#~ "das \n"
#~ "                    colunas, trunca linhas, mas une as linhas de \n"
#~ "                    comprimento total com -J\n"
#~ " -n[SEP[DIGITOS]], --number-lines[=SEP[DIGITOS]]\n"
#~ "                    numera linhas, usa DIGITOS (5 digitos) e SEP (TAB),\n"
#~ "                    a contagem padrão inicia com a primeira linha\n"
#~ "                    do arquivo de entrada\n"
#~ "  -N NÚMERO, --first-line-number=NÚMERO\n"
#~ "                    inicia contando com o NÚMERO da primeira linha da\n"
#~ "                    primeira página impressa (veja +PRIMEIRA_PÁGINA)\n"
#~ "  -o MARGEM, --indent=MARGEM\n"
#~ "                    desloca cada linha com MARGEM (zero) espaços, não "
#~ "afeta\n"
#~ "                    -w ou -W, a MARGEM será adicionada a \n"
#~ "                    COMP_PÁGINA\n"
#~ "  -r, --no-file-warnings\n"
#~ "                    omite avisos quando o arquivo não pode ser aberto\n"

#~ msgid ""
#~ "  -s[CHAR],--separator[=CHAR]\n"
#~ "                    separate columns by a single character, default for "
#~ "CHAR\n"
#~ "                    is the <TAB> character without -w and 'no char' with -"
#~ "w\n"
#~ "                    -s[CHAR] turns off line truncation of all 3 column\n"
#~ "                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
#~ "  -S[STRING], --sep-string[=STRING]\n"
#~ "                    separate columns by an optional STRING, don't use\n"
#~ "                    -S \"STRING\", -S only: No separator used (same as -S"
#~ "\"\"),\n"
#~ "                    without -S: Default separator <TAB> with -J and "
#~ "<space>\n"
#~ "                    otherwise (same as -S\" \"), no effect on column "
#~ "options\n"
#~ "  -t, --omit-header omit page headers and trailers\n"
#~ "  -T, --omit-pagination\n"
#~ "                    omit page headers and trailers, eliminate any "
#~ "pagination\n"
#~ "                    by form feeds set in input files\n"
#~ "  -v, --show-nonprinting\n"
#~ "                    use octal backslash notation\n"
#~ "  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters for\n"
#~ "                    multiple text-column output only, -s[char] turns off "
#~ "(72)\n"
#~ "  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters always,\n"
#~ "                    truncate lines, except -J option is set, no "
#~ "interference\n"
#~ "                    with -S or -s\n"
#~ "  --help            display this help and exit\n"
#~ "  --version         output version information and exit\n"
#~ "\n"
#~ "-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
#~ "FILE is -, read standard input.\n"
#~ msgstr ""
#~ "  -s[CARACTERE],--separator[=CARACTERE]\n"
#~ "                    separa as colunas por um caracter simples, o default "
#~ "para                     CARACTERE é o <TAB> caractere sem -w e 'no char' "
#~ "com -w\n"
#~ "                    -s[CHARARACTER] desliga o truncamento de linha das\n"
#~ "                    columas opções (-COLUMA|-a -COLUMA|-m) exeto -w está\n"
#~ "                    configurado\n"
#~ "  -S[STRING], --sep-string[=STRING]\n"
#~ "                    separa as colunas por uma STRING opcional, não use\n"
#~ "                    -S \"STRING\", somente -S\n"
#~ "  -t, --omit-header omite páginas de cabeçalho e trailers\n"
#~ "  -T, --omit-pagination\n"
#~ "                    omite páginas de cabeçalho e trailers, eliminando "
#~ "qualquerpaginação\n"
#~ "  -v, --show-nonprinting\n"
#~ "                    use notação octal para a contra-barra (barra "
#~ "invertida)\n"
#~ "  -w PÁGINA_EXTENSÃO, --width=PÁGINA_EXTENSÃO\n"
#~ "                    configure a extensão da página para (72) characters \n"
#~ "                    para multiplo texto-coluna somente para saída,\n"
#~ "                    -s[caractere] desliga (72)\n"
#~ "  -W PÁGINA_EXTENSÃO, --page-width=PÁGINA_EXTENSÃO\n"
#~ "                    configure a extensao da página para (72) characters\n"
#~ "                    sempre, linhas truncadas, exceto a opcão -J é setada, "
#~ "seminterferencia com -S ou -s\n"
#~ "  --help            mostra esta ajuda e finaliza\n"
#~ "  --version         informa a versao e finaliza\n"
#~ "\n"
#~ "-T implica em -l nn onde nn <= 10 ou <= 3 com -F. Com \"no FILE\", ou "
#~ "onde\n"
#~ "FILE é -, lido na entrada padrão.\n"

#, fuzzy
#~ msgid ""
#~ "Output a permuted index, including context, of the words in the input "
#~ "files.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -A, --auto-reference           output automatically generated "
#~ "references\n"
#~ "  -C, --copyright                display Copyright and copying "
#~ "conditions\n"
#~ "  -G, --traditional              behave more like System V `ptx'\n"
#~ "  -F, --flag-truncation=STRING   use STRING for flagging line "
#~ "truncations\n"
#~ "  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
#~ "  -O, --format=roff              generate output as roff directives\n"
#~ "  -R, --right-side-refs          put references at right, not counted in -"
#~ "w\n"
#~ "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
#~ "  -T, --format=tex               generate output as TeX directives\n"
#~ "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
#~ "  -b, --break-file=FILE          word break characters in this FILE\n"
#~ "  -f, --ignore-case              fold lower case to upper case for "
#~ "sorting\n"
#~ "  -g, --gap-size=NUMBER          gap size in columns between output "
#~ "fields\n"
#~ "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
#~ "  -o, --only-file=FILE           read only word list from this FILE\n"
#~ "  -r, --references               first field of each line is a reference\n"
#~ "  -t, --typeset-mode               - not implemented -\n"
#~ "  -w, --width=NUMBER             output width in columns, reference "
#~ "excluded\n"
#~ "      --help                     display this help and exit\n"
#~ "      --version                  output version information and exit\n"
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
#~ msgstr ""
#~ "Os argumentos obrigatórios para as opções largas são também obrigatórios "
#~ "para as opções curtas.\n"
#~ "  -A, --auto-reference           output automatically generated "
#~ "references\n"
#~ "  -C, --copyright                display Copyright and copying "
#~ "conditions\n"
#~ "  -G, --traditional              behave more like System V `ptx'\n"
#~ "  -F, --flag-truncation=STRING   use STRING for flagging line "
#~ "truncations\n"
#~ "  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
#~ "  -O, --format=roff              generate output as roff directives\n"
#~ "  -R, --right-side-refs          put references at right, not counted in -"
#~ "w\n"
#~ "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
#~ "  -T, --format=tex               generate output as TeX directives\n"

#~ msgid ""
#~ "Other options:\n"
#~ "\n"
#~ "  -c, --check               check whether input is sorted; do not sort\n"
#~ "  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin "
#~ "1)\n"
#~ "  -m, --merge               merge already sorted files; do not sort\n"
#~ "  -o, --output=FILE         write result to FILE instead of standard "
#~ "output\n"
#~ "  -s, --stable              stabilize sort by disabling last-resort "
#~ "comparison\n"
#~ "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
#~ "  -t, --field-separator=SEP use SEP instead of non- to whitespace "
#~ "transition\n"
#~ "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %"
#~ "s\n"
#~ "                              multiple options specify multiple "
#~ "directories\n"
#~ "  -u, --unique              with -c: check for strict ordering\n"
#~ "                              otherwise: output only the first of an "
#~ "equal run\n"
#~ "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolescent\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Outras opções:\n"
#~ "\n"
#~ "  -c, --check               verifica se a entrada está classificada; não "
#~ "classifica\n"
#~ "  -k, --key=POS1[,POS2]     inicia uma chave em POS1, finaliza em POS 2 "
#~ "(origem 1)\n"
#~ "  -m, --merge               mescla arquivos já classificados; não "
#~ "classifica\n"
#~ "  -o, --output=ARQUIVO      escreve resultado no ARQUIVO em vez da saída "
#~ "padrão\n"
#~ "  -s, --stable              estabiliza classificação desabilitando a "
#~ "comparação last-resort\n"
#~ "  -S, --buffer-size=TAMANHO usa TAMANHO para o buffer principal de "
#~ "memória\n"
#~ "  -t, --field-separator=SEP usa SEP no lugar de non- para transição de "
#~ "espaços\n"
#~ "  -T, --temporary-directory=DIR  usa DIR para temporários, não $TMPDIR ou "
#~ "%s\n"
#~ "                              múltiplas opções especificam múltiplos "
#~ "diretórios\n"
#~ "  -u, --unique              com -c: verifica ordenação restrita\n"
#~ "                              caso contrário: exterioriza apenas o "
#~ "primeiro de uma execução\n"
#~ "                              igual\n"
#~ "  -z, --zero-terminated     termina linhas com o byte 0, não fim-de-"
#~ "linha\n"
#~ "  +POS1 [-POS2]             inicia uma chave em POS1, termina antes de "
#~ "POS2 (origem 0)\n"
#~ "                              Atenção: esta opção é obsoleta\n"
#~ "      --help       exibe esta ajuda e finaliza\n"
#~ "      --version    exibe informações da versão e finaliza\n"
#~ "\n"

#, fuzzy
#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                           inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                           inaccessible later -- useful only with -f\n"
#~ "  -c, --bytes=N            output the last N bytes\n"
#~ "  -f, --follow[={name|descriptor}]\n"
#~ "                           output appended data as the file grows;\n"
#~ "                           -f, --follow, and --follow=descriptor are\n"
#~ "                           equivalent\n"
#~ "  -F                       same as --follow=name --retry\n"
#~ "  -n, --lines=N            output the last N lines, instead of the last %"
#~ "d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           with --follow=name, reopen a FILE which has "
#~ "not\n"
#~ "                           changed size after N (default %d) iterations\n"
#~ "                           to see if it has been unlinked or renamed\n"
#~ "                           (this is the usual case of rotated log files)\n"
#~ "      --pid=PID            with -f, terminate after process ID, PID dies\n"
#~ "  -q, --quiet, --silent    never output headers giving file names\n"
#~ "  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
#~ "                           (default 1) seconds\n"
#~ "  -v, --verbose            always output headers giving file names\n"
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Imprime as últimas %d linhas de cada ARQUIVO na saída padrão.\n"
#~ "Com mais de um ARQUIVO, precede cada com um cabeçalho dado no nome do "
#~ "arquivo.\n"
#~ "Sem ARQUIVO, ou quando ARQUIVO for -, ler entrada padrão.\n"
#~ "\n"
#~ "      --retry              continuar tentando abrir um arquivo mesmo se "
#~ "for \n"
#~ "                             inacessível quando 'tail' inicia ou se for\n"
#~ "                             inacessível mais tarde  -- útil somente com -"
#~ "f\n"
#~ "  -c, --bytes=N            apresentar saída dos últimos N bytes\n"
#~ "  -f, --follow[={nome|descritor}] mostra dados anexados conforme o "
#~ "arquivo\n"
#~ "                             aumenta; -f, --follow, e --follow=descritor "
#~ "são\n"
#~ "                             equivalentes\n"
#~ "  -n, --lines=N            apresentar a saída das últimas N linhas, em "
#~ "vez da última %d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           com --follow=nome, reabre um ARQUIVO que não\n"
#~ "                           foi alterado após N (o padrão é %d) iterações\n"
#~ "                           para ver se ele foi removido ou renomeado\n"
#~ "                           (este é o caso normal de arquivos de log\n"
#~ "                           rotacionados)\n"
#~ "      --pid=PID            com -f, terminado após processo ID, PID morre\n"
#~ "  -q, --quiet, --silent    nunca colocar cabeçalhos na saída dando nomes "
#~ "de arquivos\n"
#~ "  -s, --sleep-interval=S   com -f, espera S segundos (o padrão é 1) "
#~ "entre\n"
#~ "                           as iterações\n"
#~ "  -v, --verbose            sempre colocar cabeçalhos na saída dando nomes "
#~ "de arquivos\n"
#~ "      --help               mostra esta ajuda e sai\n"
#~ "      --version            mostra informações da versão e sai\n"
#~ "\n"

#~ msgid ""
#~ "If the first character of N (the number of bytes or lines) is a `+',\n"
#~ "print beginning with the Nth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last N items in the file.  N may have a multiplier suffix:\n"
#~ "b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
#~ "or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
#~ "the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
#~ "or -c +VALUE.  Warning: a first option of +VALUE is obsolescent, and "
#~ "support\n"
#~ "for it will be withdrawn.\n"
#~ "\n"
#~ "With --follow (-f), tail defaults to following the file descriptor, "
#~ "which\n"
#~ "means that even if a tail'ed file is renamed, tail will continue to "
#~ "track\n"
#~ "its end.  This default behavior is not desirable when you really want to\n"
#~ "track the actual name of the file, not the file descriptor (e.g., log\n"
#~ "rotation).  Use --follow=name in that case.  That causes tail to track "
#~ "the\n"
#~ "named file by reopening it periodically to see if it has been removed "
#~ "and\n"
#~ "recreated by some other program.\n"
#~ "\n"
#~ msgstr ""
#~ "Se o primeiro caracter de N (o número de bytes ou linhas) for um `+',\n"
#~ "imprime iniciando no eNésimo ítem a partir do início de cada arquivo,\n"
#~ "caso contrário, imprime os últimos N ítens no arquivo. N pode ter um\n"
#~ "sufixo multiplicador: b para 512, k para 1024, m para 1048576 (1 Meg).\n"
#~ "Uma primeira OPÇÃO de -VALUE ou +VALUE é tratada como -n VALUE ou\n"
#~ "-n +VALUE a menos que VALUE tenha um dos multiplicadores de sufixo\n"
#~ "[bkm], caso em que é tratado como -c VALUE ou -c +VALUE. Atenção: uma\n"
#~ "primeira opção de +VALUE é obsoleta e o suporte a ela será extinto.\n"
#~ "\n"
#~ "Com --follow (-f), o padrão do tail é seguir o descritor de arquivos,\n"
#~ "o que significa que mesmo se um arquivo no qual tenha sido aplicado um\n"
#~ "tail for renomeado, o tail irá continuar a rastrear seu final. Este\n"
#~ "comportamento padrão não é desejável quando você realmente quer rastrear\n"
#~ "o nome real do arquivo, e não o descritor do arquivo (por exemplo,\n"
#~ "rotação do log). Use --follow=name neste caso. Isto faz com que o tail\n"
#~ "rastreie o arquivo reabrindo-o periodicamente para ver se ele foi\n"
#~ "removido e recriado por algum outro programa.\n"
#~ "\n"

#~ msgid ""
#~ "\n"
#~ "SETs are specified as strings of characters.  Most represent themselves.\n"
#~ "Interpreted sequences are:\n"
#~ "\n"
#~ "  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
#~ "  \\\\              backslash\n"
#~ "  \\a              audible BEL\n"
#~ "  \\b              backspace\n"
#~ "  \\f              form feed\n"
#~ "  \\n              new line\n"
#~ "  \\r              return\n"
#~ "  \\t              horizontal tab\n"
#~ "  \\v              vertical tab\n"
#~ "  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
#~ "  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
#~ "  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
#~ "  [:alnum:]       all letters and digits\n"
#~ "  [:alpha:]       all letters\n"
#~ "  [:blank:]       all horizontal whitespace\n"
#~ "  [:cntrl:]       all control characters\n"
#~ "  [:digit:]       all digits\n"
#~ "  [:graph:]       all printable characters, not including space\n"
#~ "  [:lower:]       all lower case letters\n"
#~ "  [:print:]       all printable characters, including space\n"
#~ "  [:punct:]       all punctuation characters\n"
#~ "  [:space:]       all horizontal or vertical whitespace\n"
#~ "  [:upper:]       all upper case letters\n"
#~ "  [:xdigit:]      all hexadecimal digits\n"
#~ "  [=CHAR=]        all characters which are equivalent to CHAR\n"
#~ msgstr ""
#~ "\n"
#~ "Os CONJUNTOs são especificados como strings de caracteres. A maior parte\n"
#~ "representa eles mesmos.\n"
#~ " As sequências válidas são as seguintes:\n"
#~ "\n"
#~ "  \\NNN            caractere com valor octal NNN (de um a três dígitos)\n"
#~ "  \\\\             barra invertida\n"
#~ "  \\a              beep audível (BEL)\n"
#~ "  \\b              backspace\n"
#~ "  \\f              salto de página\n"
#~ "  \\n              salto de linha\n"
#~ "  \\r              retorno de carro\n"
#~ "  \\t              tabulação horizontal\n"
#~ "  \\v              tabulação vertical\n"
#~ "  CAR1-CAR2       todos os caracteres de CAR1 a CAR2 em ordem ascendente\n"
#~ "  [CAR*]          em CONJUNTO2, copia de CAR até que se alcance a "
#~ "largura\n"
#~ "                  de CONJUNTO1\n"
#~ "  [CAR*REPETE]    copia REPETE vezes CAR; REPETE é octal se começa com 0\n"
#~ "  [:alnum:]       todas as letras e dígitos\n"
#~ "  [:alpha:]       todas as letras\n"
#~ "  [:blank:]       todos os espaços em branco horizontais\n"
#~ "  [:cntrl:]       todos os caracteres de control\n"
#~ "  [:digit:]       todos os dígitos\n"
#~ "  [:graph:]       todos os caracteres imprimíveis, sem incluir o espaço\n"
#~ "  [:lower:]       todas as letras minúsculas\n"
#~ "  [:print:]       todos os caracteres imprimíveis, incluindo o espaço\n"
#~ "  [:punct:]       todos os caracteres de pontuação\n"
#~ "  [:space:]       todos os espaços em branco horizontais e verticais\n"
#~ "  [:upper:]       todas as letras maiúsculas\n"
#~ "  [:xdigit:]      todos os números hexadecimais\n"
#~ "  [=CAR=]         todos os caracteres que são iguais a CAR\n"

#, fuzzy
#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -c, --count           prefix lines by the number of occurrences\n"
#~ "  -d, --repeated        only print duplicate lines\n"
#~ "  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
#~ "                        delimit-method={none(default),prepend,separate)}\n"
#~ "                        Delimiting is done with blank lines.\n"
#~ "  -f, --skip-fields=N   avoid comparing the first N fields\n"
#~ "  -i, --ignore-case     ignore differences in case when comparing\n"
#~ "  -s, --skip-chars=N    avoid comparing the first N characters\n"
#~ "  -u, --unique          only print unique lines\n"
#~ "  -w, --check-chars=N   compare no more than N characters in lines\n"
#~ "  -N                    same as -f N\n"
#~ "  +N                    same as -s N (obsolescent; will be withdrawn)\n"
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ "\n"
#~ "A field is a run of whitespace, then non-whitespace characters.\n"
#~ "Fields are skipped before chars.\n"
#~ msgstr ""
#~ "Descarta todas (menos uma) as linhas sucessivas idênticas de ENTRADA\n"
#~ "(ou entrada padrão), escrevendo em SAÍDA (ou na saída padrão).\n"
#~ "\n"
#~ "   -c, --count          preceder as linhas com o número de ocorrências\n"
#~ "   -d, --repeated       mostrar só as linhas duplicadas\n"
#~ "   -D, --all-repeated   mostra todas as linhas duplicadas\n"
#~ "   -f, --skip-fields=N  ignorar os primeiros N campos\n"
#~ "   -i, --ignore-case    ignorar as diferenças entre maiúsculas e\n"
#~ "                        minúsculas\n"
#~ "   -s, --skip-chars=N   ignorar os primeiros N caracteres\n"
#~ "   -u, --unique         mostrar só as linhas que são únicas\n"
#~ "   -w, --check-chars=N  só comparar os primeiros N caracteres da linha\n"
#~ "   -N                   o mesmo que -f N\n"
#~ "   +N                   o mesmo que -s N (obsoleto; será extinto)\n"
#~ "       --help           mostrar esta ajuda e sair\n"
#~ "       --version        mostrar a versão e sair\n"
#~ "\n"
#~ "Um campo é cada conjunto de caracteres separados por espaços.\n"
#~ "Os campos são ignorados antes dos caracteres.\n"

#, fuzzy
#~ msgid "Copyright (C) 2001 Free Software Foundation, Inc."
#~ msgstr "Copyright (C) 2001 Free Software Foundation, Inc."
