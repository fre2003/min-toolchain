# traditional Chinese translation for textutils.
# Copyright (C) 1998, 2002 Free Software Foundation, Inc.
# Yuan-Chung Cheng <platin@ms.ccafps.khc.edu.tw>, 1998.
# Abel Cheung <maddog@linux.org.hk>, 2002.
#
msgid ""
msgstr ""
"Project-Id-Version: textutils 2.0.21\n"
"POT-Creation-Date: 2002-07-29 10:41+0200\n"
"PO-Revision-Date: 2002-06-18 21:09+0800\n"
"Last-Translator: Abel Cheung <maddog@linux.org.hk>\n"
"Language-Team: Chinese (traditional) <zh-l10n@linux.org.tw>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8-bit\n"

#: lib/argmatch.c:161
#, c-format
msgid "invalid argument %s for %s"
msgstr "%2$s 的引數 %1$s 無效"

#: lib/argmatch.c:162
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "%2$s 的引數 %1$s 不明確"

#: lib/argmatch.c:181
msgid "Valid arguments are:"
msgstr "有效的引數為："

#: lib/c-stack.c:368
#, fuzzy
msgid "program error"
msgstr "讀取時發生錯誤"

#: lib/c-stack.c:369
msgid "stack overflow"
msgstr ""

#: lib/closeout.c:107 src/cat.c:186 src/cat.c:267 src/cat.c:320
#: src/cksum.c:267 src/head.c:152 src/head.c:195 src/tail.c:327
#: src/tail.c:1651 src/tr.c:1667 src/tr.c:1913 src/tr.c:2021
msgid "write error"
msgstr "寫入時發生錯誤"

#: lib/error.c:129 lib/error.c:157
msgid "Unknown system error"
msgstr "不明的系統錯誤"

#: lib/file-type.c:42
msgid "regular empty file"
msgstr ""

#: lib/file-type.c:42
#, fuzzy
msgid "regular file"
msgstr "讀入時發生錯誤"

#: lib/file-type.c:45
msgid "directory"
msgstr ""

#: lib/file-type.c:48
#, fuzzy
msgid "block special file"
msgstr "區塊大小錯誤"

#: lib/file-type.c:51
#, fuzzy
msgid "character special file"
msgstr "字元偏移值是 0"

#: lib/file-type.c:54
msgid "fifo"
msgstr ""

#: lib/file-type.c:57
msgid "symbolic link"
msgstr ""

#: lib/file-type.c:60
msgid "socket"
msgstr ""

#: lib/file-type.c:63
msgid "message queue"
msgstr ""

#: lib/file-type.c:66
msgid "semaphore"
msgstr ""

#: lib/file-type.c:69
msgid "shared memory object"
msgstr ""

#: lib/file-type.c:71
#, fuzzy
msgid "weird file"
msgstr "讀入時發生錯誤"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s：選項‘%s’不明確\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s：選項‘--%s’不可配合引數使用\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s：選項‘%c%s’不可配合引數使用\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s：選項‘%s’需要引數\n"

#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s：無法識別的選項‘--%s’\n"

#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s：無法識別的選項‘%c%s’\n"

#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s：不合法的選項 ─ %c\n"

#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s：無效的選項 ─ %c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s：選項需要引數 ─ %c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s：選項‘-W %s’不明確\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s：選項‘-W %s’不可配合引數使用\n"

#: lib/human.c:365
msgid "block size"
msgstr "區塊大小錯誤"

#: lib/makepath.c:176
#, c-format
msgid "cannot create directory %s"
msgstr "無法建立目錄 %s"

#: lib/makepath.c:182 lib/makepath.c:423
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s 已存在但不是目錄"

#: lib/makepath.c:319 lib/makepath.c:381 lib/makepath.c:442
#, c-format
msgid "cannot change owner and/or group of %s"
msgstr "無法更改 %s 的擁有者和/或所屬群組"

#: lib/makepath.c:341
#, fuzzy, c-format
msgid "cannot chdir to directory %s"
msgstr "無法進入目錄 %s"

#: lib/makepath.c:395 lib/makepath.c:448
#, c-format
msgid "cannot change permissions of %s"
msgstr "無法更改 %s 的權限"

#: lib/obstack.c:494 lib/obstack.c:497 lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "記憶體耗盡"

#: lib/quotearg.c:270
msgid "`"
msgstr "‘"

#: lib/quotearg.c:271
msgid "'"
msgstr "’"

#: lib/rpmatch.c:78
msgid "^[yY]"
msgstr "^[yY]"

#: lib/rpmatch.c:81
msgid "^[nN]"
msgstr "^[nN]"

#: lib/unicodeio.c:159
msgid "iconv function not usable"
msgstr "iconv 功能無法使用"

#: lib/unicodeio.c:161
msgid "iconv function not available"
msgstr "iconv 功能不存在"

#: lib/unicodeio.c:168
msgid "character out of range"
msgstr "字元值超出可接受的範圍以外"

#: lib/unicodeio.c:231
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "無法將 U+%04X 轉換至使用者的字元集"

#: lib/unicodeio.c:233
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "無法將 U+%04X 轉換至使用者的字元集：%s"

#: lib/userspec.c:178
msgid "invalid user"
msgstr "無效的使用者"

#: lib/userspec.c:179
msgid "invalid group"
msgstr "無效的群組"

#: lib/userspec.c:181
msgid "cannot get the login group of a numeric UID"
msgstr "無法取得 UID 數值所代表的登入群組"

#: lib/userspec.c:183
msgid "cannot omit both user and group"
msgstr "不可同時省略使用者和所屬群組"

#: lib/version-etc.c:61
#, c-format
msgid "Written by %s.\n"
msgstr "由 %s 編寫。\n"

#: lib/version-etc.c:67
msgid ""
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"這是自由軟體；請參考原始碼的版權聲明。本軟體不提供任何保證，甚至不會包括\n"
"可售性或適用於任何特定目的的保證。\n"

#: lib/xmemcoll.c:61
msgid "string comparison failed"
msgstr "字串比較出現錯誤"

#: lib/xmemcoll.c:62
msgid "Set LC_ALL='C' to work around the problem."
msgstr "請設定 LC_ALL='C' 避免問題出現。"

#: lib/xmemcoll.c:64
#, c-format
msgid "The strings compared were %s and %s."
msgstr "要比較的字串為 %s 及 %s。"

#: src/cat.c:42 src/split.c:42
msgid "Torbjorn Granlund and Richard M. Stallman"
msgstr "Torbjorn Granlund 及 Richard M. Stallman"

#: src/cat.c:88 src/cksum.c:276 src/comm.c:69 src/csplit.c:1490 src/cut.c:163
#: src/expand.c:106 src/fmt.c:267 src/fold.c:63 src/head.c:84 src/join.c:140
#: src/md5sum.c:121 src/nl.c:172 src/od.c:287 src/paste.c:399 src/pr.c:2752
#: src/ptx.c:1855 src/sort.c:275 src/split.c:91 src/sum.c:56 src/tac.c:123
#: src/tail.c:234 src/tr.c:323 src/tsort.c:93 src/unexpand.c:371
#: src/uniq.c:130 src/wc.c:124
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "請嘗試執行‘%s --help’來獲取更多資訊。\n"

#: src/cat.c:92
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "用法：%s [選項] [檔案]...\n"

#: src/cat.c:96
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
msgstr ""
"將由<檔案>或標準輸入讀取的資料連結起來，並在標準輸出顯示。\n"
"\n"
"  -A, --show-all           等於 -vET\n"
"  -b, --number-nonblank    輸出時在非空白行加上行號\n"
"  -e                       等於 -vE\n"
"  -E, --show-ends          在每一行最後顯示 $ 記號\n"
"  -n, --number             輸出時加上行號\n"
"  -s, --squeeze-blank      不連續輸出超過一行空行\n"

#: src/cat.c:106
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       等於 -vT\n"
"  -T, --show-tabs          將 TAB 字元顯示為 ^I\n"
"  -u                       (此選項不作處理)\n"
"  -v, --show-nonprinting   除了換行及 TAB 字元外，使用 ^ 及 M- 表示法顯示字"
"元\n"

#: src/cat.c:114 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/cat.c:119
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             (DOS/Windows)以二元碼模式將資料輸出至畫面。\n"
"\n"

#: src/cat.c:124 src/cksum.c:291 src/comm.c:86 src/csplit.c:1532 src/cut.c:208
#: src/expand.c:131 src/fmt.c:297 src/fold.c:86 src/head.c:115 src/join.c:180
#: src/md5sum.c:157 src/nl.c:227 src/od.c:374 src/paste.c:423 src/pr.c:2864
#: src/sort.c:346 src/split.c:123 src/sum.c:76 src/tac.c:146 src/tail.c:304
#: src/tr.c:396 src/tsort.c:105 src/unexpand.c:394 src/uniq.c:169 src/wc.c:146
#, fuzzy, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"請向 <bug-textutils@gnu.org> 回報錯誤。"

#: src/cat.c:308
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "沒辦法對 `%s' 執行輸出入控制 (ioctl)"

#: src/cat.c:647 src/od.c:1014
msgid "standard output"
msgstr "標準輸出"

#: src/cat.c:778
#, c-format
msgid "%s: input file is output file"
msgstr "%s：輸出和輸入檔案是相同的"

#: src/cksum.c:234
#, c-format
msgid "%s: file too long"
msgstr "%s：檔案過大"

#: src/cksum.c:280
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [檔案]...\n"
"  或：%s [選項]\n"

#: src/cksum.c:285
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"印出每個<檔案>的 CRC 總和檢查值及位元組總數。\n"
"\n"

#: src/comm.c:35 src/uniq.c:38
msgid "Richard Stallman and David MacKenzie"
msgstr "Richard Stallman 及 David MacKenzie"

#: src/comm.c:73
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "用法：%s [選項]... LEFT_FILE RIGHT_FILE\n"

#: src/comm.c:77
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines that appear in both files\n"
msgstr ""
"逐行比較兩個已排序的檔案 LEFT_FILE 及 RIGHT_FILE。\n"
"\n"
"  -1              不顯示任何一行只在 LEFT_FILE 出現過的資料\n"
"  -2              不顯示任何一行只在 RIGHT_FILE 出現過的資料\n"
"  -3              不顯示兩個檔案中同時出現的任何一行\n"

#: src/csplit.c:41
msgid "Stuart Kemp and David MacKenzie"
msgstr "Stuart Kemp 及 David MacKenzie"

#: src/csplit.c:290 src/csplit.c:1479 src/tac-pipe.c:57 src/tr.c:1609
#: src/tr.c:1712 src/tr.c:1755
msgid "read error"
msgstr "讀取時發生錯誤"

#: src/csplit.c:584
msgid "input disappeared"
msgstr "輸入資料消失了"

#: src/csplit.c:706 src/csplit.c:717
#, c-format
msgid "%s: line number out of range"
msgstr "%s：行號超出範圍以外"

#: src/csplit.c:744
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s：‘%s’：行號超出範圍以外"

#: src/csplit.c:747 src/csplit.c:793
#, c-format
msgid " on repetition %d\n"
msgstr "（在第 %d 次重覆時）\n"

#: src/csplit.c:789
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s：‘%s’：找不到符合的字串"

#: src/csplit.c:850 src/csplit.c:890 src/tac.c:262
msgid "error in regular expression search"
msgstr "在正規運算式搜尋時發生錯誤"

#: src/csplit.c:993
#, c-format
msgid "write error for `%s'"
msgstr "寫入‘%s’時發生錯誤"

#: src/csplit.c:1065
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s：分隔符號後面應該是‘+’或‘-’字元"

#: src/csplit.c:1069
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s：‘%c’後面應該是整數"

#: src/csplit.c:1089
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s：重覆的數目後應該是‘}’字元"

#: src/csplit.c:1099
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}：‘{’和‘}’之間必須是整數"

#: src/csplit.c:1126
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s：缺少了封閉分隔符號‘%c’"

#: src/csplit.c:1142
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s：無效的正規表示式：%s"

#: src/csplit.c:1175
#, c-format
msgid "%s: invalid pattern"
msgstr "%s：無效的樣式"

#: src/csplit.c:1178
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s：行號必須大於零"

#: src/csplit.c:1184
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "行號‘%s’小於之前的行號‘%s’"

#: src/csplit.c:1190
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "警告：行號‘%s’和之前的行號一樣"

#: src/csplit.c:1312
msgid "missing conversion specifier in suffix"
msgstr "後置字串缺少了字串轉換字符"

#: src/csplit.c:1318
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "後置字串的字串轉換字符無效：%c"

#: src/csplit.c:1321
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "後置字串的字串轉換字符無效：\\%.3o"

#: src/csplit.c:1353
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "後置字串缺少了 %% 字串轉換規格"

#: src/csplit.c:1356
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "後置字串含有過多的 %% 字串轉換規格"

#: src/csplit.c:1439
#, c-format
msgid "%s: invalid number"
msgstr "%s：無效的號碼"

#: src/csplit.c:1462
msgid "too few arguments"
msgstr "引數過少"

#: src/csplit.c:1494
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "用法：%s [選項]... 檔案 樣式...\n"

#: src/csplit.c:1498
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"根據<樣式>分割<檔案>，並將之輸出至‘xx01’、‘xx02’等等的檔案，\n"
"同時在標準輸出顯示每個分割部份的位元組數目。\n"

#: src/csplit.c:1503 src/cut.c:175 src/expand.c:119 src/fmt.c:277
#: src/fold.c:76 src/head.c:98 src/nl.c:185 src/paste.c:413 src/pr.c:2765
#: src/ptx.c:1867 src/sort.c:289 src/split.c:104 src/tac.c:136 src/tail.c:248
#: src/unexpand.c:384 src/uniq.c:143
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr "長選項必須用的引數在使用短選項時也是必須的。\n"

#: src/csplit.c:1506
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=格式   以 sprintf 的<格式>代替 %d\n"
"  -f, --prefix=前置字串      以<前置字串>代替‘xx’\n"
"  -k, --keep-files           遇到錯誤時不移除輸出檔\n"

#: src/csplit.c:1511
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=位數          使用指定位數的數字而不是 2 個位\n"
"  -s, --quiet, --silent      不印出輸出檔的大小\n"
"  -z, --elide-empty-files    移除空白的輸出檔\n"

#: src/csplit.c:1518
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"若<檔案>是 - 則由標準輸入讀取資料。每一個<樣式>可以是：\n"

#: src/csplit.c:1522
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  整數                   複製直至指定行數之前的一行\n"
"  /正規表示式/[偏移值]   複製直至符合表示式之前的一行\n"
"  %正規表示式%[偏移值]   忽略直至符合表示式之前的一行\n"
"  {整數}                 將之前的樣式重覆指定的次數\n"
"  {*}                    將之前的樣式重覆最大可能的次數\n"
"\n"
"行號偏移值是一個(必須的)‘+’或‘-’字元加上一個正整數。\n"

#: src/cut.c:39
msgid "David Ihnat, David MacKenzie, and Jim Meyering"
msgstr "David Ihnat、David MacKenzie 及 Jim Meyering"

#: src/cut.c:167 src/expand.c:110 src/fold.c:67 src/head.c:88 src/nl.c:176
#: src/paste.c:403 src/pr.c:2756 src/sort.c:279 src/sum.c:60 src/tac.c:127
#: src/tail.c:238 src/unexpand.c:375 src/wc.c:128
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法：%s [選項]... [檔案]...\n"

#: src/cut.c:171
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr "在標準輸出印出每個<檔案>被選取的部份。\n"

#: src/cut.c:178
msgid ""
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=LIST        只輸出指定的位元組\n"
"  -c, --characters=LIST   只輸出指定的字元\n"
"  -d, --delimiter=DELIM   以 DELIM 字元代替 TAB 作為欄位的分隔符號\n"

#: src/cut.c:183
msgid ""
"  -f, --fields=LIST       output only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=LIST       只輸出指定的欄位；同時也印出不含分隔符號的\n"
"                            每一行，除非使用了 -s 選項\n"
"  -n                      (不會作任何處理)\n"

#: src/cut.c:189
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    不印出不含分隔符號的每一行\n"
"      --output-delimiter=字串  以<字串>作為輸出資料的分隔符號\n"
"                                 預設是使用輸入資料的分隔符號\n"

#: src/cut.c:196
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"必須恰好指定 -b、-c 或 -f 其中一個選項。每個 LIST 是由一個範圍或是\n"
"多個以逗號分隔的範圍組成的。每個範圍可以是：\n"
"\n"
"  N     由 1 開始計算，只取第 N 個位元組、字元或欄位\n"
"  N-    由第 N 個位元組、字元或欄位直至行末\n"
"  N-M   由第 N 至第 M（包括在內）個位元組、字元或欄位\n"
"  -M    由第 1 至第 M（包括在內）個位元組、字元或欄位\n"
"\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/cut.c:263 src/cut.c:294 src/cut.c:354
msgid "invalid byte or field list"
msgstr "無效的位元組或欄位選項"

#: src/cut.c:624 src/cut.c:633
msgid "only one type of list may be specified"
msgstr "只能指定一種種類的位置"

#: src/cut.c:627
msgid "missing list of positions"
msgstr "缺少了表示位置的數值"

#: src/cut.c:636
msgid "missing list of fields"
msgstr "缺少了欄位數值"

#: src/cut.c:643
msgid "the delimiter must be a single character"
msgstr "分隔符號必須是恰好一個字元"

#: src/cut.c:673
msgid "you must specify a list of bytes, characters, or fields"
msgstr "必須指定一系列的位元組、字元或欄位"

#: src/cut.c:676
msgid "a delimiter may be specified only when operating on fields"
msgstr "只有在處理欄位時才能指定分隔符號"

#: src/cut.c:679
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr "只有在處理欄位時才能指定去除缺少分隔符號的每一行"

#: src/expand.c:114
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"將每個<檔案>中的 tab 轉換為空格，並在標準輸出顯示。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/expand.c:122
msgid ""
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       不轉換非空白字元後的 TAB 字元\n"
"  -t, --tabs=數目     將 tab 轉換為指定<數目>的空格而不是 8 個\n"

#: src/expand.c:126
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr "  -t, --tabs=LIST     用以逗號分隔的數字來指定 tab 的位置\n"

#: src/expand.c:173 src/unexpand.c:153
msgid "tab size contains an invalid character"
msgstr "tab 字元寬度含有無效的字元"

#: src/expand.c:191 src/unexpand.c:171
msgid "tab size cannot be 0"
msgstr "tab 字元寬度不可為 0"

#: src/expand.c:193 src/unexpand.c:173
msgid "tab sizes must be ascending"
msgstr "tab 字元位置必須由小至大"

#: src/expand.c:386
msgid "`-LIST' option is obsolete; use `-t LIST'"
msgstr "‘-LIST’選項已經過時；請使用‘-t LIST’"

#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "用法：%s [-數字] [選項]... [檔案]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
msgstr ""
"重新編排<檔案>中的每一段文字，並在標準輸出顯示結果。\n"
"如果沒有指定<檔案>或<檔案>是‘-’，則由標準輸入讀取資料。\n"
"\n"

#: src/fmt.c:280
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        保留最初兩行的縮排方式\n"
"  -p, --prefix=字串         只合併含有指定前置<字串>的每一行\n"
"  -s, --split-only          只將一行過長的資料分開，而不合併多於一行的資料\n"

#: src/fmt.c:286
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph    第一和第二行的縮排方式不同\n"
"  -u, --uniform-spacing     每兩個字之間以一個空格分隔，句子後則用兩個空格\n"
"  -w, --width=數字          最大的行寬 (預設為 75 個字元)\n"

#: src/fmt.c:293
msgid ""
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"\n"
"使用 -w數字 時，字元‘w’可以省略不用。\n"

#: src/fmt.c:345
#, c-format
msgid "invalid width option: `%s'"
msgstr "無效的寬度選項：‘%s’"

#: src/fmt.c:385
#, c-format
msgid "invalid width: `%s'"
msgstr "無效的寬度：‘%s’"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"將<檔案>(預設為標準輸入)中的每一行進行自動斷行，並將結果寫至標準輸出。\n"
"\n"

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         計算位元組總數而非字元位置\n"
"  -s, --spaces        只在空格位置斷開\n"
"  -w, --width=寬度    使用指定的<寬度>作為行寬而非 80\n"

#: src/fold.c:267
#, c-format
msgid "`%s' option is obsolete; use `%s'"
msgstr "‘%s’選項已過時；請使用‘%s’"

#: src/fold.c:295
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "無效的欄位數目：`%s'"

#: src/head.c:92
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"在標準輸出印出每個<檔案>的最初 10 行。\n"
"當多於一個<檔案>時，顯示時會先加上表示檔案名稱的標頭。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/head.c:101
msgid ""
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
msgstr ""
"  -c, --bytes=大小         印出最初指定<大小>的位元組\n"
"  -n, --lines=行數         印出最初指定<行數>而非最初 10 行\n"

#: src/head.c:105
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    絕不顯示含有檔案名稱的標頭\n"
"  -v, --verbose            一定顯示含有檔案名稱的標頭\n"

#: src/head.c:111 src/split.c:119
msgid ""
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"\n"
"<大小> 可以加上單位：b 表示 512，k 表示 1K，m 表示 1M。\n"

#: src/head.c:189
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "無法將 %s 的檔案指標重新定位"

#: src/head.c:220 src/md5sum.c:334 src/md5sum.c:675 src/od.c:960 src/od.c:2000
#: src/pr.c:1166 src/pr.c:1373 src/pr.c:1495 src/tac.c:484 src/tac.c:490
#: src/tr.c:2028 src/tsort.c:585
msgid "standard input"
msgstr "標準輸出"

#: src/head.c:255 src/tail.c:1378
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s：%s過大，因此無法表示"

#: src/head.c:256 src/tail.c:1380
msgid "number of lines"
msgstr "行數"

#: src/head.c:256 src/tail.c:1381
msgid "number of bytes"
msgstr "位元組數目"

#: src/head.c:263 src/tail.c:1467
msgid "invalid number of lines"
msgstr "無效的行數"

#: src/head.c:264 src/tail.c:1468
msgid "invalid number of bytes"
msgstr "無效的位元組數目"

#: src/head.c:340
#, c-format
msgid "unrecognized option `-%c'"
msgstr "無法識別的選項‘-%c’"

#: src/head.c:347
#, c-format
msgid "`-%s' option is obsolete; use `-%c %.*s%.*s%s'"
msgstr "‘-%s’選項已過時；請使用‘-%c %.*s%.*s%s’"

#: src/join.c:144
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "用法：%s [選項]... 檔案1 檔案2\n"

#: src/join.c:148
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"當兩個檔案指定要合併的欄位相同時，並在標準輸出顯示結果。預設的合併欄位是\n"
"以空格分隔計算的第一個欄位。如果<檔案1>或<檔案2>(並非同時)是 -，則讀入\n"
"標準輸入的資料。\n"
"\n"
"  -a SIDE           當某行遇到無法配對的欄位時，取其中一個檔案印出該行\n"
"  -e 字串           當缺少輸入欄位時，以<字串>代替\n"

#: src/join.c:156
msgid ""
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case 當比較欄位時忽略大小寫\n"
"  -j 欄位           (已過時) 等於‘-1 欄位 -2 欄位’\n"
"  -j1 欄位          (已過時) 等於‘-1 欄位’\n"
"  -j2 欄位          (已過時) 等於‘-2 欄位’\n"
"  -o 格式           當輸出時遵從指定<格式>\n"
"  -t 字元           以<字元>作為輸入和輸出的欄位分隔符號\n"

#: src/join.c:164
msgid ""
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
msgstr ""
"  -v SIDE           類似 -a SIDE，但不印出已合併的任何一行\n"
"  -1 欄位           以檔案 1 的指定<欄位>來合併\n"
"  -2 欄位           以檔案 2 的指定<欄位>來合併\n"

#: src/join.c:171
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"\n"
"除非使用了‘-t 字元’選項，會忽略每行開始的空白字元，否則欄位會以指定的\n"
"<字元>分隔。<欄位>編號是由 1 開始算起的。<格式>是一個或多個以逗號分隔的\n"
"字串，每個字串可以是‘SIDE.<欄位>’或‘0’。預設的<格式>是先輸出用來合併\n"
"的索引，然後是<檔案1>的其它欄位，最後是<檔案2>的其它欄位，全部皆以<字元>\n"
"來分隔。\n"

#: src/join.c:644
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "無效的欄位規格：‘%s’"

#: src/join.c:658 src/join.c:771 src/join.c:807
#, c-format
msgid "invalid field number: `%s'"
msgstr "無效的欄位號碼：‘%s’"

#: src/join.c:671
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "欄位規格中含有無效的檔案編號：‘%s’"

#: src/join.c:791
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "檔案 1 的欄位號碼是無效的：‘%s’"

#: src/join.c:800
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "檔案 2 的欄位號碼是無效的：‘%s’"

#: src/join.c:832
msgid "too many non-option arguments"
msgstr "非選項的引數過多"

#: src/join.c:854
msgid "too few non-option arguments"
msgstr "非選項的引數過少"

#: src/join.c:865
msgid "both files cannot be standard input"
msgstr "兩個檔案不能都是標準輸入"

#: src/md5sum.c:38
msgid "Ulrich Drepper and Scott Miller"
msgstr "Ulrich Drepper 及 Scott Miller"

#: src/md5sum.c:125
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"用法：%s [選項] [檔案]...\n"
"  或：%s [選項] --check [檔案]\n"
"印出或檢查 %s (%d 位元) 總和檢查值。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/md5sum.c:134
#, c-format
msgid ""
"\n"
"  -b, --binary            read files in binary mode (default on DOS/"
"Windows)\n"
"  -c, --check             check %s sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
msgstr ""
"\n"
"  -b, --binary            以二元碼模式讀入檔案 (DOS/Windows 平台的預設模式)\n"
"  -c, --check             驗證由指定的清單提供的 %s 檢查值\n"
"  -t, --text              以文字模式讀入檔案 (預設模式)\n"
"\n"

#: src/md5sum.c:142
msgid ""
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated checksum lines\n"
"\n"
msgstr ""
"以下的兩個選項只在驗證總和檢查值時有用：\n"
"      --status            不顯示任何結果，只用回傳值表示是否成功\n"
"  -w, --warn              對於每一行含有不正確格式的總和檢查值都顯示警告\n"

#: src/md5sum.c:150
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"總和檢查是根據 %s 描述的方法計算出來的。當驗證時，輸入資料必須是此程式以往\n"
"的輸出結果。預設模式是印出總和檢查值，一個代表檔案類型的字元 (‘*’表示二元\n"
"碼，‘ ’表示文字)，及每個<檔案>的名稱。\n"

#: src/md5sum.c:379
#, c-format
msgid "%s: %lu: improperly formatted %s checksum line"
msgstr "%s：%lu：此行 %s 總和檢查值的格式不正確"

#: src/md5sum.c:401
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s：開啟或讀取時發生錯誤\n"

#: src/md5sum.c:425
msgid "FAILED"
msgstr "錯誤"

#: src/md5sum.c:425
msgid "OK"
msgstr "正確"

#: src/md5sum.c:438
#, c-format
msgid "%s: read error"
msgstr "%s：讀取時發生錯誤"

#: src/md5sum.c:451
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s：找不到正確格式的 %s 總和檢查值"

#: src/md5sum.c:464
#, c-format
msgid "WARNING: %d of %d listed %s could not be read"
msgstr "警告：無法讀入 %2$d 個%3$s的其中 %1$d 個"

#: src/md5sum.c:467
msgid "file"
msgstr "檔案"

#: src/md5sum.c:467
msgid "files"
msgstr "檔案"

#: src/md5sum.c:473
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "警告：%2$d 個計算出來的%3$s的其中 %1$d 個並不匹配"

#: src/md5sum.c:476
msgid "checksum"
msgstr "總和檢查值"

#: src/md5sum.c:476
msgid "checksums"
msgstr "總和檢查值"

#: src/md5sum.c:558
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "當驗證總和檢查值時，選項 --binary 及 --text 是沒有意義的"

#: src/md5sum.c:566
msgid "the --string and --check options are mutually exclusive"
msgstr "不能同時使用 --string 及 --check 選項"

#: src/md5sum.c:573
msgid "the --status option is meaningful only when verifying checksums"
msgstr "選項 --status 只有在驗證總和檢查值時才有意義"

#: src/md5sum.c:580
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "選項 --warn 只有在驗證總和檢查值時才有意義"

#: src/md5sum.c:590
msgid "no files may be specified when using --string"
msgstr "使用選項 --string 時不能再指定檔案"

#: src/md5sum.c:612
msgid "only one argument may be specified when using --check"
msgstr "使用選項 --check 時只能指定一個引數"

#: src/nl.c:39
msgid "Scott Bartram and David MacKenzie"
msgstr "Scott Bartram 及 David MacKenzie"

#: src/nl.c:180
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"將每個<檔案>的內容在標準輸出顯示，並加上行號。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"

#: src/nl.c:188
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=方式       決定將內容加上行號的<方式>\n"
"  -d, --section-delimiter=CC      使用 CC 字元分辨標頭、內容和註腳\n"
"  -f, --footer-numbering=方式     決定將註腳加上行號的<方式>\n"

#: src/nl.c:193
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=方式     決定將標頭加上行號的<方式>\n"
"  -i, --page-increment=數字       每行的行號增加量\n"
"  -l, --join-blank-lines=行數     將指定<行數>的空行合併成一行\n"
"  -n, --number-format=格式        根據<格式>加上行號\n"
"  -p, --no-renumber               每次分頁後不重設行號\n"
"  -s, --number-separator=字串     以<字串>分隔行號和內容\n"

# I can't imagine manpage and --help output are so outdated -- maddog
#: src/nl.c:201
msgid ""
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=數字 每頁第一行的行號\n"
"  -w, --number-width=數字         以指定<數字>的字元作為顯示行數的寬度\n"

#: src/nl.c:207
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"預設的選項為 -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn。CC 是兩個用來\n"
"分辨每頁的標頭、內容和註腳的字元；如果沒有指定第二個字元則表示是 :。\n"
"請輸入 \\\\ 表示 \\ 字元。<方式>可以是以下其中一個：\n"

#: src/nl.c:213
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a             每一行都加上行號\n"
"  t             只有非空白的行才加上行號\n"
"  n             每一行都不加行號\n"
"  p正規表示式   只有符合<正規表示式>的每一行才加上行號\n"
"\n"
"<格式>可以是以下其中一個：\n"
"  ln   向左對齊，前面不加零補位\n"
"  rn   向右對齊，前面不加零補位\n"
"  rz   向右對齊，前面加零補位\n"

#: src/nl.c:500
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "無效的開始行號：‘%s’"

#: src/nl.c:510
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "無效的行號增加值：‘%s’"

#: src/nl.c:523
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "無效的空白行數目：‘%s’"

#: src/nl.c:537
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "無效的行號欄位寬度：‘%s’"

#: src/od.c:291
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"用法：%s [選項]... [檔案]...\n"
"  或：%s --traditional [檔案] [[+]偏移值 [[+]標號]]\n"

#: src/od.c:296
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"以明確方式(預設為八進位數字)表示<檔案>的內容。當指定多於一個<檔案>時，\n"
"會以指定的次序將檔案內容合併。如果沒有指定<檔案>或<檔案>是 -，則由標準\n"
"輸入讀取資料。\n"
"\n"

#: src/od.c:303
msgid "All arguments to long options are mandatory for short options.\n"
msgstr "長選項必須用的參數在使用短選項時也是必須的。\n"

#: src/od.c:306
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=RADIX   決定基準位址的單位\n"
"  -j, --skip-bytes=位元組     先略過指定<位元組>的輸入資料\n"

#: src/od.c:310
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=位元組     限制傾印的輸入資料<位元組>數目\n"
"  -s, --strings[=位元組]      只印出不少於指定<位元組>大小的字串常數\n"
"  -t, --format=格式           選擇輸出的<格式>\n"
"  -v, --output-duplicates     不使用 * 表示每行重覆的資料\n"
"  -w, --width[=位元組]        每行顯示指定的<位元組>數目\n"
"      --traditional           接受舊式的選項\n"

#: src/od.c:320
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
msgstr ""
"\n"
"舊式的規格可以混合使用，而且效果會累積：\n"
"  -a   等於 -t a，  顯示 ASCII 字元或以 ASCII 表示的控制字元\n"
"  -b   等於 -t oC， 顯示八進位位元組\n"
"  -c   等於 -t c，  顯示 ASCII 字元或反斜號溢出序列\n"
"  -d   等於 -t u2， 顯示十進位 unsigned short\n"

#: src/od.c:328
msgid ""
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"  -f   等於 -t fF， 顯示浮點數\n"
"  -h   等於 -t x2， 顯示十六進位 short integer\n"
"  -i   等於 -t d2， 顯示十進位 short integer\n"
"  -l   等於 -t d4， 顯示十進位 long integer\n"
"  -o   等於 -t o2， 顯示八進位 short integer\n"
"  -x   等於 -t x2， 顯示十六進位 short integer\n"

#: src/od.c:336
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes may be . for octal and b for multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"對於舊式的語法 (第二種調用的格式)，<偏移值>等於‘-j <偏移值>’。<標號>\n"
"是第一個位元組的虛擬地址(本來是 0)，會在傾印資料時相應增加。對於<偏移值>\n"
"和<標號>，前面加上 0x 或 0X 表示是十六進位數字；後面加上 . 表示是八進位\n"
"數字，加上 b 則表示乘以 512。\n"
"\n"
"<格式>可以是下列一個或多個的規格：\n"
"\n"
"  a          ASCII 字元或以 ASCII 字元代表的控制字元\n"
"  c          ASCII 字兀或反斜號溢出序列\n"

#: src/od.c:348
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[大小]    有正負號的十進位數，每個整數佔指定<大小>的位元組\n"
"  f[大小]    浮點數，每個整數佔指定<大小>的位元組\n"
"  o[大小]    八進位數，每個整數佔指定<大小>的位元組\n"
"  u[大小]    無正負號的十進位數，每個整數佔指定<大小>的位元組\n"
"  x[大小]    十六進位數，每個整數佔指定<大小>的位元組\n"

#: src/od.c:355
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"<大小>是一個數字。當<格式>是 doux 其中之一時，<大小>也可以是：表示\n"
"sizeof(char) 的 C、表示 sizeof(short) 的 S、表示 sizeof(int) 的 I 或\n"
"表示 sizeof(long) 的 L。如果<格式>是 f，<大小>可以是表示 sizeof(float)\n"
"的 F、表示 sizeof(double) 的 D 或表示 sizeof(long double) 的 L。\n"

#: src/od.c:362
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  "
msgstr ""
"\n"
"RADIX 的選擇為：d 表示十進位，o 表示八進位，h 表示十六進位，或 n 表示\n"
"不顯示基準位址。<位元組>可以是前置 0x 或 0X 的十六進位數字；如果<位元組>\n"
"後加上 b 字元表示將數字乘以 512，加上 k 表示乘以 1024，加上 m 表示乘以\n"
"1048576。在任何<格式>後加上 z 字元會在每行輸出後顯示相應的可列印字元。"

#: src/od.c:370
msgid ""
"--string without a number implies 3.  --width without a number\n"
"implies 32.  By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
" \n"
"--string 不加數字表示字串長度是 3。--width 不加數字表示寬度是 32。預設\n"
"od 使用的選項是 -A o -t d2 -w 16。\n"

#: src/od.c:726 src/od.c:845
#, c-format
msgid "invalid type string `%s'"
msgstr "無效的類型‘%s’"

#: src/od.c:736
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"‘%s’是無效的類型；\n"
"此系統不支援 %lu 位元組的整數"

#: src/od.c:855
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"‘%s’是無效的類型；\n"
"此系統不支援 %lu 位元組的浮點數"

#: src/od.c:918
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "類型‘%2$s’中含有無效的字元‘%1$c’。"

#: src/od.c:1145
msgid "cannot skip past end of combined input"
msgstr "無法移至合併後的輸入資料的末端之後"

#: src/od.c:1398
msgid "old-style offset"
msgstr "舊式的偏移量表示法"

#: src/od.c:1706
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr "輸出位址的基數‘%c’是無效的；基數必須是 [doxn] 四個字元其中之一"

#: src/od.c:1716
msgid "skip argument"
msgstr "略過引數"

#: src/od.c:1724
msgid "limit argument"
msgstr "限制引數"

#: src/od.c:1734
msgid "minimum string length"
msgstr "最小字串長度"

#: src/od.c:1739 src/od.c:1805
#, c-format
msgid "%s is too large"
msgstr "%s 過長"

#: src/od.c:1803
msgid "width specification"
msgstr "寬度規格"

#: src/od.c:1825
msgid "no type may be specified when dumping strings"
msgstr "傾印字串時不能指定類型"

#: src/od.c:1873
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "在相容性模式下，第二個運算符號‘%s’是無效的"

#: src/od.c:1894
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr "在相容性模式下，最後兩個引數必須是偏移值"

#: src/od.c:1901
msgid "compatibility mode supports at most three arguments"
msgstr "在相容性模式下，最多只能有三個引數"

#: src/od.c:1974
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "警告：寬度 %lu 是無效的；以 %d 代替"

#: src/od.c:1990
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d：格式=\"%s\" 寬度=%d\n"

#: src/paste.c:50
msgid "David M. Ihnat and David MacKenzie"
msgstr "David M. Ihnat 及 David MacKenzie"

#: src/paste.c:208
msgid "standard input is closed"
msgstr "已關閉標準輸入"

#: src/paste.c:407
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"將每個<檔案>相應的每一行用 TAB 隔開，在標準輸出中並排顯示。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/paste.c:416
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=列表   反覆使用<列表>中的字元代替 TAB\n"
"  -s, --serial            每次合併一個檔案中的每一行，而非所有檔案的某一行\n"

#: src/pr.c:328
msgid "Pete TerMaat and Roland Huebner"
msgstr "Pete TerMaat 及 Roland Huebner"

#: src/pr.c:805
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "‘--pages’的頁碼範圍無效：‘%s’"

#: src/pr.c:817
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "‘--pages’的開始頁碼無效：‘%s’"

#: src/pr.c:829
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "‘--pages’的結束頁碼無效：‘%s’"

#: src/pr.c:836
msgid "`--pages' starting page number is larger than ending page number"
msgstr "‘--pages’的開始頁碼大於結束頁碼"

#: src/pr.c:913
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "‘--pages=開始頁碼[:結束頁碼]’缺少了引數"

#: src/pr.c:924
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "‘--columns=欄位’的欄位數目無效：‘%s’"

#: src/pr.c:978
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "‘-l 每頁行數’的行數無效：‘%s’"

#: src/pr.c:1002
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "‘-N 行號’的開始行號無效：‘%s’"

#: src/pr.c:1014
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "‘-o 邊界’的字元偏移值無效：‘%s’"

#: src/pr.c:1055
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "‘-w 頁寬’的字元數目無效：‘%s’"

#: src/pr.c:1067
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "‘-W 頁寬’的字元數目無效：‘%s’"

#: src/pr.c:1081
msgid "%b %e %H:%M %Y"
msgstr "%Y-%m-%d %H:%M"

#: src/pr.c:1090
msgid "Cannot specify number of columns when printing in parallel."
msgstr "並排列印時不能同時指定欄位數目。"

#: src/pr.c:1094
msgid "Cannot specify both printing across and printing in parallel."
msgstr "不能同時指定橫向列印與並排列印。"

#: src/pr.c:1190
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr "引數‘%2$s’含有多餘的字元‘-%1$c’或無效的數字"

#: src/pr.c:1301
msgid "page width too narrow"
msgstr "頁面太窄"

#: src/pr.c:2364
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr "開始頁碼大於總頁數：‘%d’"

#: src/pr.c:2395
#, c-format
msgid "Page %d"
msgstr "第 %d 頁"

#: src/pr.c:2761
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""
"將<檔案>分頁或分欄以便列印。\n"
"\n"

#: src/pr.c:2768
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""
"  +開始頁碼[:結束頁碼], --pages=開始頁碼[:結束頁碼]\n"
"                    只印出由<開始頁碼>至<結束頁碼>的每一頁\n"
"  -欄數, --columns=欄數\n"
"                    將輸出分為指定的<欄數>顯示，而每一欄都是向下列印的，除"
"非\n"
"                    使用了 -a 選項。它也會平均分佈每頁中所有欄位的行數。\n"

#: src/pr.c:2776
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      印出內容時會先橫跨所有欄位 (橫向列印)，並非印完一欄才\n"
"                    跳至第二欄繼續列印；此選項需要配合 -欄數 使用\n"
"  -c, --show-control-chars\n"
"                    使用 ^ 符號 (^G) 或反斜號加八進位數字顯示無法列印的字元\n"
"  -d, --double-space\n"
"                    隔行顯示結果\n"

# -F and -f are just the same, help text is ambiguous -- maddog
#: src/pr.c:2784
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=格式\n"
"                    使用<格式>顯示標頭的日期\n"
"  -e[字元[寬度]], --expand-tabs[=字元[寬度]]\n"
"                    將輸入資料中的<字元>(預設為 TAB)轉換為指定<寬度>的空格\n"
"                    數目(預設為 8)\n"
"  -F, -f, --form-feed\n"
"                    使用 form feed 而不是 newline 字元來分頁 (使用此選項\n"
"                    時只會印出三行標頭，否則會印出五行標頭再加註腳)\n"

#: src/pr.c:2794
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h 標頭文字, --header=標頭文字\n"
"                    每頁的標頭使用置中的<標頭文字>代替檔案名稱；-h \"\"\n"
"                    表示空白字串，不要使用 -h\"\" (留意空格)\n"
"  -i[字元[寬度]], --output-tabs[=字元[寬度]]\n"
"                    將指定<寬度>的空格轉換為<字元>(預設為 TAB)\n"
"  -J, --join-lines  將每行資料完整地合併；會關閉 -W 選項將每行截斷的效果；\n"
"                    不將每欄對齊；--sep-string[=字串] 選項可設定分隔字串\n"

#: src/pr.c:2803
msgid ""
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l 每頁行數, --length=每頁行數\n"
"                    設定每頁的總行數 (預設為 66)\n"
"                    (預設可顯示資料內容的行數為 56，使用 -F 選項時為 63)\n"
"  -m, --merge       並排顯示所有檔案 (每欄一個檔案)；會將資料截短至符合\n"
"                    欄寬，但使用 -J 選項則不會截短任何一行\n"

#: src/pr.c:2810
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[SEP[位數]], --number-lines[=SEP[位數]]\n"
"                    加上行號；行號由指定<位數>的數字(預設為 5)加上 SEP 字元\n"
"                    (預設為 TAB)組成；計算行號時會以每個檔案第一行開始\n"
"  -N 行號, --first-line-number=行號\n"
"                    指定每個檔案第一行的<行號> (請參考 +開始頁碼 的說明)\n"

#: src/pr.c:2818
msgid ""
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o 邊界, --indent=邊界\n"
"                    每行前先加上<邊界>所指定的空格數目(預設為 0)；不會\n"
"                    影響 -w 或 -W 選項；<邊界>空格數目會加至<頁寬>的數目\n"
"  -r, --no-file-warnings\n"
"                    無法開啟檔案時不會印出警告訊息\n"

#: src/pr.c:2825
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[字元],--separator[=字元]\n"
"                    以一個字元分隔欄位，當不使用 -w 選項時預設字元為\n"
"                    <TAB>，否則不使用任何分隔字元\n"
"                    除非使用了 -w 選項，否則 -s[字元] 會防止以下三種\n"
"                    和欄位有關的選項截斷每行的資料： -欄位、-a -欄位、\n"
"                    -m\n"

#: src/pr.c:2832
msgid "  -SSTRING, --sep-string[=STRING]\n"
msgstr "  -S字串, --sep-string[=字串]\n"

#: src/pr.c:2835
msgid ""
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
msgstr ""
"                    以<字串>分隔欄位。\n"
"                    不使用 -S 選項時，預設的分隔字串為：使用 -J 選項時是\n"
"                    <TAB>，否則是<空格> (即 -S\" \")；此選項不會影響其它和\n"
"                    欄位有關的選項\n"
"  -t, --omit-header 不印出標頭和註腳\n"

#: src/pr.c:2841
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    不印出任何標頭和註腳，不進行任何因輸入檔的 form feed\n"
"                    字元而起的分頁操作\n"
"  -v, --show-nonprinting\n"
"                    使用反斜號加八進位數字的表示法顯示無法列印的字元\n"
"  -w 頁寬, --width=頁寬\n"
"                    當顯示多欄的文字時設定<頁寬>(預設為 72 字元)；-s[字元]\n"
"                    會關閉此效果\n"

#: src/pr.c:2851
msgid ""
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W 頁寬, --page-width=頁寬\n"
"                    設定每頁的<頁寬>(預設為 72 個字元)；任何一行太長都會\n"
"                    強行截短至符合頁寬，除非同時使用 -J 選項；不會影響 -S\n"
"                    或 -s 選項\n"

#: src/pr.c:2859
msgid ""
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"\n"
"當 nn <= 10 (配合 -F 選項時 nn <= 3) 的時候，使用 -l nn 選項即表示 -T 選項\n"
"已生效。如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"

#: src/ptx.c:410
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (對於正規表示式‘%s’)"

#: src/ptx.c:1859
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"用法：%s [選項]... [輸入]...   (沒有 -G)\n"
"  或：%s -G [選項]... [輸入 [輸出]]\n"

#: src/ptx.c:1863
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""

#: src/ptx.c:1870
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""

#: src/ptx.c:1876
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""

#: src/ptx.c:1883
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""

#: src/ptx.c:1891
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""

#: src/ptx.c:1898
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀入資料。預設使用‘-F /’選項。\n"

#: src/ptx.c:1978
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
msgstr ""
"本程式是自由軟體；你可以根據 Free Software Foundation 所公佈的 GNU\n"
"General Public License 第二版或(自由選擇)較新的版本中的條款去重新\n"
"散佈及/或修改本軟體。\n"
"\n"

#: src/ptx.c:1985
msgid ""
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
msgstr ""
"發佈本軟體是希望它會有用，但不會提供任何保證，甚至不會包括可售性或\n"
"適用於任何特定目的的保證。詳情請參考 GNU General Public License。\n"
"\n"

#: src/ptx.c:1992
msgid ""
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"你應該已經隨本軟體收到一份 GNU General Public License；否則請寄信至\n"
"Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,\n"
"MA 02111-1307, USA.\n"

#: src/sort.c:53
msgid "Mike Haertel and Paul Eggert"
msgstr "Mike Haertel 及 Paul Eggert"

#: src/sort.c:283
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"Ordering options:\n"
"\n"
msgstr ""
"將所有<檔案>內容合併和排序，並在標準輸出顯示結果。\n"
"\n"
"排序選項：\n"
"\n"

#: src/sort.c:292
msgid ""
"  -b, --ignore-leading-blanks ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks 忽略每行開始的空白字元\n"
"  -d, --dictionary-order      只考慮空白字元、英文字和數字\n"
"  -f, --ignore-case           排序前先將小寫字元轉換為大寫\n"

#: src/sort.c:297
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -r, --reverse               reverse the result of comparisons\n"
"\n"
msgstr ""
"  -g, --general-numeric-sort  以普通數值的方式作比較\n"
"  -i, --ignore-nonprinting    只考慮可列印的字元\n"
"  -M, --month-sort            比較月份： (不明) <‘JAN’< ... <‘DEC’\n"
"  -n, --numeric-sort          將字串轉換為數值來作比較\n"
"  -r, --reverse               以相反的次序排列\n"
"\n"

#: src/sort.c:305
msgid ""
"Other options:\n"
"\n"
"  -c, --check               check whether input is sorted; do not sort\n"
"  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"其它選項：\n"
"\n"
"  -c, --check               只檢查輸入資料是否排列好，不會真正將資料排序\n"
"  -k, --key=位置1[,位置2]   排序索引由<位置1>的欄位開始，在<位置2>的欄位\n"
"                            結束(1 表示第一個欄位)\n"
"  -m, --merge               只合併已經排序的檔案；不分別排列每個檔案的內容\n"
"  -o, --output=FILE         將結果寫入<檔案>而並非在標準輸出顯示\n"
"  -s, --stable              不進行最後的整行比較排序\n"
"  -S, --buffer-size=大小    指定記憶緩衝區的<大小>\n"

#: src/sort.c:315
#, c-format
msgid ""
"  -t, --field-separator=SEP use SEP instead of non- to whitespace "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c: check for strict ordering\n"
"                              otherwise: output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=SEP       使用 SEP 作為分隔字串，而並非一組空白字元\n"
"  -T, --temporary-directory=目錄  自行指定暫存<目錄>，而非 $TMPDIR 或 %s\n"
"                                  多次使用此選項可指定多個目錄\n"
"  -u, --unique                    配合 -c：嚴格檢查資料是否依次序排列\n"
"                                  沒有 -c：遇到多行相同的資料時只顯示第一行\n"

#: src/sort.c:322
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     以位元組 0 而非 newline 字元作為每行的結束字元\n"

#: src/sort.c:327
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field.  OPTS is one or more single-letter ordering options, which\n"
"override global ordering options for that key.  If no key is given, use the\n"
"entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"<位置>的格式是 F[.C][OPTS]，其中 F 是欄位編號，C 是該欄的字元位置。OPTS\n"
"是一個或多個單字元的排序選項，這些專用的選項會取代該排序索引的一般排序\n"
"選項。如果沒有指定排序索引，則以整行的內容作為索引。\n"
"\n"
"<大小>可以加上如下的單位：\n"

#: src/sort.c:336
#, fuzzy, c-format
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% = 1% 記憶體，b=1，K=1024(預設值)，還有 M、G、T、P、E、Z、Y 如此類推。\n"
"\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"
"*** 警告 ***\n"
"和語系有關的環境變數會影響排序結果。\n"
"如果要以位元組數值作為排列次序，請設定環境變數 LC_ALL=C。\n"

#: src/sort.c:447
msgid "cannot create temporary file"
msgstr "無法建立暫存檔"

#: src/sort.c:470
msgid "open failed"
msgstr "開啟時發生錯誤"

#: src/sort.c:490 src/sort.c:2488
msgid "close failed"
msgstr "關閉時發生錯誤"

#: src/sort.c:498
msgid "write failed"
msgstr "寫入時發生錯誤"

#: src/sort.c:644
msgid "sort size"
msgstr "排序記憶緩衝區"

#: src/sort.c:718
msgid "stat failed"
msgstr "stat 時發生錯誤"

#: src/sort.c:970
msgid "read failed"
msgstr "讀入時發生錯誤"

#: src/sort.c:1566
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s： %s：%s：次序不正確："

#: src/sort.c:1570
msgid "standard error"
msgstr "標準錯誤輸出"

#: src/sort.c:2028
#, c-format
msgid "%s: invalid field specification `%s'"
msgstr "%s：無效的欄位規格‘%s’"

#: src/sort.c:2054
#, c-format
msgid "%s: count `%.*s' too large"
msgstr "%s：數字‘%.*s’過大"

#: src/sort.c:2060
#, c-format
msgid "%s: invalid count at start of `%s'"
msgstr "%s：‘%s’開始部份的數字無效"

#: src/sort.c:2290
msgid "invalid number after `-'"
msgstr "‘-’後的數字無效"

#: src/sort.c:2293 src/sort.c:2339 src/sort.c:2366
msgid "invalid number after `.'"
msgstr "‘.’後的數字無效"

#: src/sort.c:2296 src/sort.c:2375
msgid "stray character in field spec"
msgstr "欄位規格出現不合法的字元"

#: src/sort.c:2330
msgid "invalid number at field start"
msgstr "欄位規格開始部份的數字無效"

#: src/sort.c:2334 src/sort.c:2362
msgid "field number is zero"
msgstr "欄位是 0"

#: src/sort.c:2343
msgid "character offset is zero"
msgstr "字元偏移值是 0"

#: src/sort.c:2358
msgid "invalid number after `,'"
msgstr "‘,’後的數字無效"

#: src/sort.c:2403
#, c-format
msgid "multi-character tab `%s'"
msgstr "分隔欄位字元‘%s’多於一個字元"

#: src/sort.c:2471
#, c-format
msgid "extra operand `%s' not allowed with -c"
msgstr "使用 -c 時不允許指定額外的參數‘%s’"

#: src/split.c:95
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "用法：%s [選項] [輸入 [前置字串]]\n"

#: src/split.c:99
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
msgstr ""
"將<輸入>資料分割為固定大小的部份，並將結果寫入‘<前置字串>aa’、\n"
"‘<前置字串>ab’等等；預設的<前置字串>為‘x’。如果沒有指定<輸入>\n"
"或<輸入>是 -，則由標準輸入讀入資料。\n"
"\n"

#: src/split.c:107
#, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"  -a, --suffix-length=N   後置字串的長度為 N (預設值是 %d)\n"
"  -b, --bytes=大小        指定每個輸出檔的<大小>，以位元組為單位\n"
"  -C, --line-bytes=大小   每個輸出檔放入某行數的完整資料，但<大小>不會超出\n"
"                          指定位元組數目\n"
"  -l, --lines=行數        每個輸出檔放入指定<行數>的資料\n"

#: src/split.c:113
msgid ""
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
msgstr "      --verbose           開啟每個輸出檔之前都在標準錯誤輸出顯示訊息\n"

#: src/split.c:170
msgid "Output file suffixes exhausted"
msgstr "輸出檔的後置字串已用盡"

#: src/split.c:188
#, c-format
msgid "creating file `%s'\n"
msgstr "正在建立檔案‘%s’\n"

#: src/split.c:407
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s：無效的後置字串長度"

#: src/split.c:416 src/split.c:432 src/split.c:448 src/split.c:474
msgid "cannot split in more than one way"
msgstr "不能用超過一種方式進行分割"

#: src/split.c:423 src/split.c:456
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s：無效的位元組數目"

#: src/split.c:439
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s：無效的行數"

#: src/split.c:499
#, c-format
msgid "`-%d' option is obsolete; use `-l %d'"
msgstr "‘-%d’選項已過時；請使用‘-l %d’"

#: src/split.c:512
msgid "invalid number"
msgstr "無效的數字"

#: src/split.c:527 src/tr.c:1849
msgid "too many arguments"
msgstr "引數過多"

#: src/sum.c:36
msgid "Kayvan Aghaiepour and David MacKenzie"
msgstr "Kayvan Aghaiepour 及 David MacKenzie"

#: src/sum.c:64
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"印出每個<檔案>的總和檢查值及區塊數目。\n"
"\n"
"  -r              令 -s 選項無效，使用 BSD 的演算法，用 1K 的區塊大小\n"
"  -s, --sysv      使用 System V 的演算法，用 512 個位元組的區塊大小\n"

#: src/sys2.h:483
msgid "      --help     display this help and exit\n"
msgstr "      --help     顯示此求助說明並離開\n"

#: src/sys2.h:485
msgid "      --version  output version information and exit\n"
msgstr "      --version  顯示版本資訊並離開\n"

#: src/tac.c:54
msgid "Jay Lepreau and David MacKenzie"
msgstr "Jay Lepreau 及 David MacKenzie"

#: src/tac.c:131
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"將每個<檔案>由最後一行開始在標準輸出顯示出來。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"

#: src/tac.c:139
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             將分隔字串加在前面而不是後面\n"
"  -r, --regex              將分隔字串理解為正規表示式\n"
"  -s, --separator=字串     用<字串>作為分隔字串，而不是 newline 字元\n"

#: src/tac.c:454 src/tac.c:593
msgid "stdin: read error"
msgstr "標準輸入：讀取資料時發生錯誤"

#: src/tac.c:639
msgid "separator cannot be empty"
msgstr "分隔字串不可以是空的"

#: src/tail.c:242
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"在標準輸出顯示每個<檔案>的最後 %d 行。\n"
"當指定多於一個<檔案>時，會先印出表示每個檔案名稱的標頭。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"

#: src/tail.c:251
msgid ""
"      --retry              keep trying to open a file even if it is\n"
"                           inaccessible when tail starts or if it becomes\n"
"                           inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
msgstr ""
"      --retry              即使執行 tail 時或一段時間後無法存取某檔案，仍然\n"
"                           不斷嘗試開啟該檔案 ─ 只在配合 -f 選項時有用\n"
"  -c, --bytes=N            輸出最後的 N 個位元組\n"

#: src/tail.c:257
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           當檔案不斷變大時顯示加上的資料；\n"
"                           -f、--follow 及 --follow=descriptor 是相同的\n"
"  -F                       等於 --follow=name --retry\n"

# --max-consecutive-size-changes is undocumented  -- maddog
#: src/tail.c:264
#, c-format
msgid ""
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""
"  -n, --lines=N            顯示最後 N 行而不是 %d 行\n"
"      --max-unchanged-stats=N\n"
"                           配合 --follow=name 時，如果檢查<檔案> N 次\n"
"                           (預設是 %d 次)後檔案大小仍沒有改變，則會\n"
"                           重新開啟<檔案>來檢查檔案是否已被刪除或改名\n"
"                           (此情況在備份紀錄檔時會較常見)\n"
"      --max-consecutive-size-changes=N\n"
"                           配合 --follow=name 時，如果<檔案>連續 N 次\n"
"                           改變大小，則認定此檔案已經被改名。\n"

#: src/tail.c:275
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
"                           (default 1) seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"      --pid=PID            配合 -f 選項時，tail 會在指定的程序 (識別碼\n"
"                           為 PID) 退出後中止\n"
"  -q, --quiet, --silent    不顯示任何標明檔案名稱的標頭\n"
"  -s, --sleep-interval=S   配合 -f 選項時，每兩次檢查相隔約 S 秒\n"
"                           (預設為 1 秒)\n"
"  -v, --verbose            一定顯示任何標明檔案名稱的標頭\n"

#: src/tail.c:284
msgid ""
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).\n"
"\n"
msgstr ""
"\n"
"如果 N (行數或位元組數目) 的第一個字元是‘+’，會由每個檔案的第 N 行開始\n"
"顯示，否則會顯示每個檔案的最後 N 行。N 可以加上單位：b 是 512，k 是 1024，\n"
"m 則是 1048576 (1M)。\n"
"\n"

#: src/tail.c:292
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""
"若配合 --follow (-f) 選項，tail 預設會檢查檔案描述子 (file descriptor)；\n"
"即是說，即使要 tail 的檔案已經改名，tail 仍會繼續檢查該檔案的末端。"

#: src/tail.c:297
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""
"如果\n"
"確實要檢查檔案名稱而不是檔案描述子時 (例如備份紀錄檔時)，這種預設的處理\n"
"方式並不適用。在這情況下應使用 --follow=name。這樣會令 tail 檢查指定名稱\n"
"的檔案，方法是重覆地開啟檔案，看看它是否已被移除和其它程式會否再產生該\n"
"檔案。\n"

#: src/tail.c:335
#, c-format
msgid "closing %s (fd=%d)"
msgstr "正在關閉 %s (fd=%d)"

#: src/tail.c:400
#, c-format
msgid "%s: cannot seek to offset %s%s"
msgstr "%s：無法搜尋至位置 %s%s"

#: src/tail.c:404
#, c-format
msgid "%s: cannot seek to relative offset %s%s"
msgstr "%s：無法搜尋至相對位置 %s%s"

#: src/tail.c:408
#, c-format
msgid "%s: cannot seek to end-relative offset %s%s"
msgstr "%s：無法搜尋至末端相對位置 %s%s"

#: src/tail.c:814
#, c-format
msgid "`%s' has become inaccessible"
msgstr "已無法存取‘%s’"

#: src/tail.c:831
#, c-format
msgid "`%s' has been replaced with an untailable file; giving up on this name"
msgstr "%s：被一個無法 tail 的檔案取代；不會再檢查此檔案名稱"

#: src/tail.c:852
#, c-format
msgid "`%s' has become accessible"
msgstr "已經可以存取‘%s’"

#: src/tail.c:860
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "‘%s’已出現；正在檢查新檔案的末端"

#: src/tail.c:871
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "‘%s’已被取代；正在檢查新檔案的末端"

#: src/tail.c:996
#, c-format
msgid "%s: file truncated"
msgstr "%s：檔案被截斷了"

#: src/tail.c:1016
msgid "no files remaining"
msgstr "已沒有任何剩餘的檔案"

#: src/tail.c:1226
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr "%s：無法檢查此類檔案的末端；不會再檢查此檔案名稱"

#: src/tail.c:1346
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c：在已過時的選項中含有無效的後置字元"

#: src/tail.c:1395
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"參數過多；當使用已過時的 tail 選項語法 (%s) 時，不可指定多於一個的檔案\n"
"參數。請使用同等的 -n 或 -c 選項。"

#: src/tail.c:1404
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"警告：將兩個或以上的檔案配合已過時的 tail 選項語法 (%s) 不是在所有系統\n"
"都通用的。請使用同等的 -n 或 -c 選項。"

#: src/tail.c:1413
#, c-format
msgid "`%s' option is obsolete; use `%s-%c %.*s'"
msgstr "‘%s’選項已過時；請使用‘%s-%c %.*s’"

#: src/tail.c:1473
#, c-format
msgid "%s: is so large that it is not representable"
msgstr "%s：因為過大，所以無法表示"

#: src/tail.c:1477
#, c-format
msgid "%s is larger than the maximum file size on this system"
msgstr "%s 大於此系統能接受的最大檔案大小"

#: src/tail.c:1503
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr "%s：開啟檔案前 stat 資料沒有改變的最大次數無效"

#: src/tail.c:1515
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s：檔案連續改變大小的最大次數無效"

#: src/tail.c:1527
#, c-format
msgid "%s: invalid PID"
msgstr "%s：無效的 PID"

#: src/tail.c:1545
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s：無效的秒數"

#: src/tail.c:1565
msgid "warning: --retry is useful only when following by name"
msgstr "警告：只有檢查檔案名稱時 --retry 選項才會有效"

#: src/tail.c:1569
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "警告：會忽略 PID；--pid=PID 選項只在不斷檢查檔案時才會有效"

#: src/tail.c:1572
msgid "warning: --pid=PID is not supported on this system"
msgstr "警告：此系統不支援 --pid=PID 選項"

#: src/tr.c:327
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "用法：%s [選項]... SET1 [SET2]\n"

#: src/tr.c:331
#, fuzzy
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"從標準輸入讀取資料，將字元置換、壓縮、刪除後，在標準輸出顯示結果。\n"
"\n"
"  -c, --complement        以所有不屬於 SET1 的字元 (SET1 的餘集) 取代 SET1\n"
"  -d, --delete            刪除所有 SET1 裡的字元，不進行置換\n"
"  -s, --squeeze-repeats   將連續重複的字元刪除至只剩一個\n"
"  -t, --truncate-set1     先將 SET1 的長度截至跟 SET2 一樣\n"

#: src/tr.c:344
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"SET 是以字串方式指定。大部份字元都會直接處理。要解譯的序列包括：\n"
"\n"
"  \\NNN            八進位數字 NNN (1 至 3 個位)所代表的字元\n"
"  \\\\              反斜號\n"
"  \\a              響聲 (BEL)\n"
"  \\b              倒退字元 (backspace)\n"
"  \\f              換頁字元 (form feed)\n"
"  \\n              換行字元 (new line)\n"
"  \\r              復位字元 (return)\n"
"  \\t              水平定位字元 (tab)\n"

#: src/tr.c:358
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              垂直定位字元 (vertical tab)\n"
"  字元1-字元2     由<字元1>開始升序排列至<字元2>\n"
"  [字元*]         在 SET2 裡重覆加上<字元>，直至 SET1 的長度\n"
"  [字元*重覆次數] 重覆指定<字元>，如果<重覆次數>的第一個字元是 0 則表示\n"
"                  <重覆次數>是八進位數字\n"
"  [:alnum:]       所有英文字及數字\n"
"  [:alpha:]       所有英文字\n"
"  [:blank:]       所有水平的空白字元\n"
"  [:cntrl:]       所有控制字元\n"
"  [:digit:]       所有數字\n"

#: src/tr.c:369
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       所有可列印的字元，不包括空格\n"
"  [:lower:]       所有小寫英文字母\n"
"  [:print:]       所有可列印的字元，包括空格\n"
"  [:punct:]       所有標點符號\n"
"  [:space:]       所有水平或垂直的空白字元\n"
"  [:upper:]       所有大寫英文字母\n"
"  [:xdigit:]      所有十六進位數字\n"
"  [=CHAR=]        所有和 CHAR 同等的字元\n"

#: src/tr.c:379
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  "
msgstr ""
"\n"
"置換操作只在沒有指定 -d 選項和 SET1、SET2 同時存在的情況下有效。\n"
"-t 選項只能在置換操作時使用。有需要時，SET2 會將它的最後一個字元\n"
"重覆，直至 SET2 的長度和 SET1 的一樣。"

#: src/tr.c:385
msgid ""
"Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  "
msgstr ""
"SET2 中的多餘字元會被忽略。\n"
"只有 [:lower:] 及 [:upper:] 可保證展開的字元以升序排列；當在 SET2 中\n"
"使用作為置換操作的字元時，它們只能一起使用，表示置換大小寫。"

#: src/tr.c:391
msgid ""
"-s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"若不是\n"
"置換或刪除字元，-s 選項只會使用 SET1；另外壓縮字元會使用 SET2，並在\n"
"置換或刪除字元後才進行。\n"

#: src/tr.c:557
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"警告：意義不明確的八進位溢出序列 \\%c%c%c 會\n"
"\t理解為兩個位元組的序列 \\0%c%c，‘%c’"

#: src/tr.c:566
msgid "invalid backslash escape at end of string"
msgstr "字串末端的反斜號溢出序列無效"

#: src/tr.c:572
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "反斜號溢出序列‘\\%c’無效"

#: src/tr.c:725
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr "‘%s-%s’範圍的端點和字元應有的排列次序相反"

#: src/tr.c:906
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "[c*n] 結構中的重覆次數‘%s’無效"

#: src/tr.c:999
msgid "missing character class name `[::]'"
msgstr "無效的字元種類名稱‘[::]’"

#: src/tr.c:1002
msgid "missing equivalence class character `[==]'"
msgstr "缺少了等價字元種類的字元‘[==]’"

#: src/tr.c:1025
#, c-format
msgid "invalid character class `%s'"
msgstr "無效的字元種類‘%s’"

#: src/tr.c:1050
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s：等價字元種類中的運算符必須是恰好一個字元"

#: src/tr.c:1522
msgid "the [c*] repeat construct may not appear in string1"
msgstr "重複結構 [c*] 不能在字串 1 出現"

#: src/tr.c:1532
msgid "only one [c*] repeat construct may appear in string2"
msgstr "重複結構 [c*] 只能在字串 2 出現一次"

#: src/tr.c:1540
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "進行置換時，[=c=] 表示式不能在字串 2 出現"

#: src/tr.c:1553
msgid "when not truncating set1, string2 must be non-empty"
msgstr "若不截斷(消除) set1，字串 2 不能是空的"

#: src/tr.c:1562
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"取字元種類的餘集(complement)作置換時，只能將所有字元映射\n"
"至一個字元，即字串 2 只可含有一個字元"

#: src/tr.c:1569
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr "置換時，可以在字串 2 出現的字元種類只有‘upper’或‘lower’"

#: src/tr.c:1578
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "[c*] 結構只有在置換時方可在字串 2 出現"

#: src/tr.c:1854
msgid "two strings must be given when translating"
msgstr "置換時必須指定兩個字串"

#: src/tr.c:1857
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr "同時刪除字元和壓縮重覆字時必須指定兩個字串"

#: src/tr.c:1871
msgid "only one string may be given when deleting without squeezing repeats"
msgstr "刪除但不壓縮重覆字時只能指定一個字串"

#: src/tr.c:1877
msgid "at least one string must be given when squeezing repeats"
msgstr "壓縮重覆字時至少要指定一個字串"

#: src/tr.c:1968
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "[:upper:]、[:lower:]結構的位置沒有對齊"

#: src/tr.c:1991
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"無效的恆等映射 (identity mapping)；進行置換時，對於字串 1 的任何\n"
"[:lower:]、[:upper:] 結構，在字串 2 裡都必須有一個相應的結構。\n"
"(分別為 [:upper:]、[:lower:]) "

#: src/tsort.c:97
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"用法：%s [選項] [檔案]\n"
"將<檔案>中所有已進行部份排序的項目聯繫起來，產生新的排列，而該排列含有\n"
"<檔案>中的所有項目。如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"

#: src/tsort.c:533
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s：將輸入資料排序時出現迴圈："

#: src/tsort.c:575
msgid "only one argument may be specified"
msgstr "只能指定一個引數"

#: src/unexpand.c:379
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"將每個<檔案>中的空格轉換為 tab，並在標準輸出顯示結果。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"\n"

#: src/unexpand.c:387
msgid ""
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -a, --all           轉換所有空白字元，並非只是每行開始的空白字元\n"
"  -t, --tabs=數字     將指定<數字>的空格轉換為 tab，而非 8 個\n"
"  -t, --tabs=LIST     用以逗號分隔的數字特別指定 tab 的位置\n"

#: src/unexpand.c:463
msgid "`-LIST' option is obsolete; use `--first-only -t LIST'"
msgstr "‘-LIST’選項已過時；請使用‘--first-only -t LIST’"

#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [選項]... [輸入 [輸出]]\n"

#: src/uniq.c:138
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
msgstr ""
"將<輸入>(預設為標準輸入)的資料中每行連續相同的資料捨棄至只剩一行，\n"
"並將結果寫入至<輸出>(預設會在標準輸出顯示結果)。\n"

#: src/uniq.c:146
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           每行前加上出現次數\n"
"  -d, --repeated        只印出重覆的資料\n"

#: src/uniq.c:150
msgid ""
"  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -D, --all-repeated[=分隔方式]\n"
"                        印出所有重覆的資料\n"
"                        分隔方式={none(預設)、prepend、separate}\n"
"                        會使用空行來分隔資料。\n"
"  -f, --skip-fields=N   不比較最初的 N 個欄位\n"
"  -i, --ignore-case     比較時忽略大小寫\n"
"  -s, --skip-chars=N    不比較最初的 N 個字元\n"
"  -u, --unique          只印出沒有重覆的資料\n"

#: src/uniq.c:159
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=N   每行比較不多於 N 個字元\n"

#: src/uniq.c:164
msgid ""
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"\n"
"一個欄位是由一組空白字元加上一組非空白的字元組成的。\n"
"當同時指定略過欄位和略過字元不作比較時，會先略過欄位。\n"

#: src/uniq.c:377
#, c-format
msgid "error reading %s"
msgstr "讀取 %s 時發生錯誤"

#: src/uniq.c:382
#, c-format
msgid "error writing %s"
msgstr "寫入 %s 時發生錯誤"

#: src/uniq.c:428 src/uniq.c:445
#, c-format
msgid "extra operand `%s'"
msgstr "多餘的參數‘%s’"

#: src/uniq.c:468 src/uniq.c:493
msgid "invalid number of fields to skip"
msgstr "要略過的欄位數目無效"

#: src/uniq.c:502
msgid "invalid number of bytes to skip"
msgstr "要略過的位元組數目無效"

#: src/uniq.c:511
msgid "invalid number of bytes to compare"
msgstr "要比較的位元組數目無效"

#: src/uniq.c:525
#, c-format
msgid "`-%lu' option is obsolete; use `-f %lu'"
msgstr "‘-%lu’選項已過時；請使用‘-f %lu’"

#: src/uniq.c:533
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "顯示每行重覆的資籵又計算該行的重覆次數是沒有意義的"

#: src/wc.c:78
msgid "Paul Rubin and David MacKenzie"
msgstr "Paul Rubin 及 David MacKenzie"

#: src/wc.c:132
#, fuzzy
msgid ""
"Print byte, word, and newline counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"印出每個<檔案>的行數、字數及位元組數目，指定多個<檔案>時還會印出總計。\n"
"如果沒有指定<檔案>或<檔案>是 -，則由標準輸入讀取資料。\n"
"  -c, --bytes            印出位元組數目\n"
"  -m, --chars            印出字元數目\n"
"  -l, --lines            印出行數\n"

#: src/wc.c:140
msgid ""
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"  -L, --max-line-length  印出最長一行的字數\n"
"  -w, --words            印出字數\n"

#: src/wc.c:589
msgid "total"
msgstr "總計"
