# German translation of textutils messages.
# Copyright © 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
# This file is distributed under the same license as the textutils package.
# Karl Eichwalder <ke@suse.de>, 2001-2002.
# Michael Schmidt <michael@guug.de>, 1996, 1997, 1998, 1999, 2000.
# Michael Piefel <piefel@informatik.hu-berlin.de>, 2001.
#
# The first 200+ lines are translations for the lib directory. This is very
# similar or even identical to other tools' lib directories. Therefore take
# care to have consistent translation. I have made this identical to the
# translation in sh-utils and fileutils. -MPi
#
# TAB: spell it out ("Tabulatoren"). -ke-
# Don't use obscure abbreviations, please.  -ke-
# No hyphenation, please. -ke-
#
# space: Leerzeichen oder Leerschritt
#
msgid ""
msgstr ""
"Project-Id-Version: GNU textutils 2.0.22\n"
"POT-Creation-Date: 2002-07-29 10:41+0200\n"
"PO-Revision-Date: 2002-07-28 10:20+0200\n"
"Last-Translator: Karl Eichwalder <ke@suse.de>\n"
"Language-Team: German <de@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: lib/argmatch.c:161
#, c-format
msgid "invalid argument %s for %s"
msgstr "ungültiges Argument %s für %s"

#: lib/argmatch.c:162
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "mehrdeutiges Argument %s für %s"

#: lib/argmatch.c:181
msgid "Valid arguments are:"
msgstr "Gültige Argumente sind:"

#: lib/c-stack.c:368
msgid "program error"
msgstr "Programmfehler"

#: lib/c-stack.c:369
msgid "stack overflow"
msgstr "Stacküberlauf"

#: lib/closeout.c:107 src/cat.c:186 src/cat.c:267 src/cat.c:320
#: src/cksum.c:267 src/head.c:152 src/head.c:195 src/tail.c:327
#: src/tail.c:1651 src/tr.c:1667 src/tr.c:1913 src/tr.c:2021
msgid "write error"
msgstr "Schreibfehler"

#: lib/error.c:129 lib/error.c:157
msgid "Unknown system error"
msgstr "Unbekannter Systemfehler"

#: lib/file-type.c:42
msgid "regular empty file"
msgstr "reguläre leere Datei"

#: lib/file-type.c:42
msgid "regular file"
msgstr "reguläre Datei"

#: lib/file-type.c:45
msgid "directory"
msgstr "Verzeichnis"

#: lib/file-type.c:48
msgid "block special file"
msgstr "blockorientierte Spezialdatei"

#: lib/file-type.c:51
msgid "character special file"
msgstr "zeichenorientierte Spezialdatei"

#: lib/file-type.c:54
msgid "fifo"
msgstr "FIFO"

#: lib/file-type.c:57
msgid "symbolic link"
msgstr "symbolische Verknüpfung"

#: lib/file-type.c:60
msgid "socket"
msgstr "Socket"

#: lib/file-type.c:63
msgid "message queue"
msgstr "Nachrichtenwarteschlange"

#: lib/file-type.c:66
msgid "semaphore"
msgstr "Semaphore"

#: lib/file-type.c:69
msgid "shared memory object"
msgstr "Objekt gemeinsamen Speichers"

#: lib/file-type.c:71
msgid "weird file"
msgstr "merkwürdige Datei"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: Option »%s« ist mehrdeutig\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: Option »--%s« erlaubt kein Argument\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: Option »%c%s« erlaubt kein Argument\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: Option »%s« erfordert ein Argument\n"

#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: unbekannte Option »--%s«\n"

#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: unbekannte Option »%c%s«\n"

#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: ungültige Option -- %c\n"

#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: ungültige Option -- %c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Option erfordert ein Argument -- %c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: Option »-W %s« ist mehrdeutig\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: Option »-W %s« erlaubt kein Argument\n"

#: lib/human.c:365
msgid "block size"
msgstr "Blockgröße"

#: lib/makepath.c:176
#, c-format
msgid "cannot create directory %s"
msgstr "kann Verzeichnis %s nicht anlegen"

#: lib/makepath.c:182 lib/makepath.c:423
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s existiert, ist aber kein Verzeichnis"

#: lib/makepath.c:319 lib/makepath.c:381 lib/makepath.c:442
#, c-format
msgid "cannot change owner and/or group of %s"
msgstr "kann Besitzer und/oder Gruppe von %s nicht ändern."

#: lib/makepath.c:341
#, c-format
msgid "cannot chdir to directory %s"
msgstr "kann nicht in Verzeichnis %s wechseln"

#: lib/makepath.c:395 lib/makepath.c:448
#, c-format
msgid "cannot change permissions of %s"
msgstr "kann Zugriffsrechte von %s nicht ändern"

#: lib/obstack.c:494 lib/obstack.c:497 lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "kein Speicher mehr verfügbar"

#: lib/quotearg.c:270
msgid "`"
msgstr "»"

#: lib/quotearg.c:271
msgid "'"
msgstr "«"

#: lib/rpmatch.c:78
msgid "^[yY]"
msgstr "^[jJyY]"

#: lib/rpmatch.c:81
msgid "^[nN]"
msgstr "^[nN]"

#: lib/unicodeio.c:159
msgid "iconv function not usable"
msgstr "iconv-Funktion nicht benutzbar"

#: lib/unicodeio.c:161
msgid "iconv function not available"
msgstr "iconv-Funktion nicht verfügbar"

#: lib/unicodeio.c:168
msgid "character out of range"
msgstr "Zeichen außerhalb erlaubter Grenzen"

#: lib/unicodeio.c:231
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr ""
"es ist nicht möglich, U+%04X in den lokalen Zeichensatz zu konvertieren"

#: lib/unicodeio.c:233
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr ""
"es ist nicht möglich, U+%04X in den lokalen Zeichensatz zu konvertieren: %s"

#: lib/userspec.c:178
msgid "invalid user"
msgstr "ungültiger Benutzer"

#: lib/userspec.c:179
msgid "invalid group"
msgstr "ungültige Gruppe"

#: lib/userspec.c:181
msgid "cannot get the login group of a numeric UID"
msgstr "kann die Login-Gruppe einer numerischen UID nicht ermitteln"

#: lib/userspec.c:183
msgid "cannot omit both user and group"
msgstr "kann nicht sowohl Benutzer als auch Gruppe weglassen"

#: lib/version-etc.c:61
#, c-format
msgid "Written by %s.\n"
msgstr "Geschrieben von %s.\n"

#: lib/version-etc.c:67
msgid ""
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"Dies ist freie Software; die Kopierbedingungen stehen in den Quellen. Es\n"
"gibt keine Garantie; auch nicht für VERKAUFBARKEIT oder FÜR SPEZIELLE "
"ZWECKE.\n"

#: lib/xmemcoll.c:61
msgid "string comparison failed"
msgstr "Vergleich der Zeichenketten fehlgeschlagen"

#: lib/xmemcoll.c:62
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Setzen Sie LC_ALL='C', um dieses Problem zu umgehen."

#: lib/xmemcoll.c:64
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Die zu vergleichenden Zeichenketten waren %s und %s."

#: src/cat.c:42 src/split.c:42
msgid "Torbjorn Granlund and Richard M. Stallman"
msgstr "Torbjorn Granlund und Richard M. Stallman"

#: src/cat.c:88 src/cksum.c:276 src/comm.c:69 src/csplit.c:1490 src/cut.c:163
#: src/expand.c:106 src/fmt.c:267 src/fold.c:63 src/head.c:84 src/join.c:140
#: src/md5sum.c:121 src/nl.c:172 src/od.c:287 src/paste.c:399 src/pr.c:2752
#: src/ptx.c:1855 src/sort.c:275 src/split.c:91 src/sum.c:56 src/tac.c:123
#: src/tail.c:234 src/tr.c:323 src/tsort.c:93 src/unexpand.c:371
#: src/uniq.c:130 src/wc.c:124
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "»%s --help« gibt weitere Informationen.\n"

#: src/cat.c:92
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Aufruf: %s [OPTION] [DATEI]...\n"

#: src/cat.c:96
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
msgstr ""
"DATEI(en) oder Standardeingabe auf Standardausgabe verketten. \n"
"\n"
"  -A, --show-all           äquivalent zu -vET\n"
"  -b, --number-nonblank    nichtleere Ausgabezeilen nummerieren\n"
"  -e                       äquivalent zu -vE\n"
"  -E, --show-ends          $ am Ende jeder Zeile ausgeben\n"
"  -n, --number             alle Ausgabezeilen nummerieren\n"
"  -s, --squeeze-blank      nie mehr als eine einzige Leerzeile\n"

#: src/cat.c:106
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       äquivalent zu -vT\n"
"  -T, --show-tabs          TAB-Zeichen als ^I ausgeben\n"
"  -u                       (wird ignoriert)\n"
"  -v, --show-nonprinting   ^ und M- Notation benutzen, außer für LFD und "
"TAB\n"

#: src/cat.c:114 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Ohne DATEI oder wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/cat.c:119
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             binär auf das Konsolen-Gerät schreiben\n"
"\n"

#: src/cat.c:124 src/cksum.c:291 src/comm.c:86 src/csplit.c:1532 src/cut.c:208
#: src/expand.c:131 src/fmt.c:297 src/fold.c:86 src/head.c:115 src/join.c:180
#: src/md5sum.c:157 src/nl.c:227 src/od.c:374 src/paste.c:423 src/pr.c:2864
#: src/sort.c:346 src/split.c:123 src/sum.c:76 src/tac.c:146 src/tail.c:304
#: src/tr.c:396 src/tsort.c:105 src/unexpand.c:394 src/uniq.c:169 src/wc.c:146
#, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Berichten Sie Fehler an <%s>.\n"
"Fehler bei der deutschen Übersetzung bitte an die Mailingliste <de@li.org>\n"
"melden.\n"

#: src/cat.c:308
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "Anwendung von ioctl auf »%s« ist nicht möglich"

#: src/cat.c:647 src/od.c:1014
msgid "standard output"
msgstr "Standardausgabe"

#: src/cat.c:778
#, c-format
msgid "%s: input file is output file"
msgstr "%s: Eingabedatei und Ausgabedatei sind gleich"

#: src/cksum.c:234
#, c-format
msgid "%s: file too long"
msgstr "%s: Datei zu lang"

#: src/cksum.c:280
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Aufruf: %s [DATEI]...\n"
"  oder:    %s [OPTION]\n"

#: src/cksum.c:285
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"CRC-Checksumme und Byteanzahl für jede DATEI ausgeben.\n"
"\n"

#: src/comm.c:35 src/uniq.c:38
msgid "Richard Stallman and David MacKenzie"
msgstr "Richard Stallman und David MacKenzie"

#: src/comm.c:73
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "Aufruf: %s [OPTION]... LINKE_DATEI RECHTE_DATEI\n"

#: src/comm.c:77
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines that appear in both files\n"
msgstr ""
"Sortierte Dateien LINKE_DATEI und RECHTE_DATEI Zeile für Zeile vergleichen.\n"
"\n"
"  -1              Zeilen unterdrücken, die nur in LINKE_DATEI auftauchen\n"
"  -2              Zeilen unterdrücken, die nur in RECHTE_DATEI auftauchen\n"
"  -3              Zeilen unterdrücken, die in beiden Dateien auftauchen\n"

#: src/csplit.c:41
msgid "Stuart Kemp and David MacKenzie"
msgstr "Stuart Kemp und David MacKenzie"

#: src/csplit.c:290 src/csplit.c:1479 src/tac-pipe.c:57 src/tr.c:1609
#: src/tr.c:1712 src/tr.c:1755
msgid "read error"
msgstr "Fehler beim Lesen"

#: src/csplit.c:584
msgid "input disappeared"
msgstr "Eingabe ist verschwunden"

#: src/csplit.c:706 src/csplit.c:717
#, c-format
msgid "%s: line number out of range"
msgstr "%s: Zeilennummer nicht im zulässigen Bereich"

#: src/csplit.c:744
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: »%s«: Zeilennummer nicht im zulässigen Bereich"

#: src/csplit.c:747 src/csplit.c:793
#, c-format
msgid " on repetition %d\n"
msgstr " bei Wiederholung von %d\n"

#: src/csplit.c:789
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: »%s«: keine Entsprechung gefunden"

#: src/csplit.c:850 src/csplit.c:890 src/tac.c:262
msgid "error in regular expression search"
msgstr "Fehler bei Suche mit regulären Ausdrücken"

#: src/csplit.c:993
#, c-format
msgid "write error for `%s'"
msgstr "Fehler beim Schreiben von »%s«"

#: src/csplit.c:1065
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: »+« oder »-« nach Trenner erwartet"

#: src/csplit.c:1069
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: ganze Zahl nach »%c« erwartet"

#: src/csplit.c:1089
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: »}« ist bei Angabe einer Wiederholungsanzahl erforderlich"

#: src/csplit.c:1099
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: ganze Zahl zwischen »{« and »}« erforderlich"

#: src/csplit.c:1126
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: schließender Trenner »%c« fehlt"

#: src/csplit.c:1142
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: ungültiger regulärer Ausdruck: %s"

#: src/csplit.c:1175
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: ungültiges Muster"

#: src/csplit.c:1178
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: Zeilennummer muss größer als Null sein"

#: src/csplit.c:1184
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "Zeilennummer »%s« ist kleiner als vorhergehende Zeilennummer, %s"

#: src/csplit.c:1190
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "Warnung: Zeilennummer »%s« ist dieselbe wie die vorhergehende"

#: src/csplit.c:1312
msgid "missing conversion specifier in suffix"
msgstr "Angabe zur Wandlung fehlt im Suffix"

#: src/csplit.c:1318
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "Angabe zur Wandlung fehlt im Suffix: %c"

#: src/csplit.c:1321
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "Ungültige Angabe zur Wandlung im Suffix: \\%.3o"

#: src/csplit.c:1353
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "Fehlende %%-Angabe zur Wandlung im Suffix"

#: src/csplit.c:1356
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "Zu viele Angaben zur %%-Wandlung im Suffix"

#: src/csplit.c:1439
#, c-format
msgid "%s: invalid number"
msgstr "%s: ungültige Zahl"

#: src/csplit.c:1462
msgid "too few arguments"
msgstr "Zuwenige Argumente"

#: src/csplit.c:1494
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Aufruf: %s [OPTION]... DATEI MUSTER...\n"

#: src/csplit.c:1498
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"Teile der DATEI getrennt durch MUSTER in die Dateien »xx01«, »xx02«, ...\n"
"ausgeben und die Bytezahl für jedes Teil auf Standardausgabe.\n"
"\n"

#: src/csplit.c:1503 src/cut.c:175 src/expand.c:119 src/fmt.c:277
#: src/fold.c:76 src/head.c:98 src/nl.c:185 src/paste.c:413 src/pr.c:2765
#: src/ptx.c:1867 src/sort.c:289 src/split.c:104 src/tac.c:136 src/tail.c:248
#: src/unexpand.c:384 src/uniq.c:143
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Erforderliche Argumente für lange Optionen sind für kurze auch notwendig.\n"

#: src/csplit.c:1506
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=FORMAT sprintf-FORMAT anstelle von %d benutzen\n"
"  -f, --prefix=PRÄFIX        PRÄFIX anstelle von »xx« benutzen\n"
"  -k, --keep-files           Ausgabedateien bei Fehler nicht löschen\n"

#: src/csplit.c:1511
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ZIFFERN       angegebene Anzahl ZIFFERN anstelle von 2 "
"benutzen\n"
"  -s, --quiet, --silent      keine Bytezahlen der Ausgabedateigrößen "
"ausgeben\n"
"  -z, --elide-empty-files    leere Ausgabedateien löschen\n"

#: src/csplit.c:1518
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"Standardeingabe lesen, wenn DATEI »-« ist. Jedes MUSTER kann sein:\n"

#: src/csplit.c:1522
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  GANZZAHL           bis zu angebener Zeilennumer kopieren (ausschließlich)\n"
"  /REGEXP/[OFFSET]   bis zu entsprechender Zeile kopieren (ausschließlich)\n"
"  %%REGEXP%%[OFFSET]   bis zu entsprechender Zeile übergehen "
"(ausschließlich)\n"
"  {GANZZAHL}         das vorherige Muster sooft wie angegeben wiederholen\n"
"  {*}                das vorherige Muster sooft wie möglich wiederholen\n"
"\n"
"Ein Zeilen-OFFSET ist ein »+« or »-« gefolgt von einer positiven ganzen "
"Zahl.\n"

#: src/cut.c:39
msgid "David Ihnat, David MacKenzie, and Jim Meyering"
msgstr "David Ihnat, David MacKenzie und Jim Meyering"

#: src/cut.c:167 src/expand.c:110 src/fold.c:67 src/head.c:88 src/nl.c:176
#: src/paste.c:403 src/pr.c:2756 src/sort.c:279 src/sum.c:60 src/tac.c:127
#: src/tail.c:238 src/unexpand.c:375 src/wc.c:128
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Aufruf: %s [OPTION]... [DATEI]...\n"

#: src/cut.c:171
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr "Ausgewählte Teile jeder DATEI auf Standardausgabe ausgeben.\n"

#: src/cut.c:178
msgid ""
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=LISTE       nur diese Bytes ausgeben\n"
"  -c, --characters=LISTE  nur diese Zeichen ausgeben\n"
"  -d, --delimiter=TRENN   TRENN anstelle von TAB als Trenner benutzen\n"

#: src/cut.c:183
msgid ""
"  -f, --fields=LIST       output only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=LIST       nur diese Felder ausgeben; außerdem jede Zeile\n"
"                            ausgeben, die kein Trennzeichen enthält, außer "
"die\n"
"                            Option -s ist gegeben\n"
"  -n                      (ignoriert)\n"

#: src/cut.c:189
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    keine Zeilen ausgeben, die keinen Trenner "
"enthalten\n"
"      --ouput-delimiter=ZKETTE  ZKETTE als Ausgabetrennzeichen benutzen;\n"
"                            Voreinstellung ist das Eingabetrennzeichen\n"

#: src/cut.c:196
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Benutzen Sie genau eins aus -b, -c oder -f.  Jede LISTE besteht aus einem\n"
"Bereich oder mehreren kommagetrennten.  Jeder Bereich ist eins aus:\n"
"\n"
"  N     Ntes Byte, Zeichen oder Feld, beginnend von 1\n"
"  N-    vom Nten Byte, Zeichen oder Feld bis zum Ende der Zeile\n"
"  N-M   vom Nten zum Mten (einschl.) Byte, Zeichen oder Feld\n"
"  -M    vom ersten zum Mten (einschl.) Byte, Zeichen oder Feld\n"
"\n"
"Ohne DATEI, oder wenn DATEI »-« ist, die Standardeingabe lesen.\n"

#: src/cut.c:263 src/cut.c:294 src/cut.c:354
msgid "invalid byte or field list"
msgstr "Ungültige Byte- oder Feldliste"

#: src/cut.c:624 src/cut.c:633
msgid "only one type of list may be specified"
msgstr "Nur ein Typ einer Liste kann angegeben werden"

#: src/cut.c:627
msgid "missing list of positions"
msgstr "Liste der Positionen fehlt"

#: src/cut.c:636
msgid "missing list of fields"
msgstr "Liste der Felder fehlt"

#: src/cut.c:643
msgid "the delimiter must be a single character"
msgstr "Trenner muss ein einzelnes Zeichen sein"

#: src/cut.c:673
msgid "you must specify a list of bytes, characters, or fields"
msgstr "Sie müssen eine Liste von Bytes, Zeichen oder Feldern angeben"

#: src/cut.c:676
msgid "a delimiter may be specified only when operating on fields"
msgstr ""
"Ein Begrenzer darf nur angegeben werden, wenn auf Feldern gearbeitet wird"

# CHECKIT -> no \t, please
# 2001-08-10 08:03:34 CEST -ke-
#: src/cut.c:679
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"Nicht-getrennte Zeilen zu unterdrücken ist nur sinnvoll,\n"
"\twenn auf Feldern operiert wird."

#: src/expand.c:114
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Tabulatoren in jeder DATEI in Leerzeichen wandeln, auf Standardausgabe\n"
"schreiben.  Wurde keine DATEI angegeben, oder ist DATEI »-«, die\n"
"Standardeingabe lesen.\n"
"\n"

#: src/expand.c:122
msgid ""
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       Tabulatoren nicht nach Nicht-Freiraumzeichen (non\n"
"                        whitespace) wandeln\n"
"  -t, --tabs=ZAHL     Tabulator alle ZAHL Zeichen annehmen, nicht 8\n"

#: src/expand.c:126
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=LISTE    durch Komma getrennte LISTE von Tabulatorpositionen\n"
"                        annehmen\n"

#: src/expand.c:173 src/unexpand.c:153
msgid "tab size contains an invalid character"
msgstr "Tabulatorgröße enthält ein ungültiges Zeichen"

#: src/expand.c:191 src/unexpand.c:171
msgid "tab size cannot be 0"
msgstr "Tabulatorgröße muss ungleich 0 sein"

#: src/expand.c:193 src/unexpand.c:173
msgid "tab sizes must be ascending"
msgstr "Tabulatorgrößen müssen aufsteigend sein"

#: src/expand.c:386
msgid "`-LIST' option is obsolete; use `-t LIST'"
msgstr "die Option »-LIST« ist überholt; bitte verwenden Sie »-t LIST«"

#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "Aufruf: %s [-ZIFFERN] [OPTION]... [DATEI]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
msgstr ""
"Jeden Absatz in DATEI(en) formatieren, auf Standardausgabe schreiben.\n"
"Wurde keine DATEI angegeben, oder ist DATEI »-«, Standardeingabe lesen.\n"

#: src/fmt.c:280
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        Einrückung der ersten beiden Zeilen erhalten\n"
"  -p, --prefix=ZKETTE       nur Zeilen mit ZKETTE als Präfix kombinieren\n"
"  -s, --split-only          lange Zeilen umbrechen, aber nicht auffüllen\n"

#: src/fmt.c:286
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph    erste Zeile anders als die zweite einrücken\n"
"  -u, --uniform-spacing     ein Leerzeichen zwischen Wörtern, zwei nach "
"Sätzen\n"
"  -w, --width=ZAHL          maximale Zeilenbreite (Vorgabe: 75 Spalten)\n"

#: src/fmt.c:293
msgid ""
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"\n"
"Bei -wZAHL darf das »w« weggelassen werden.\n"

#: src/fmt.c:345
#, c-format
msgid "invalid width option: `%s'"
msgstr "ungültige Option für Zeilenbreite: »%s«"

#: src/fmt.c:385
#, c-format
msgid "invalid width: `%s'"
msgstr "ungültige Zeilenbreite: »%s«"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"Eingabezeilen jeder DATEI umbrechen (Vorgabe: Standardeingabe),\n"
"das Ergebnis auf Standardausgabe ausgeben.\n"
"\n"

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         Bytes anstatt Spalten zählen\n"
"  -s, --spaces        Umbruch bei Leerzeichen\n"
"  -w, --width=BREITE  BREITE Spalten anstatt 80 benutzen\n"

#: src/fold.c:267
#, c-format
msgid "`%s' option is obsolete; use `%s'"
msgstr "die Option »%s« ist überholt; bitte verwenden Sie »%s«"

#: src/fold.c:295
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "Ungültige Anzahl Spalten: »%s«"

#: src/head.c:92
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Die ersten 10 Zeilen jeder DATEI auf Standardausgabe ausgeben.\n"
"Mit mehr als einer DATEI, vorab den Dateinamen ausgeben.\n"
"Ohne DATEI oder DATEI ist »-«, Standardeingabe lesen.\n"
"\n"

#: src/head.c:101
msgid ""
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
msgstr ""
"  -c, --bytes=GRÖSSE       erste GRÖSSE Bytes ausgeben\n"
"  -n, --lines=ANZAHL       erste ANZAHL Zeilen statt 10 ausgeben\n"

#: src/head.c:105
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    nie Dateinamen vorab ausgeben\n"
"  -v, --verbose            immer Dateinamen vorab ausgeben\n"

#: src/head.c:111 src/split.c:119
msgid ""
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"\n"
"GRÖSSE kann ein Vervielfältigungssuffix haben: »b« für 512, »k« für 1K, »m« "
"für\n"
"1 Megabyte.\n"

#: src/head.c:189
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "es ist nicht möglich, den Datei-Zeiger für %s neu zu positionieren"

#: src/head.c:220 src/md5sum.c:334 src/md5sum.c:675 src/od.c:960 src/od.c:2000
#: src/pr.c:1166 src/pr.c:1373 src/pr.c:1495 src/tac.c:484 src/tac.c:490
#: src/tr.c:2028 src/tsort.c:585
msgid "standard input"
msgstr "Standardeingabe"

#: src/head.c:255 src/tail.c:1378
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s ist so groß, dass es nicht dargestellt werden kann"

#: src/head.c:256 src/tail.c:1380
msgid "number of lines"
msgstr "Anzahl Zeilen"

#: src/head.c:256 src/tail.c:1381
msgid "number of bytes"
msgstr "Anzahl Bytes"

#: src/head.c:263 src/tail.c:1467
msgid "invalid number of lines"
msgstr "ungültige Anzahl von Zeilen"

#: src/head.c:264 src/tail.c:1468
msgid "invalid number of bytes"
msgstr "ungültige Anzahl von Bytes"

#: src/head.c:340
#, c-format
msgid "unrecognized option `-%c'"
msgstr "Unbekannte Option »-%c«"

#: src/head.c:347
#, c-format
msgid "`-%s' option is obsolete; use `-%c %.*s%.*s%s'"
msgstr "die Option »-%s« ist überholt; bitte verwenden Sie »-%c %.*s%.*s%s«"

#: src/join.c:144
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Aufruf: %s [OPTION]... DATEI1 DATEI2\n"

#: src/join.c:148
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Für jedes Eingabezeilenpaar mit identischen Verschmelzungsfeldern, eine "
"Zeile\n"
"auf Standardausgabe schreiben.  Das voreingestellte Verschmelzungsfeld ist "
"das\n"
"erste durch Leerzeichen/Tabulator begrenzte Feld.  Wenn DATEI1 oder DATEI2\n"
"(nicht beide) »-« ist, Standardeingabe lesen.\n"
"\n"
"  -a SEITE           nicht-passende Zeilen von Datei SEITE ausgeben\n"
"  -e LEER            fehlende Eingabefelder durch LEER ersetzen\n"

#: src/join.c:156
msgid ""
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case  Unterschiede in Groß/Kleinschreibung ignorieren, wenn\n"
"                       Felder verglichen werden\n"
"  -j FELD            (überholt) äquivalent zu »-1 FELD -2 FELD«\n"
"  -j1 FELD           (überholt) äquivalent zu »-1 FELD«\n"
"  -j2 FELD           (überholt) äquivalent zu »-2 FELD«\n"
"  -o FORMAT          FORMAT benutzen, wenn Ausgabezeilen erstellt werden\n"
"  -t ZEICHEN         ZEICHEN als Trennzeichen für Ein- und Ausgabefelder\n"
"                       benutzen\n"

#: src/join.c:164
msgid ""
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
msgstr ""
"  -v SEITE           wie -a SEITE, aber verschmolzene Ausgabezeilen\n"
"                       unterdrücken\n"
"  -1 FELD            mit diesem FELD von DATEI1 unterdrücken\n"
"  -2 FELD            mit diesem FELD von DATEI2 unterdrücken\n"

#: src/join.c:171
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"\n"
"Außer wenn -t ZEICHEN angegeben wurde, trennen führende Leerzeichen Felder "
"und\n"
"sie werden ignoriert; andernfalls werden Felder von ZEICHEN getrennt.  "
"Jedes\n"
"FELD ist eine Feldnummer, beginnend mit 1.  FORMAT sind eine oder mehrere "
"durch\n"
"Komma- oder Leerzeichen getrennte Spezifikationen, jede beginnt mit\n"
"»SEITE.FELD« oder »0«.  Das voreingestellte FORMAT gibt das "
"Verschmelzungsfeld\n"
"aus, die restlichen Felder von DATEI1, die restlichen Felder von DATEI2, "
"alle\n"
"getrennt mit ZEICHEN.\n"

#: src/join.c:644
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "Ungültiger Feldbezeichner: »%s«"

#: src/join.c:658 src/join.c:771 src/join.c:807
#, c-format
msgid "invalid field number: `%s'"
msgstr "Ungültige Feldnummer: »%s«"

#: src/join.c:671
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "Ungültige Feldnummer in Feldbezeichner: »%s«"

#: src/join.c:791
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "Ungültige Feldnummer für Datei1: »%s«"

#: src/join.c:800
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "Ungültige Feldnummer für Datei2: »%s«"

#: src/join.c:832
msgid "too many non-option arguments"
msgstr "Zuviele Argumente, die keine Optionen sind"

#: src/join.c:854
msgid "too few non-option arguments"
msgstr "Zuwenige Argumente, die keine Optionen sind"

#: src/join.c:865
msgid "both files cannot be standard input"
msgstr "Alle beide Dateien können nicht Standardeingabe sein"

#: src/md5sum.c:38
msgid "Ulrich Drepper and Scott Miller"
msgstr "Ulrich Drepper und Scott Miller"

#: src/md5sum.c:125
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Aufruf: %s [OPTION] [DATEI]...\n"
"  oder:    %s [OPTION] --check [DATEI]\n"
"%s-Prüfsummen (%d Bits) ausgeben oder überprüfen.\n"
"Ohne DATEI oder wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/md5sum.c:134
#, c-format
msgid ""
"\n"
"  -b, --binary            read files in binary mode (default on DOS/"
"Windows)\n"
"  -c, --check             check %s sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
msgstr ""
"\n"
"  -b, --binary          Dateien im Binärmodus lesen (Vorgabe unter DOS/"
"Windows)\n"
"  -c, --check           %s-Summen gegen angegebene Liste gegenprüfen\n"
"  -t, --text            Dateien im Textmodus lesen (Vorgabe)\n"
"\n"

#: src/md5sum.c:142
msgid ""
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated checksum lines\n"
"\n"
msgstr ""
"Die folgenden beiden Optionen sind nur beim Überprüfen sinnvoll:\n"
"      --status          nichts ausgeben, der Statuscode zeigt Erfolg an\n"
"  -w, --warn            bei ungeeignet formatierten Prüfsummenzeilen warnen\n"
"\n"

#: src/md5sum.c:150
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"Die Summen werden berechnet, wie in %s beschrieben. Beim Überprüfen sollte\n"
"die Eingabe eine frühere Ausgabe dieses Programms sein.  Die normale\n"
"Arbeitsweise ist es, eine Zeile mit Prüfsumme, einem Zeichen, das den Typ\n"
"anzeigt (»*« für binär, » « für Text), und dem Namen jeder Datei "
"auszugeben.\n"

#: src/md5sum.c:379
#, c-format
msgid "%s: %lu: improperly formatted %s checksum line"
msgstr "%s: %lu: nicht korrekt formatierte %s-Prüfsummenzeile"

#: src/md5sum.c:401
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: Fehlschlag bei open oder read\n"

#: src/md5sum.c:425
msgid "FAILED"
msgstr "Fehlschlag"

#: src/md5sum.c:425
msgid "OK"
msgstr "Ok"

#: src/md5sum.c:438
#, c-format
msgid "%s: read error"
msgstr "%s: Lesefehler"

#: src/md5sum.c:451
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: keine korrekt formatierte %s-Prüfsummenzeile gefunden"

#: src/md5sum.c:464
#, c-format
msgid "WARNING: %d of %d listed %s could not be read"
msgstr "WARNUNG: %d von %d aufgeführten %s konnten nicht gelesen werden"

#: src/md5sum.c:467
msgid "file"
msgstr "Datei"

#: src/md5sum.c:467
msgid "files"
msgstr "Dateien"

#: src/md5sum.c:473
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "Warnung: %d von %d berechneten %s passten NICHT"

#: src/md5sum.c:476
msgid "checksum"
msgstr "Prüfsumme"

#: src/md5sum.c:476
msgid "checksums"
msgstr "Prüfsummen"

#: src/md5sum.c:558
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"Die Optionen --binary und --text sind bei der Kontrolle von Prüfsummen "
"sinnlos"

#: src/md5sum.c:566
msgid "the --string and --check options are mutually exclusive"
msgstr "Die Optionen --string und --check schließen sich gegenseitig aus"

#: src/md5sum.c:573
msgid "the --status option is meaningful only when verifying checksums"
msgstr "Die Option --status ist nur bei der Kontrolle von Prüfsummen sinnvoll"

#: src/md5sum.c:580
msgid "the --warn option is meaningful only when verifying checksums"
msgstr ""
"Die Option --warn ist nur nur bei der Kontrolle von Prüfsummen sinnvoll"

#: src/md5sum.c:590
msgid "no files may be specified when using --string"
msgstr "Bei Verwendung von --string dürfen keine Dateien angegeben werden"

#: src/md5sum.c:612
msgid "only one argument may be specified when using --check"
msgstr "Bei Verwendung von --check ist nur ein Argument zulässig"

#: src/nl.c:39
msgid "Scott Bartram and David MacKenzie"
msgstr "Scott Bartram und David MacKenzie"

#: src/nl.c:180
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Jede DATEI mit Zeilennummern nach Standardausgabe schreiben.\n"
"Ohne DATEI oder wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/nl.c:188
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=STIL       STIL zur Nummerierung benutzen\n"
"  -d, --section-delimiter=CC      CC benutzen, um logische Seiten zu "
"trennen\n"
"  -f, --footer-numbering=STIL     STIL benutzen, um Fußzeilen zu "
"nummerieren\n"

#: src/nl.c:193
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=STIL     STIL benutzen, um Kopfzeilen zu "
"nummerieren\n"
"  -i, --page-increment=ANZAHL     Zeilennummerinkrement in jeder Zeile\n"
"  -l, --join-blank-lines=ANZAHL   ANZAHL Leerzeilen zählen als eine\n"
"  -n, --number-format=FORMAT      Zeilennummern gemäß FORMAT einfügen\n"
"  -p, --no-renumber               logische Zeilennummer am Anfang von "
"logischen\n"
"                                    Seiten nicht zurücksetzen\n"
"  -s, --number-separator=ZKETTE   ZKETTE nach (möglicher) Zeilennummer "
"einfügen\n"

#: src/nl.c:201
msgid ""
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --first-page=ANZAHL         erste Zeilennummer auf jeder logischen "
"Seite\n"
"  -w, --number-width=ANZAHL       ANZAHL Spalten für Zeilennummern benutzen\n"

#: src/nl.c:207
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Standardeinstellung ist -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC sind\n"
"zwei Begrenzungszeichen, um logische Seiten zu trennen, ein fehlendes "
"zweites\n"
"Zeichen impliziert »:«.  Geben Sie \\\\ für \\ ein.  STIL ist einer aus:\n"

#: src/nl.c:213
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         alle Zeilen nummerieren\n"
"  t         nur nichtleere Zeilen nummerieren\n"
"  n         keine Zeilen nummerieren\n"
"  pREGEXP   nur Zeilen nummerieren, auf die REGEXP passt\n"
"\n"
"FORMAT ist eines der folgenden:\n"
"\n"
"  ln   linksbündig, keine führenden Nullen\n"
"  rn   rechtsbündig, keine führenden Nullen\n"
"  rz   rechtsbündig, führende Nullen\n"
"\n"

#: src/nl.c:500
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "Ungültige Startzeilennummer: »%s«"

#: src/nl.c:510
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "Ungültiges Inkrement für Zeilennummer: »%s«"

#: src/nl.c:523
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "Ungültige Anzahl von Leerzeilen: »%s«"

#: src/nl.c:537
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "Ungültige Breite des Feldes für die Zeilennummer: »%s«"

#: src/od.c:291
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"Aufruf: %s [OPTION]... [DATEI]...\n"
"  oder:    %s --traditional [DATEI] [[+]OFFSET [[+]MARKE]]\n"

#: src/od.c:296
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"Eine eindeutige Darstellung der DATEI, auf Standardausgabe ausgeben "
"(Vorgabe:\n"
"Oktalzahlen).  Bei mehr als einem Argument DATEI, die Dateien in der\n"
"angegebenen Folge verketten und die Eingabe zu bilden.\n"
"Ohne DATEI oder wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/od.c:303
msgid "All arguments to long options are mandatory for short options.\n"
msgstr ""
"Erforderliche Argumente für lange Optionen sind für kurze auch notwendig.\n"

#: src/od.c:306
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=RADIX   entscheiden, wie Dateioffsets ausgegeben "
"werden\n"
"  -j, --skip-bytes=BYTES      BYTES Eingabebytes am Anfang jeder Datei\n"
"                                übergehen\n"

#: src/od.c:310
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=BYTES      Ausgabe auf BYTES Eingabebytes pro Datei\n"
"                                begrenzen\n"
"  -s, --strings[=BYTES]       Ketten mit wenigstens BYTES alphanumerischen\n"
"                                Zeichen ausgeben\n"
"  -t, --format=TYP            Ausgabeformat(e) wählen\n"
"  -v, --output-duplicates     nicht * benutzen, um Zeilenunterdrückung\n"
"                                anzuzeigen\n"
"  -w, --width[=BYTES]         Anzahl BYTES pro Ausgabezeile ausgeben\n"
"      --traditional           Argumente in traditioneller Form akzeptieren\n"

#: src/od.c:320
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
msgstr ""
"\n"
"Traditionell spezifizierte Formatangaben können gemischt werden; sie werden\n"
"akkumuliert:\n"
"  -a   dasselbe wie -t a,  benannte Zeichen wählen\n"
"  -b   dasselbe wie -t oC, Oktalbytes wählen\n"
"  -c   dasselbe wie -t c,  ASCII-Zeichen oder Backslash-Escapes wählen\n"
"  -d   dasselbe wie -t u2, dezimale Shorts ohne Vorzeichen wählen\n"

#: src/od.c:328
msgid ""
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"  -f   dasselbe wie -t fF, Fließkommazahlen wählen\n"
"  -h   dasselbe wie -t x2, hexadezimale Shorts wählen\n"
"  -i   dasselbe wie -t d2, dezimale Shorts wählen\n"
"  -l   dasselbe wie -t d4, dezimale Longs wählen\n"
"  -o   dasselbe wie -t o2, oktale Shorts wählen\n"
"  -x   dasselbe wie -t x2, hexadezimale Shorts wählen\n"

#: src/od.c:336
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes may be . for octal and b for multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"Bei Verwendung der älteren Syntax (dem zweiten Aufrufformat), steht OFFSET "
"für\n"
"-j OFFSET.  MARKE ist die Pseudoadresse des ersten auszugebenden Bytes; sie\n"
"wird entsprechend erhöht, wenn die Ausgabe fortschreitet.  Für OFFSET und "
"MARKE\n"
"bedeutet ein 0x- oder 0X-Präfix hexadezimal, Suffixe können ».« für oktal "
"und\n"
"»b« für multipliziert mit 512 sein.\n"
"\n"
"TYP setzt sich zusammen aus einer oder mehreren dieser Spezifikationen:\n"
"\n"
"  a           ein benanntes Zeichen\n"
"  c           ASCII-Zeichen oder Backslash-Escape\n"

#: src/od.c:348
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[ANZAHL]   dezimal mit Vorzeichen, ANZAHL Bytes pro Zahl\n"
"  f[ANZAHL]   Fließkomma, ANZAHL Bytes pro Zahl\n"
"  o[ANZAHL]   oktal, ANZAHL Bytes pro Zahl\n"
"  u[ANZAHL]   dezimal ohne Vorzeichen, ANZAHL Bytes pro Zahl\n"
"  x[ANZAHL]   hexadezimal, ANZAHL Bytes pro Zahl\n"

#: src/od.c:355
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"ANZAHL ist eine Zahl.  Wenn TYP einer von »d«, »o«, »u«, oder »x« ist, kann\n"
"ANZAHL auch »C« für sizeof(char), »S« für sizeof(short) , »I« für sizeof"
"(int)\n"
"oder »L« für sizeof(long) sein.  Wenn TYP »f« ist, kann ANZAHL auch »F« für\n"
"sizeof(float), »D« für sizeof(double) oder »L« für sizeof(long double) "
"sein.\n"

#: src/od.c:362
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  "
msgstr ""
"\n"
"RADIX ist »d« für dezimal, »o« für oktal, »x« für hexadezimal oder »n« für\n"
"nichts.  BYTES ist hexadezimal mit 0x- oder 0X-Präfix, wird multipliziert "
"mit\n"
"512 für Suffix »b«, mit 1024 für »k« und mit 1048576 für »m«.  Wird ein "
"Suffix\n"
"»z« zu einem belibigen Typ angehängt, werden am Ende jeder Zeile die "
"druckbaren\n"
"Zeichen ausgegeben.  "

#: src/od.c:370
msgid ""
"--string without a number implies 3.  --width without a number\n"
"implies 32.  By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
"--string ohne Zahl impliziert »3«.  --width ohne Zahl impliziert »32«.\n"
"Standard ist -A o -t d2 -w 16.\n"

#: src/od.c:726 src/od.c:845
#, c-format
msgid "invalid type string `%s'"
msgstr "Ungültige Typbezeichnung »%s«"

#: src/od.c:736
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"Ungültiger Typ »%s«;\n"
"dieses System hat keinen Typ für %lu-Byte große Ganzzahlen"

#: src/od.c:855
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"Ungültiger Typ »%s«;\n"
"dieses System hat keinen Typ für %lu-Byte große Gleitkommazahlen"

#: src/od.c:918
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "Ungültiges Zeichen »%c« in Typenbezeichnung »%s«"

#: src/od.c:1145
msgid "cannot skip past end of combined input"
msgstr ""
"Es ist nicht möglich, hinter das Ende der kombinierten Eingabe vorzurücken"

#: src/od.c:1398
msgid "old-style offset"
msgstr "Offset der alten Art"

#: src/od.c:1706
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""
"Ungültiger Ausgabeadressradix »%c«; es muss ein Zeichen aus [doxn] sein"

#: src/od.c:1716
msgid "skip argument"
msgstr "Argument übergehen "

#: src/od.c:1724
msgid "limit argument"
msgstr "Argument begrenzen"

#: src/od.c:1734
msgid "minimum string length"
msgstr "Minimale Zeichenkettenlänge"

#: src/od.c:1739 src/od.c:1805
#, c-format
msgid "%s is too large"
msgstr "%s ist zu groß"

#: src/od.c:1803
msgid "width specification"
msgstr "Breitenangabe"

#: src/od.c:1825
msgid "no type may be specified when dumping strings"
msgstr "Bei der Ausgabe von Zeichenketten darf kein Typ angegeben werden"

#: src/od.c:1873
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "Ungültiger zweiter Operand im Kompatibilitätsmodus »%s«"

#: src/od.c:1894
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr ""
"Im Kompatibilitätsmodus müssen die letzten beiden Argumente Offsets sein"

#: src/od.c:1901
msgid "compatibility mode supports at most three arguments"
msgstr ""
"Im Kompatibilitätsmodus dürfen nicht mehr als 3 Argumente angegeben werden"

#: src/od.c:1974
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "Warnung: ungültige Breite %lu; %d wird benutzt"

#: src/od.c:1990
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: fmt=\"%s\" width=%d\n"

#: src/paste.c:50
msgid "David M. Ihnat and David MacKenzie"
msgstr "David M. Ihnat und David MacKenzie"

#: src/paste.c:208
msgid "standard input is closed"
msgstr "Standardeingabe ist geschlossen"

#: src/paste.c:407
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Zeilen auf Standardausgabe ausgeben, die aus sequenziell sich "
"entsprechenden\n"
"Zeilen jeder DATEI bestehen, getrennt durch Tabulatoren.  Ohne DATEI oder "
"wenn\n"
"DATEI »-« ist, Standardeingabe lesen.\n"
"\n"

#: src/paste.c:416
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=LISTE  Zeichen aus LISTE anstelle von Tabulatoren "
"benutzen\n"
"  -s, --serial            Dateien nacheinander ausgeben anstelle parallel\n"

#: src/pr.c:328
msgid "Pete TerMaat and Roland Huebner"
msgstr "Pete TerMaat und Roland Huebner"

#: src/pr.c:805
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "--pages: ungültige Angabe einer Seitenfolge: »%s«"

#: src/pr.c:817
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "--pages: ungültige Angabe der Startseite: »%s«"

#: src/pr.c:829
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "--pages: ungültige Angabe der Endseite: »%s«"

#: src/pr.c:836
msgid "`--pages' starting page number is larger than ending page number"
msgstr "--pages: Angabe der Startseite ist größer als Endseite"

#: src/pr.c:913
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "--pages=ERSTE_SEITE[:LETZTE_SEITE]: fehlendes Argument"

#: src/pr.c:924
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "--columns=SPALTE: ungültige Angabe der Spaltenanzahl: »%s«"

#: src/pr.c:978
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "-l SEITEN_LÄNGE: ungültige Angabe der Zeilenanzahl: »%s«"

#: src/pr.c:1002
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "-N ZAHL: ungültige Angabe der Startzeilennummer: »%s«"

#: src/pr.c:1014
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "-o RAND: ungültige Angabe des Zeilenoffsets: »%s«"

#: src/pr.c:1055
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "-w SEITEN_BREITE: ungültige Angabe der Zeichenanzahl: »%s«"

#: src/pr.c:1067
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "-W SEITEN_BREITE: ungültige Angabe der Zeichenanzahl: »%s«"

#: src/pr.c:1081
msgid "%b %e %H:%M %Y"
msgstr "%e. %b. %Y, %H:%M"

#: src/pr.c:1090
msgid "Cannot specify number of columns when printing in parallel."
msgstr ""
"Es ist nicht möglich, die Anzahl der Spalten bei Parallel-Ausgabe "
"festzulegen."

#: src/pr.c:1094
msgid "Cannot specify both printing across and printing in parallel."
msgstr ""
"Es ist nicht möglich, gleichzeitig bei Parallel- und Überkreuz-Ausgabe\n"
"festzulegen."

#: src/pr.c:1190
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr "»-%c« Extrazeichen oder ungültige Zahl im Argument: »%s«"

#: src/pr.c:1301
msgid "page width too narrow"
msgstr "Seitenbreite zu schmal"

#: src/pr.c:2364
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr "Startseitenangabe ist größer als Gesamtseitenzahl: »%d«"

#: src/pr.c:2395
#, c-format
msgid "Page %d"
msgstr "Seite %d"

#: src/pr.c:2761
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr "DATEI(en) in Seiten und Spalten unterteilen für eine Druckausgabe.\n"

#: src/pr.c:2768
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""
"  +ERSTE_SEITE[:LETZTE_SEITE], --pages=ERSTE_SEITE[:LETZTE_SEITE]\n"
"              Druck mit ERSTE_[LETZTE_]SEITE beginnen [beenden]\n"
"  -SPALTEN, --columns=SPALTEN\n"
"              SPALTEN-spaltige Ausgabe erzeugen und Spalten vertikal "
"schreiben,\n"
"              es sei denn, -a wurde benutzt.  Zahl der Zeilen in jeder "
"Spalte\n"
"              ausbalancieren.\n"

#: src/pr.c:2776
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across\n"
"              Spalten horizontal statt vertikal schreiben, wird zusammen\n"
"              mit -SPALTEN benutzt\n"
"  -c, --show-control\n"
"              Hut-Notation (^G) und oktale Backslash-Notation benutzen\n"
"  -d, --double-space\n"
"              doppelter Zeilenvorschub in der Ausgabe\n"

#: src/pr.c:2784
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=FORMAT\n"
"              FORMAT für die Datumsausgabe in der Kopfzeile benutzen\n"
"  -e[ZEICH[BREITE]], --expand-tabs[=ZEICH[BREITE]]\n"
"              Eingabe-ZEICHen (TABs) zu BREITE Leerzeichen (8) ersetzen \n"
"  -F, -f, --form-feed\n"
"              Seitenvorschübe statt Zeilenvorschübe benutzen, um Seiten zu\n"
"              trennen (duch einen 3-Zeilen-Seitenkopf bei -F oder einen\n"
"              5-Zeilen-Seitenkopf und -fuß ohne -F)\n"

#: src/pr.c:2794
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h KOPF, --header=KOPF\n"
"              KOPF als zentrierten Seitenkopf anstelle des Dateinamens "
"benutzen\n"
"              -h \"\" druckt eine leere Zeile, nicht -h\"\" benutzen.\n"
"  -i[ZEICH[BREITE]], --output-tabs[=ZEICH[BREITE]]\n"
"              Leerzeichen mit ZEICHen (TABs) auf BREITE (8) ersetzen\n"
"  -J, --join-lines\n"
"              zu vollen Zeilen zusammenziehen, gleichzeitig die durch -W\n"
"              veranlasste Zeilenbeschneidung abschalten, keine\n"
"              Spaltenausrichtung, --sep-string[=ZKETTE] setzt Trennzeichen\n"

#: src/pr.c:2803
msgid ""
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l SEITENLÄNGE, --length=SEITENLÄNGE\n"
"              Seitenlänge auf SEITENLÄNGE (66) Zeilen setzen\n"
"              (Vorgabe: 56 Zeilen, und mit -F 63)\n"
"  -m, --merge alle Dateien parallel ausgeben, eine in jeder Spalte,\n"
"              Zeilen abschneiden, aber Zeilen voller Länge bei -J "
"vereinigen\n"

#: src/pr.c:2810
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[SEP[ZIFFERN]], --number-lines[=SEP[ZIFFERN]]\n"
"              Zeilen nummerieren, ZIFFERN (5) Ziffern benutzen, dann SEP "
"(TAB),\n"
"              Vorgabe: Nummerierung beginnt mit der ersten Zeile der "
"Eingabe\n"
"  -N ZAHL, --first-line-number=ZAHL\n"
"              Nummerierung mit ZAHL bei der ersten Zeile der ersten Seite\n"
"              beginnen, die ausgedruckt wird (siehe auch +ERSTE_SEITE)\n"

#: src/pr.c:2818
msgid ""
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o RAND, --indent=RAND\n"
"              Zeile um RAND (null) Leerzeichen einrücken (beeinflusst nicht\n"
"              -w oder -W), RAND wird zu SEITEN_BREITE addiert\n"
"  -r, --no-file-warnings\n"
"              Warnung unterdrücken, wenn eine Datei nicht geöffnet werden "
"kann\n"

# CHECKIT
# space missing
# 2001-11-23 20:32:53 CET -ke-
#: src/pr.c:2825
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ZEICHEN],--separator[=ZEICHEN]\n"
"                    Spalten durch ein einziges Zeichen trennen, Vorgabe für\n"
"                    ZEICHEN ist das TAB-Zeichen ohne -w und \"kein Zeichen"
"\"\n"
"                    mit -w -s[ZEICHEN] schaltet Zeilenabschneidung ab bei "
"allen\n"
"                    drei Spaltenoptionen (-SPALTE|-a -SPALTE|-m), außer bei -"
"w\n"

#: src/pr.c:2832
msgid "  -SSTRING, --sep-string[=STRING]\n"
msgstr "  -SZKETTE, --sep-string[=ZKETTE]\n"

#: src/pr.c:2835
msgid ""
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
msgstr ""
"  -S[ZKETTE], --sep-string[=ZKETTE]\n"
"                    Spalten durch eine optionale ZKETTE trennen,\n"
"                    ohne -S: Vorgabetrennzeichen ist <TAB> mit -J und\n"
"                    <Leerzeichen> sonst (dasselbe wie -S\" \"), hat keine\n"
"                    Auswirkung auf Spaltenoptionen\n"
"  -t, --omit-header Kopf- und Fußzeilen unterdrücken\n"

#: src/pr.c:2841
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    Kopf- und Fußzeilen unterdrücken, Seitenvorschubangaben "
"der\n"
"                    Eingabedateien ignorieren\n"
"  -v, --show-nonprinting\n"
"                    oktale Backslash-Notation benutzen\n"
"  -w SEITEN_BREITE, --width=SEITEN_BREITE\n"
"                    Seitenbreite auf SEITEN_BREITE (72) Zeichen nur für "
"Ausgabe\n"
"                    mehrfacher Textspalten setzen, -s[Zeichen] schaltet (72) "
"ab\n"

#: src/pr.c:2851
msgid ""
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W SEITEN_BREITE, --page-width=SEITEN_BREITE\n"
"                    Seitenbreite immer auf SEITEN_BREITE (72) Zeichen "
"setzen,\n"
"                    Zeilen abschneide, es sei denn -J ist gesetzt, kein\n"
"                    Zusammenspiel mit -S oder -s\n"

#: src/pr.c:2859
msgid ""
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"\n"
"-T wird impliziert von -l nn, wenn nn <= 10 oder <= 3 mit -F.  Ohne DATEI "
"oder\n"
"wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/ptx.c:410
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (für reguläre Ausdrücke »%s«)"

#: src/ptx.c:1859
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Aufruf: %s [OPTION]... [EINGABE]...   (ohne -G)\n"
"  oder:    %s -G [OPTION]... [EINGABE [AUSGABE]]\n"

#: src/ptx.c:1863
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""
"Einen permutierten Index der Wörter der Eingabedateien einschließlich "
"Kontext\n"
"ausgeben.\n"
"\n"

#: src/ptx.c:1870
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A, --auto-reference           automatisch generierte Referenzen ausgeben\n"
"  -C, --copyright                Copyright und Kopierbedingungen ausgeben\n"
"  -G, --traditional              mehr wie »ptx« von System V funktionieren\n"
"  -F, --flag-truncation=ZKETTE   ZKETTE benutzen, um Abschneidungen "
"anzuzeigen\n"

#: src/ptx.c:1876
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=ZKETTE        Makroname, der statt »xx« zu benutzen ist\n"
"  -O, --format=roff              Ausgabe als roff-Anweisungen erzeugen\n"
"  -R, --right-side-refs          Referenzen nach rechts setzen, in -w nicht\n"
"                                   gezählt\n"
"  -S, --sentence-regexp=REGEXP   für Zeilen- oder Satzende\n"
"  -T, --format=tex               Ausgabe als TeX-Anweisungen erzeugen\n"

#: src/ptx.c:1883
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       REGEXP benutzen, um jedes Schlüsselwort\n"
"                                   abzubilden\n"
"  -b, --break-file=DATEI         Wortendezeichen in dieser Datei\n"
"  -f, --ignore-case              zum Sortieren Klein- in Großschreibung "
"wandeln\n"
"  -g, --gap-size=NUMBER          Zwischenraumgröße zwischen Ausgabefeldern\n"
"  -i, --ignore-file=DATEI        Liste zu ignorierender Wörter aus DATEI "
"lesen\n"
"  -o, --only-file=DATEI          Wortliste nur aus dieser DATEI lesen\n"

#: src/ptx.c:1891
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               erstes Feld jeder Zeile ist eine Referenz\n"
"  -t, --typeset-mode               - nicht implementiert -\n"
"  -w, --width=ANZAHL             Ausgabebreite innerhalb der Spalten, ohne "
"die\n"
"                                   Referenzen\n"

#: src/ptx.c:1898
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"Ohne DATEI, oder falls DATEI »-« ist, Standardeingabe lesen.  Vorgabe: »-"
"F /«.\n"

#: src/ptx.c:1978
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
msgstr ""
"Dieses Programm ist freie Software; Sie dürfen es weitergeben und/oder\n"
"verändern gemäß den Bestimmungen der GNU General Public License, "
"veröffentlicht\n"
"von der Free Software Foundation; entweder in Version 2, oder (nach Wahl)\n"
"einer späteren Version.\n"
"\n"

#: src/ptx.c:1985
msgid ""
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
msgstr ""
"Dieses Programm wird verteilt in der Hoffnung, das es nützlich sein\n"
"wird, aber OHNE JEGLICHE GARANTIE; sogar ohne jegliche implizite\n"
"Garantie der VERKAUFBARKEIT oder der TAUGLICHKEIT FÜR EINEN\n"
"BESTIMMTEN ZWECK. Siehe auch die GNU General Public License für\n"
"weitere Details.\n"
"\n"

#: src/ptx.c:1992
msgid ""
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"Sie sollten eine Kopie der GNU General Public License mit diesem Programm\n"
"erhalten haben; falls nicht, schreiben Sie bitte an die\n"
"\n"
"        Free Software Foundation, Inc.\n"
"        59 Temple Place - Suite 330\n"
"        Boston, MA 02111-1307\n"
"        USA\n"

#: src/sort.c:53
msgid "Mike Haertel and Paul Eggert"
msgstr "Mike Haertel und Paul Eggert"

#: src/sort.c:283
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"Ordering options:\n"
"\n"
msgstr ""
"Aneinanderfügung aller DATEI(en) sortiert nach der Standardausgabe "
"schreiben.\n"
"\n"
"Sortieroptionen:\n"
"\n"

#: src/sort.c:292
msgid ""
"  -b, --ignore-leading-blanks ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks   führende Leerzeichen ignorieren\n"
"  -d, --dictionary-order        nur Leer- und alphanumerische Zeichen "
"beachten\n"
"  -f, --ignore-case             Klein- als Großbuchstaben behandeln\n"

#: src/sort.c:297
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -r, --reverse               reverse the result of comparisons\n"
"\n"
msgstr ""
"  -g, --general-numeric-sort    anhand des allgemeinen numerischen Wertes\n"
"                                  sortieren\n"
"  -i, --ignore-nonprinting      nur druckbare Zeichen beachten\n"
"  -M, --month-sort              Reihenfolge: (unbekannt) < »JAN« < ... < "
"»DEZ«\n"
"  -n, --numeric-sort            anhand des numerischen WErts sortieren\n"
"  -r, --reverse                 das Ergebnis der Sortierung umkehren\n"
"\n"

#: src/sort.c:305
msgid ""
"Other options:\n"
"\n"
"  -c, --check               check whether input is sorted; do not sort\n"
"  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"Andere Optionen:\n"
"\n"
"  -c, --check               prüfen, ob Eingabe sortiert ist; nicht "
"sortieren\n"
"  -k, --key=POS1[,POS2]     Schlüssel geht von POS1 bis POS2 (beginnend mit "
"1)\n"
"  -m, --merge               schon sortierte Dateien zusammenführen; nicht\n"
"                              sortieren\n"
"  -o, --output=DATEI        Ergebnis in DATEI schreiben statt "
"Standardeingabe\n"
"  -s, --stable              Sortierung stabilisieren (dabei "
"Rückzugssortierung\n"
"                              deaktivieren)\n"
"  -S, --buffer-size=GRÖSSE  GRÖSSE für Hauptspeicherpuffer benutzen\n"

#: src/sort.c:315
#, c-format
msgid ""
"  -t, --field-separator=SEP use SEP instead of non- to whitespace "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c: check for strict ordering\n"
"                              otherwise: output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=SEP SEP benutzen statt Nicht- zu Leerraumübergang\n"
"                              (whitespace transition)\n"
"  -T, --temporary-directory=VERZ\n"
"                            für temporäre Dateien VERZ statt $TMPDIR oder %"
"s;\n"
"                              kann mehrfach gegeben werden\n"
"  -u, --unique              mit -c: auf strikte Odnung prüfen; andernfalls: "
"nur\n"
"                              das erste von mehreren Gleichen ausgeben\n"

#: src/sort.c:322
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     Zeilen mit Nullbyte beenden, nicht mit\n"
"                              Zeilenvorschub\n"

#: src/sort.c:327
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field.  OPTS is one or more single-letter ordering options, which\n"
"override global ordering options for that key.  If no key is given, use the\n"
"entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS ist F[.Z][OPTS], wobei F eine Feldnummer und Z eine Zeichenposition im "
"Feld\n"
"ist.  OPTS setzt sich zusammen aus einer oder mehreren Ordnungsoptionen mit\n"
"einem Buchstaben, die die globalen Ordnungsoptionen für diesen Schlüssel "
"außer\n"
"Kraft setzen.  Wenn kein Schlüssel angegeben wurde, wird die ganze Zeile "
"als\n"
"Schlüssel benutzt.\n"
"\n"
"GRÖSSE kann einer der folgenden multiplikativen Suffixe sein:\n"

#: src/sort.c:336
#, c-format
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% des Speichers, b 1, k 1024 (Vorgabe), und so weiter für M, G, T, P, E, "
"Z,\n"
"Y.\n"
"\n"
"Ohne DATEI, oder wenn DATEI »-« ist, Standardeingabe lesen.\n"
"\n"
"*** WARNUNG ***\n"
"Die eingestellte Locale beeinflusst die Sortierreihenfolge.\n"
"Setzen Sie LC_ALL=C, um die traditionelle Sortierreihenfolge zu aktivieren, "
"bei\n"
"der native Bytewerte verwendet werden.\n"

#: src/sort.c:447
msgid "cannot create temporary file"
msgstr "temporäre Datei konnte nicht angelegt werden"

#: src/sort.c:470
msgid "open failed"
msgstr "Fehler beim Öffnen"

#: src/sort.c:490 src/sort.c:2488
msgid "close failed"
msgstr "Fehler beim Schließen"

#: src/sort.c:498
msgid "write failed"
msgstr "Fehler beim Schreiben"

#: src/sort.c:644
msgid "sort size"
msgstr "Sortiergröße"

#: src/sort.c:718
msgid "stat failed"
msgstr "»stat« fehlgeschlagen"

#: src/sort.c:970
msgid "read failed"
msgstr "Lesen fehlgeschlagen"

#: src/sort.c:1566
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: ungeordnet: "

#: src/sort.c:1570
msgid "standard error"
msgstr "Standardfehler"

#: src/sort.c:2028
#, c-format
msgid "%s: invalid field specification `%s'"
msgstr "%s: ungültige Feldangabe »%s«"

#: src/sort.c:2054
#, c-format
msgid "%s: count `%.*s' too large"
msgstr "%s: Anzahl »%.*s« zu groß"

#: src/sort.c:2060
#, c-format
msgid "%s: invalid count at start of `%s'"
msgstr "%s: ungültige Zähler am Anfang von »%s«"

#: src/sort.c:2290
msgid "invalid number after `-'"
msgstr "ungültige Zahl hinter »-«"

#: src/sort.c:2293 src/sort.c:2339 src/sort.c:2366
msgid "invalid number after `.'"
msgstr "ungültige Zahl hinter ».«"

#: src/sort.c:2296 src/sort.c:2375
msgid "stray character in field spec"
msgstr "verirrte Buchstaben in Feldspezifikation"

#: src/sort.c:2330
msgid "invalid number at field start"
msgstr "ungültige Zahl am Feldanfang"

#: src/sort.c:2334 src/sort.c:2362
msgid "field number is zero"
msgstr "Feldnummer ist Null"

#: src/sort.c:2343
msgid "character offset is zero"
msgstr "Zeichenversatz ist Null"

#: src/sort.c:2358
msgid "invalid number after `,'"
msgstr "ungültige Zahl hinter »,«"

#: src/sort.c:2403
#, c-format
msgid "multi-character tab `%s'"
msgstr "Multi-Zeichen-Tab »%s«"

#: src/sort.c:2471
#, c-format
msgid "extra operand `%s' not allowed with -c"
msgstr "zusätzlicher Operand »%s« nicht erlaubt mit -c"

#: src/split.c:95
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "Aufruf: %s [OPTION] [EINGABE [PRÄFIX]]\n"

#: src/split.c:99
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
msgstr ""
"Stücke fester Größe der EINGABE auf PRÄFIXaa, PRÄFIXab, ... ausgeben; "
"Vorgabe\n"
"für PRÄFIX ist »x«.  Wenn keine EINGABE angegeben wurde oder die EINGABE "
"»-«\n"
"ist, Standardeingabe lesen.\n"
"\n"

#: src/split.c:107
#, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"  -a, --suffix-length=N    Suffixe mit Länge N verwenden (Vorgabe %d)\n"
"  -b, --bytes=GRÖSSE       GRÖSSE Bytes in die Ausgabedatei ausgeben\n"
"  -C, --line-bytes=GRÖSSE  höchstens GRÖSSE Bytes pro Zeile auf die Ausgabe\n"
"                             schreiben\n"
"  -l, --lines=ANZAHL       ANZAHL Zeilen in die Ausgabedatei ausgeben\n"

#: src/split.c:113
msgid ""
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
msgstr ""
"      --verbose            Meldung auf Standardfehlerausgabe ausgeben, "
"bevor\n"
"                             jede Ausgabedatei geöffnet wird\n"

#: src/split.c:170
msgid "Output file suffixes exhausted"
msgstr "Kein Suffix für Ausgabedateien mehr verfügbar"

#: src/split.c:188
#, c-format
msgid "creating file `%s'\n"
msgstr "Datei »%s« wird angelgt\n"

#: src/split.c:407
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s: ungültige Suffixlänge"

#: src/split.c:416 src/split.c:432 src/split.c:448 src/split.c:474
msgid "cannot split in more than one way"
msgstr "Es ist nicht möglich, auf mehr als eine Art zu splitten"

#: src/split.c:423 src/split.c:456
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: ungültige Anzahl von Bytes"

#: src/split.c:439
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: ungültige Anzahl von Zeilen"

#: src/split.c:499
#, c-format
msgid "`-%d' option is obsolete; use `-l %d'"
msgstr "die Option »-%d« ist überholt; bitte verwenden Sie »-l %d«"

#: src/split.c:512
msgid "invalid number"
msgstr "Ungültige Anzahl"

#: src/split.c:527 src/tr.c:1849
msgid "too many arguments"
msgstr "Zuviele Argumente"

#: src/sum.c:36
msgid "Kayvan Aghaiepour and David MacKenzie"
msgstr "Kayvan Aghaiepour und David MacKenzie"

#: src/sum.c:64
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Prüfsumme und Blockanzahl für jede DATEI ausgeben.\n"
"\n"
"  -r              BSD-Summenalgorithmus benutzen, 1K Blöcke verwenden "
"(Vorgabe)\n"
"  -s, --sysv      System-V-Summenalgorithmus benutzen, 512-Byte-Blöcke\n"
"                    verwenden\n"

#: src/sys2.h:483
msgid "      --help     display this help and exit\n"
msgstr "      --help      diese Hilfe anzeigen und das Programm beenden\n"

#: src/sys2.h:485
msgid "      --version  output version information and exit\n"
msgstr ""
"      --version   Versionsinformation anzeigen und das Programm beenden\n"

#: src/tac.c:54
msgid "Jay Lepreau and David MacKenzie"
msgstr "Jay Lepreau und David MacKenzie"

#: src/tac.c:131
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Jede DATEI nach Standardausgabe schreiben, die letzte Zeile zuerst.\n"
"Wurde keine DATEI angegeben oder ist DATEI »-«, Standardeingabe lesen.\n"

#: src/tac.c:139
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             Trennzeichen vorher statt hinterher einfügen\n"
"  -r, --regex              das Trennzeichen als regulären Ausdruck\n"
"                             interpretieren\n"
"  -s, --separator=ZKETTE   ZKETTE als Trenzeichen statt Zeilenumbruch "
"benutzen\n"

#: src/tac.c:454 src/tac.c:593
msgid "stdin: read error"
msgstr "Standardeingabe: Lesefehler"

#: src/tac.c:639
msgid "separator cannot be empty"
msgstr "Trennzeichen darf nicht leer sein"

#: src/tail.c:242
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Die letzten %d Zeilen jeder DATEI auf Standardausgabe ausgeben.  Wurden\n"
"mehrere DATEIen angegeben, wird für jede zunächst der Dateinamen ausgeben.\n"
"Ohne DATEI, oder wenn DATEI »-« ist, von der Standardeingabe lesen.\n"
"\n"

#: src/tail.c:251
msgid ""
"      --retry              keep trying to open a file even if it is\n"
"                           inaccessible when tail starts or if it becomes\n"
"                           inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
msgstr ""
"      --retry              weiterhin versuchen, eine Datei zu öffnen, auch "
"wenn\n"
"                             sie beim Start nicht verfügbar ist oder später\n"
"                             nicht mehr verfügbar ist; nur mit -f sinnvoll\n"
"  -c, --bytes=N            die letzten N Bytes ausgeben\n"

#: src/tail.c:257
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           angefügte Daten ausgeben, während die Datei "
"wächst;\n"
"                             »-f«, »--follow« und »--follow=descriptor« "
"sind\n"
"                             äquivalent\n"
"  -F                       gleichbedeutend mit »--follow=name --retry«\n"

#: src/tail.c:264
#, c-format
msgid ""
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""
"  -n, --lines=N            die letzten N Zeilen ausgeben, anstelle der "
"letzen %d\n"
"      --max-unchanged-stats=N\n"
"                           mit --follow=name die DATEI erneut öffnen, wenn "
"sie\n"
"                             nach N Iterationen (Vorgabe: %d) unverändert "
"ist,\n"
"                             um zu sehen, ob sie gelöscht oder umbenannt "
"wurde\n"
"                             (das ist normalerweise der Fall bei rotierten\n"
"                             Logdateien)\n"

#: src/tail.c:275
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
"                           (default 1) seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"      --pid=PID            mit -f: Programm beenden, wenn PID beendet wird\n"
"  -q, --quiet, --silent    nie Dateinamen ausgeben\n"
"  -s, --sleep-interval=S   mit -f: Pause von S (oder 1) Sek. zwischen "
"Versuchen\n"
"  -v, --verbose            immer Dateinamen vorab ausgeben\n"

#: src/tail.c:284
msgid ""
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).\n"
"\n"
msgstr ""
"\n"
"Wenn das erste Zeichen von N (der Anzahl der Bytes oder Zeilen) ein »+« "
"ist,\n"
"die Ausgabe mit dem Nten Byte bzw. der Nten Zeile vom Anfang jeder Datei\n"
"beginnen, andernfalls die letzten N Bytes bzw. Zeilen ausgeben.  N kann "
"einen\n"
"Vervielfachungssuffix haben: »b« für 512, »k« für 1024, »m« für 1048576\n"
"(1 Megabyte).\n"
"\n"

#: src/tail.c:292
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""
"Mit --follow (-f) verfolgt tail den Datei-Deskriptor.  Dies bedeutet, dass "
"auch\n"
"im Falle einer Umbenennung tail das Ende verfolgen wird.  "

#: src/tail.c:297
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""
"Dieses Verhalten ist nicht erwünscht, wenn man wirklich den derzeitigen "
"Namen\n"
"der Datei verfolgen will und nicht den Datei-Deskriptor (z. B. bei Rotation "
"der\n"
"Protokoll-Dateien, Logs).  Benutzen Sie in diesem Fall --follow=name.  Dies\n"
"bewirkt, dass tail die Datei immer wieder schließt und öffnet, um zu sehen, "
"ob\n"
"die Datei gelöscht und von einem anderen Programm neu angelegt wurde.\n"
"\n"

#: src/tail.c:335
#, c-format
msgid "closing %s (fd=%d)"
msgstr "%s wird geschlossen (df=%d)"

#: src/tail.c:400
#, c-format
msgid "%s: cannot seek to offset %s%s"
msgstr "%s: es ist nicht möglich, zum Offset %s%s zu springen"

#: src/tail.c:404
#, c-format
msgid "%s: cannot seek to relative offset %s%s"
msgstr "%s: es ist nicht möglich, zum relativen Offset %s%s zu springen"

#: src/tail.c:408
#, c-format
msgid "%s: cannot seek to end-relative offset %s%s"
msgstr ""
"%s: es ist nicht möglich, vom Ende her zum relativen Offset %s%s zu springen"

#: src/tail.c:814
#, c-format
msgid "`%s' has become inaccessible"
msgstr "auf »%s« kann nicht mehr zugegriffen werden"

#: src/tail.c:831
#, c-format
msgid "`%s' has been replaced with an untailable file; giving up on this name"
msgstr "»%s« wurde ersetzt mit einer ungeeigneten Datei; kein weiterer Versuch"

#: src/tail.c:852
#, c-format
msgid "`%s' has become accessible"
msgstr "auf »%s« kann jetzt zugegriffen werden"

#: src/tail.c:860
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "»%s« ist aufgetaucht; nach dem Ende einer neuen Datei"

#: src/tail.c:871
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "»%s« wurde ersetzt; nach dem Ende einer neuen Datei"

#: src/tail.c:996
#, c-format
msgid "%s: file truncated"
msgstr "%s: Datei abgeschnitten"

#: src/tail.c:1016
msgid "no files remaining"
msgstr "Keine Dateien mehr übrig"

#: src/tail.c:1226
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr ""
"%s: es ist nicht möglich, bis zum Ende dieses Dateityps vorgehen;\n"
"  kein weiterer Versuch für diesen Namen"

#: src/tail.c:1346
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: ungültiges Suffix-Zeichen in überholter Option"

#: src/tail.c:1395
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"Zu viele Argumente.\n"
"Wenn überholte Optionssyntax (%s) von »tail« benutzt wird,\n"
"darf nicht mehr als ein Dateiargument angegeben werden.  Stattdessen sollte\n"
"-n oder -c benutzt werden."

#: src/tail.c:1404
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"Warnung: Es ist nicht portabel, zwei oder mehr Dateiargumente mit der\n"
"überholten Optionssyntax (%s) zu benutzen.  Stattdessen sollte die\n"
"entsprechende Option -n oder -c benutzt werden."

#: src/tail.c:1413
#, c-format
msgid "`%s' option is obsolete; use `%s-%c %.*s'"
msgstr "die Option »%s« ist überholt; bitte verwenden Sie »%s-%c %.*s«"

#: src/tail.c:1473
#, c-format
msgid "%s: is so large that it is not representable"
msgstr "%s: ist so groß, dass es nicht dargestellt werden kann"

#: src/tail.c:1477
#, c-format
msgid "%s is larger than the maximum file size on this system"
msgstr "%s ist größer als die maximale Dateigröße auf diesem System"

#: src/tail.c:1503
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr ""
"%s: ungültige maximale Anzahl von ungeänderten »stats« zwischen Öffnungen"

#: src/tail.c:1515
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s: ungültige Anzahl von aufeinanderfolgenden Größenänderungen"

#: src/tail.c:1527
#, c-format
msgid "%s: invalid PID"
msgstr "%s: ungültige PID"

#: src/tail.c:1545
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: ungültige Anzahl von Sekunden"

#: src/tail.c:1565
msgid "warning: --retry is useful only when following by name"
msgstr "Warnung: --retry ist nur sinnvoll, wenn dieser Option ein Name folgt"

#: src/tail.c:1569
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "Warnung: PID ignoriert; --pid=PID ist nur sinnvoll, wenn es folgt"

#: src/tail.c:1572
msgid "warning: --pid=PID is not supported on this system"
msgstr "Warnung: --pid=PID wird auf diesem System nicht unterstützt"

#: src/tr.c:327
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Aufruf: %s [OPTION]... MENGE1 [MENGE2]\n"

#: src/tr.c:331
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Zeichen von Standardeingabe wandeln, verdichten und/oder löschen; auf\n"
"Standardausgabe schreiben.\n"
"\n"
"  -c, --complement        erstes Komplement MENGE1\n"
"  -d, --delete            Zeichen der MENGE1 löschen, nicht wandeln\n"
"  -s, --squeeze-repeats   jede Eingabefolge eines wiederholten Zeichens, "
"das\n"
"                            in MENGE1 enthalten ist, durch ein einzelnes\n"
"                            Vorkommens dieses Zeichens ersetzen\n"
"  -t, --truncate-set1     zuerst MENGE1 auf die Länge von MENGE2 "
"abschneiden\n"

#: src/tr.c:344
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"MENGEn werden angegeben als Zeichenketten.  Die meisten Zeichen stehen für "
"sich\n"
"selbst.  Interpretierte Folgen sind:\n"
"\n"
"  \\NNN            Zeichen mit Oktalwert NNN (1 bis 3 oktale Ziffern)\n"
"  \\\\              Backslash (\\)\n"
"  \\a              hörbarer Ton (Piep)\n"
"  \\b              Zeichen zurück\n"
"  \\f              Seitenvorschub\n"
"  \\n              Zeilenvorschub\n"
"  \\r              Wagenrücklauf\n"
"  \\t              horizontaler Tabulator\n"

#: src/tr.c:358
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              vertikaler Tabulator\n"
"  ZEICH1-ZEICH2   alle Zeichen von ZEICH1 bis ZEICH2 aufsteigend\n"
"  [ZEICH*]        in MENGE2, Kopien von ZEICH bis zur Länge von MENGE1\n"
"  [ZEICH*ANZ]     ANZ Kopien von ZEICHEN, ANZ ist oktal, wenn es mit 0 "
"beginnt\n"
"  [:alnum:]       alle Buchstaben und Ziffern\n"
"  [:alpha:]       alle Buchstaben\n"
"  [:blank:]       alle horizontalen Leerzeichen/Tabulatoren\n"
"  [:cntrl:]       alle Kontrollzeichen\n"
"  [:digit:]       alle Ziffern\n"

#: src/tr.c:369
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       alle druckbaren Zeichen, ohne Leerzeichen\n"
"  [:lower:]       alle Kleinbuchstaben\n"
"  [:print:]       alle druckbaren Zeichen, einschl. Leerzeichen\n"
"  [:punct:]       alle Satzzeichen\n"
"  [:space:]       alle horizontalen oder vertikalen Leerzeichen/Tabulatoren\n"
"  [:upper:]       alle Großbuchstaben\n"
"  [:xdigit:]      alle hexadezimalen Ziffern\n"
"  [=ZEICHEN=]     alle Zeichen äquivalent zu ZEICHEN\n"

#: src/tr.c:379
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  "
msgstr ""
"\n"
"Wandlung wird durchgeführt, wenn nicht -d spezifiziert ist und sowohl "
"MENGE1\n"
"als auch MENGE2 angegeben sind.  -t darf nur bei Wandlung benutzt werden.\n"
"MENGE2 wird, wenn nötig, durch Wiederholung des letzten Zeichens auf die "
"Länge\n"
"von MENGE1 vergrößert.  "

#: src/tr.c:385
msgid ""
"Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  "
msgstr ""
"Zusätzliche Zeichen in MENGE2 werden ignoriert.  Nur\n"
"[:lower:] und [:upper:] werden mit Sicherheit in aufsteigender Reihenfolge\n"
"expandiert.  In MENGE2 dürfen sie zum Wandeln nur in Paaren benutzt werden, "
"um\n"
"eine Groß-/Kleinschreibung anzuzeigen.  "

#: src/tr.c:391
msgid ""
"-s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"-s benutzt MENGE1, wenn nicht\n"
"umgewandelt oder gelöscht wird; andernfalls wird MENGE2 zum Verdichten "
"benutzt\n"
"und erscheint nach Wandlung und Löschung.\n"

#: src/tr.c:557
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"Warnung: die mehrdeutige Oktal-Escape \\%c%c%c wird als 2-Byte-Folge\n"
"\t \\0%c%c, »%c« interpretiert"

#: src/tr.c:566
msgid "invalid backslash escape at end of string"
msgstr "Ungültiger Backslash (\\)  am Ende der Zeichenkette"

#: src/tr.c:572
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "Ungültige Benutzung des Backslashs »\\%c«"

#: src/tr.c:725
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr ""
"Die Endpunkte des Bereiches »%s-%s« sind in umgekehrter Sortierreihenfolge"

#: src/tr.c:906
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "Ungültige Wiederholungsangabe »%s« in [c*n] Konstrukt"

#: src/tr.c:999
msgid "missing character class name `[::]'"
msgstr "Fehlender Zeichenklassename »[::]«"

#: src/tr.c:1002
msgid "missing equivalence class character `[==]'"
msgstr "Fehlendes Äquivalenzklassenzeichen »[==]«"

#: src/tr.c:1025
#, c-format
msgid "invalid character class `%s'"
msgstr "Ungültige Zeichenklasse »%s«"

#: src/tr.c:1050
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: Äquivalenzklassenoperand muss ein einzelnes Zeichen sein"

#: src/tr.c:1522
msgid "the [c*] repeat construct may not appear in string1"
msgstr "Die [c*] Wiederholungsangabe darf nicht in String1 erscheinen"

#: src/tr.c:1532
msgid "only one [c*] repeat construct may appear in string2"
msgstr "Nur eine [c*] Wiederholungsangabe darf in String2 auftreten"

#: src/tr.c:1540
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "[=c=] Ausdrücke dürfen beim Wandeln nicht in String2 auftauchen"

#: src/tr.c:1553
msgid "when not truncating set1, string2 must be non-empty"
msgstr "Wenn Menge1 nicht abgeschnitten wird, darf String2 nicht leer sein"

#: src/tr.c:1562
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"Beim Wandeln mit \"complemented character classes\" muss\n"
"String2 alle Zeichen im Bereich auf eines abbilden"

#: src/tr.c:1569
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"Beim Wandeln dürfen in string2 nur die Zeichenklassen »upper« und »lower«\n"
"verwendet werden"

#: src/tr.c:1578
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "Das [c*] Konstrukt darf in Kette2 nur bei Wandlungen auftauchen"

#: src/tr.c:1854
msgid "two strings must be given when translating"
msgstr "Beim Wandeln müssen zwei Zeichenketten angegeben werden"

#: src/tr.c:1857
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr "Beim Löschen mit Verdichten müssen zwei Zeichenketten angegeben werden"

#: src/tr.c:1871
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""
"Beim Löschen ohne Verdichten darf nur eine Zeichenkette angegeben werden"

#: src/tr.c:1877
msgid "at least one string must be given when squeezing repeats"
msgstr ""
"Beim Löschen von Wiederholungen muss mindestens\n"
"eine Zeichenkette angegeben werden"

#: src/tr.c:1968
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "fehlerhaft positioniertes [:upper:]- und/oder [:lower:]-Konstrukt"

#: src/tr.c:1991
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"ungültige Identitätsabbildung; bei Wandlungen muss jedes [:lower:]- oder\n"
"[:upper:]-Konstrukt in Kette1 mit dem entsprechenden [:lower:]- oder\n"
"[:upper:]-Konstrukt in Kette2 in Übereinstimmung gebracht werden"

#: src/tsort.c:97
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Aufruf: %s [OPTION] [DATEI]\n"
"\n"
"Vollkommen geordnete Liste in Übereinstimmung mit der partiellen Ordnung in\n"
"DATEI schreiben.\n"
"Ohne DATEI, oder falls DATEI »-« ist, Standardeingabe lesen.\n"
"\n"

#: src/tsort.c:533
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: Eingabe enthält eine Schleife:"

#: src/tsort.c:575
msgid "only one argument may be specified"
msgstr "Nur ein Argument ist zulässig."

#: src/unexpand.c:379
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Alle Leerzeichen in jeder DATEI in Tabulatoren wandeln, auf Standardausgabe\n"
"schreiben.  Ohne DATEI, oder wenn DATEI »-« ist, Standardeingabe lesen.\n"

#: src/unexpand.c:387
msgid ""
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -a, --all           alle Leerzeichen wandeln, statt nur der führendenen\n"
"  -t, --tabs=ANZAHL   Tabulatoren alle ANZAHL Zeichen annehmen, statt 8\n"
"  -t, --tabs=LISTE    mit Kommata getrennte Liste von Tabulatorpositionen\n"
"                        verwenden\n"

#: src/unexpand.c:463
msgid "`-LIST' option is obsolete; use `--first-only -t LIST'"
msgstr ""
"die Option »-LIST« ist überholt; bitte verwenden Sie »--first-only -t LIST«"

#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Aufruf: %s [OPTION]... [EINGABE [AUSGABE]]\n"

#: src/uniq.c:138
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
msgstr ""
"Alle hintereinanderstehenden identischen Zeilen von EINGABE (oder\n"
"Standardeingabe) bis auf eine löschen, und auf AUSGABE (oder "
"Standardausgabe)\n"
"schreiben.\n"
"\n"

#: src/uniq.c:146
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           den Zeilen die Anzahl des Vorkommens voranstellen\n"
"  -d, --repeated        nur die doppelten Zeilen ausgeben\n"

#: src/uniq.c:150
msgid ""
"  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -D, --all-repeated[=TRENN-METHODE]   alle doppelten Zeilen ausgeben\n"
"                        TRENN-METHODE={none(Vorgabe),prepend,separate)};\n"
"                        das Abtrennen geschieht durch Leerzeilen\n"
"  -f, --skip-fields=N   nicht die ersten N Felder vergleichen\n"
"  -i, --ignore-case     Abweichung in Groß/Kleinschreibung ignorieren\n"
"  -s, --skip-chars=N    nicht die ersten N Zeichen vergleichen\n"
"  -u, --unique          nur einmal vorkommende Zeilen ausgeben\n"

#: src/uniq.c:159
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=N   nicht mehr als N Zeichen pro Zeile vergleichen\n"

#: src/uniq.c:164
msgid ""
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"\n"
"Ein Feld ist eine Folge von Leerzeichen/Tabs gefolgt von anderen Zeichen.\n"
"Felder werden vor Zeichen übersprungen.\n"

#: src/uniq.c:377
#, c-format
msgid "error reading %s"
msgstr "Fehler beim Lesen von %s"

#: src/uniq.c:382
#, c-format
msgid "error writing %s"
msgstr "Fehler beim Schreiben von %s"

#: src/uniq.c:428 src/uniq.c:445
#, c-format
msgid "extra operand `%s'"
msgstr "zusätzlicher Operand »%s«"

#: src/uniq.c:468 src/uniq.c:493
msgid "invalid number of fields to skip"
msgstr "Ungültige Anzahl an zu überspringenden Feldern"

#: src/uniq.c:502
msgid "invalid number of bytes to skip"
msgstr "Ungültige Anzahl an zu überspringenden Bytes"

#: src/uniq.c:511
msgid "invalid number of bytes to compare"
msgstr "Ungültige Anzahl an zu vergleichenden Bytes"

#: src/uniq.c:525
#, c-format
msgid "`-%lu' option is obsolete; use `-f %lu'"
msgstr "die Option »-%lu« ist überholt; bitte verwenden Sie »-f %lu«"

# CHECKIT
# What's meant here?  -d vs. -D?
# 2001-08-11 16:40:37 CEST -ke-
#: src/uniq.c:533
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"Alle doppelten Zeilen auszugeben und die Zählung zu wiederholen, ist nicht\n"
"sinnvoll"

#: src/wc.c:78
msgid "Paul Rubin and David MacKenzie"
msgstr "Paul Rubin und David MacKenzie"

#: src/wc.c:132
msgid ""
"Print byte, word, and newline counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Byte-, Wort- und Zeilenanzahl für jede DATEI ausgeben und eine Zeile mit "
"der\n"
"Gesamtsumme, wenn mehr als eine DATEI angegeben wurde.  Ohne DATEI, oder "
"wenn\n"
"DATEI »-« ist, Standardeingabe lesen.\n"
"\n"
"  -c, --bytes            Byteanzahl ausgeben\n"
"  -m, --chars            Zeichenanzahl ausgeben\n"
"  -l, --lines            Zeilenanzahl ausgeben\n"

#: src/wc.c:140
msgid ""
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"  -L, --max-line-length  die Länge der längsten Zeile ausgeben\n"
"  -w, --words            Wortanzahl ausgeben\n"

#: src/wc.c:589
msgid "total"
msgstr "insgesamt"

#~ msgid ""
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "\n"
#~ "Anstelle von -t ZAHL oder -t LISTE darf auch -ZAHL oder -LISTE verwendet\n"
#~ "werden.\n"

#~ msgid "warning: `tail %s' is obsolete; use -n or -c instead"
#~ msgstr ""
#~ "Warnung: »tail %s« ist überholt; bitte verwenden Sie stattdessen -n oder -"
#~ "c"

#~ msgid "  +N                    same as -s N (obsolete; will be withdrawn)\n"
#~ msgstr ""
#~ "  +N                    dasselbe wie -s N (überholt; wird in Zukunft "
#~ "nicht mehr\n"
#~ "                          unterstützt werden)\n"

#~ msgid "warning: `uniq %s' is obsolete; use `uniq -s %s' instead"
#~ msgstr "Warnung: »uniq %s« ist überholt; bitte verwenden Sie »uniq -s %s«"

#~ msgid ""
#~ "Print CRC checksum and byte counts of each FILE.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ msgstr ""
#~ "CRC-Checksumme und Byteanzahl für jede DATEI ausgeben.\n"
#~ "\n"
#~ "  --help      diese Hilfe anzeigen und das Programm beenden\n"
#~ "  --version   Versionsinformation anzeigen und das Programm beenden\n"

#~ msgid ""
#~ "Convert tabs in each FILE to spaces, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -i, --initial       do not convert TABs after non whitespace\n"
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
#~ msgstr ""
#~ "Tabulatoren in jeder DATEI in Leerzeichen wandeln, auf Standardausgabe\n"
#~ "schreiben.  Wurde keine DATEI angegeben, oder ist DATEI »-«, die\n"
#~ "Standardeingabe lesen.\n"
#~ "\n"
#~ "Erforderliche Argumente für lange Optionen sind für kurze auch "
#~ "notwendig.\n"
#~ "  -i, --initial       Tabulatoren nicht nach Nicht-Freiraumzeichen (non\n"
#~ "                        whitespace) wandeln\n"
#~ "  -t, --tabs=ZAHL     Tabulator alle ZAHL Zeichen annehmen, nicht 8\n"

#~ msgid ""
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=LISTE    durch Komma getrennte LISTE von "
#~ "Tabulatorpositionen\n"
#~ "                        annehmen\n"
#~ "      --help          diese Hilfe anzeigen und das Programm beenden\n"
#~ "      --version       Versionsinformation anzeigen und das Programm "
#~ "beenden\n"
#~ "\n"
#~ "Anstelle von -t ZAHL oder -t LISTE darf auch -ZAHL oder -LISTE verwendet "
#~ "werden.\n"

#~ msgid ""
#~ "Wrap input lines in each FILE (standard input by default), writing to\n"
#~ "standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --bytes         count bytes rather than columns\n"
#~ "  -s, --spaces        break at spaces\n"
#~ "  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Eingabezeilen jeder DATEI umbrechen (Vorgabe: Standardeingabe),\n"
#~ "das Ergebnis auf Standardausgabe ausgeben.\n"
#~ "\n"
#~ "  -b, --bytes         Bytes anstatt Spalten zählen\n"
#~ "  -s, --spaces        Umbruch bei Leerzeichen\n"
#~ "  -w, --width=BREITE  BREITE Spalten anstatt 80 benutzen\n"
#~ "      --help          diese Hilfe anzeigen und das Programm beenden\n"
#~ "      --version       Versionsinformation anzeigen und das Programm "
#~ "beenden\n"

#~ msgid ""
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ msgstr ""
#~ "  -v, --first-page=ANZAHL         erste Zeilennummer auf jeder logischen "
#~ "Seite\n"
#~ "  -w, --number-width=ANZAHL       ANZAHL Spalten für Zeilennummern "
#~ "benutzen\n"
#~ "      --help                      diese Hilfe anzeigen und das Programm "
#~ "beenden\n"
#~ "      --version                   Versionsinformation anzeigen und "
#~ "beenden\n"
#~ "\n"
#~ "Standardeinstellung ist -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC sind\n"
#~ "zwei Begrenzungszeichen, um logische Seiten zu trennen, ein fehlendes "
#~ "zweites\n"
#~ "Zeichen impliziert »:«.  Geben Sie \\\\ für \\ ein.  STIL ist einer aus:\n"

#~ msgid ""
#~ "Write lines consisting of the sequentially corresponding lines from\n"
#~ "each FILE, separated by TABs, to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
#~ "  -s, --serial            paste one file at a time instead of in "
#~ "parallel\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Zeilen auf Standardausgabe ausgeben, die aus sequenziell sich "
#~ "entsprechenden\n"
#~ "Zeilen jeder DATEI bestehen, getrennt durch Tabulatoren.  Ohne DATEI oder "
#~ "wenn\n"
#~ "DATEI »-« ist, Standardeingabe lesen.\n"
#~ "\n"
#~ "Erforderliche Argumente für lange Optionen sind für kurze auch "
#~ "notwendig.\n"
#~ "  -d, --delimiters=LISTE  Zeichen aus LISTE anstelle von Tabulatoren "
#~ "benutzen\n"
#~ "  -s, --serial            Dateien nacheinander ausgeben anstelle "
#~ "parallel\n"
#~ "      --help              diese Hilfe anzeigen und das Programm beenden\n"
#~ "      --version           Versionsinformation anzeigen und das Programm "
#~ "beenden\n"
#~ "\n"

#~ msgid ""
#~ "  -v, --verbose            always output headers giving file names\n"
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "  -v, --verbose            immer Dateinamen ausgeben\n"
#~ "      --help               diese Hilfe anzeigen und das Programm beenden\n"
#~ "      --version            Versionsinformation anzeigen und das Programm "
#~ "beenden\n"
#~ "\n"

#~ msgid ""
#~ "Convert spaces in each FILE to tabs, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -a, --all           convert all whitespace, instead of initial "
#~ "whitespace\n"
#~ msgstr ""
#~ "Alle Leerzeichen in jeder DATEI in Tabulatoren wandeln, auf "
#~ "Standardausgabe\n"
#~ "schreiben.  Ohne DATEI, oder wenn DATEI »-« ist, Standardeingabe lesen.\n"
#~ "\n"
#~ "Erforderliche Argumente für lange Optionen sind für kurze auch "
#~ "notwendig.\n"
#~ "  -a, --all           alle Leerzeichen wandeln, statt nur der "
#~ "führendenen\n"

#~ msgid ""
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=ANZAHL   Tabulatoren alle ANZAHL Zeichen annehmen, statt 8\n"
#~ "  -t, --tabs=LISTE    mit Kommata getrennte Liste von "
#~ "Tabulatorpositionen\n"
#~ "                        verwenden\n"
#~ "      --help          diese Hilfe anzeigen und das Programm beenden\n"
#~ "      --version       Versionsinformation anzeigen und das Programm "
#~ "beenden\n"
#~ "\n"
#~ "Statt -t ANZAHL oder -t LISTE darf auch -ANZAHL oder -LISTE verwendet "
#~ "werden.\n"

#~ msgid ""
#~ "when using the old-style +POS and -POS key specifiers,\n"
#~ "the +POS specifier must come first"
#~ msgstr ""
#~ "wenn +POS und -POS Schlüsselspezifikationen benutzt werden,\n"
#~ "muss +POS zuerst kommen"

#~ msgid ""
#~ "the starting field number argument to the `-k' option must be positive"
#~ msgstr "Das Startfeld der »-k« Option muss positiv sein"

#~ msgid "starting field spec has `.' but lacks following character offset"
#~ msgstr ""
#~ "Die Startfeldangabe hat einen ».« jedoch keinen folgenden Zeichenoffset"

#~ msgid "field specification has `,' but lacks following field spec"
#~ msgstr "Feldspezifikation hat »,« aber keine folgende Feldspezifikation"

#~ msgid "ending field number argument to the `-k' option must be positive"
#~ msgstr "Endfeld der Option »-k« muss positiv sein"

#~ msgid "ending field spec has `.' but lacks following character offset"
#~ msgstr "Endfeldangabe hat ».« aber keinen folgenden Zeichenoffset"

#~ msgid ""
#~ "specified number of bytes `%s' is larger than the maximum\n"
#~ "representable value of type `long'"
#~ msgstr ""
#~ "Angebene Anzahl Bytes »%s« ist größer als der maximale darstellbare\n"
#~ "Wert des Typs »long«"
