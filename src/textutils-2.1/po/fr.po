# Messages français pour GNU concernant textutils.
# Copyright © 1996 Free Software Foundation, Inc.
# Michel Robitaille <robitail@IRO.UMontreal.CA>, depuis/since 1996.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU textutils 2.0.22\n"
"POT-Creation-Date: 2002-07-29 10:41+0200\n"
"PO-Revision-Date: 2002-07-22 08:00-0500\n"
"Last-Translator: Michel Robitaille <robitail@IRO.UMontreal.CA>\n"
"Language-Team: French <traduc@traduc.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: lib/argmatch.c:161
#, c-format
msgid "invalid argument %s for %s"
msgstr "argument %s invalide pour %s"

#: lib/argmatch.c:162
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argument %s ambigu pour %s"

#: lib/argmatch.c:181
msgid "Valid arguments are:"
msgstr "Arguments valides sont:"

#: lib/c-stack.c:368
msgid "program error"
msgstr "erreur du programme"

#: lib/c-stack.c:369
msgid "stack overflow"
msgstr "débordement de la pile"

#: lib/closeout.c:107 src/cat.c:186 src/cat.c:267 src/cat.c:320
#: src/cksum.c:267 src/head.c:152 src/head.c:195 src/tail.c:327
#: src/tail.c:1651 src/tr.c:1667 src/tr.c:1913 src/tr.c:2021
msgid "write error"
msgstr "Erreur d'écriture."

#: lib/error.c:129 lib/error.c:157
msgid "Unknown system error"
msgstr "Erreur système inconnue"

#: lib/file-type.c:42
msgid "regular empty file"
msgstr "fichier régulier vide"

#: lib/file-type.c:42
msgid "regular file"
msgstr "fichier régulier"

#: lib/file-type.c:45
msgid "directory"
msgstr "répertoire"

#: lib/file-type.c:48
msgid "block special file"
msgstr "fichier spécial de bloc"

#: lib/file-type.c:51
msgid "character special file"
msgstr "fichier spécial de caractères"

#: lib/file-type.c:54
msgid "fifo"
msgstr "PEPS (FIFO)"

#: lib/file-type.c:57
msgid "symbolic link"
msgstr "lien symbolique"

#: lib/file-type.c:60
msgid "socket"
msgstr "socket"

#: lib/file-type.c:63
msgid "message queue"
msgstr "queue de messages"

#: lib/file-type.c:66
msgid "semaphore"
msgstr "sémaphore"

#: lib/file-type.c:69
msgid "shared memory object"
msgstr "objet de mémoire partagée"

#: lib/file-type.c:71
msgid "weird file"
msgstr "fichier bizarre"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: l'option « %s » est ambiguë\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: l'option « --%s » ne requiert pas un argument.\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: l'option « %c%s » ne requiert pas un argument.\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: l'option « %s » requiert un argument.\n"

#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: option non reconnue « --%s »\n"

#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: option non reconnue « %c%s »\n"

#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: option illégale --%c\n"

#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: option invalide --%c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: l'option requiert un argument --%c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: l'option « -W %s » est ambiguë\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: l'option « -W %s » ne requiert pas un argument.\n"

#: lib/human.c:365
msgid "block size"
msgstr "taille de bloc"

#: lib/makepath.c:176
#, c-format
msgid "cannot create directory %s"
msgstr "Ne peut créer le répertoire %s"

#: lib/makepath.c:182 lib/makepath.c:423
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s existe mais n'est pas un répertoire"

#: lib/makepath.c:319 lib/makepath.c:381 lib/makepath.c:442
#, c-format
msgid "cannot change owner and/or group of %s"
msgstr "ne peut modifier le propriétraire et/ou le groupe de %s"

#: lib/makepath.c:341
#, c-format
msgid "cannot chdir to directory %s"
msgstr "ne peut aller vers le répertoire %s"

#: lib/makepath.c:395 lib/makepath.c:448
#, c-format
msgid "cannot change permissions of %s"
msgstr "Ne peut changer les permissions de %s"

#: lib/obstack.c:494 lib/obstack.c:497 lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "Mémoire épuisée"

#: lib/quotearg.c:270
msgid "`"
msgstr "`"

#: lib/quotearg.c:271
msgid "'"
msgstr "'"

#: lib/rpmatch.c:78
msgid "^[yY]"
msgstr "^[yY]"

#: lib/rpmatch.c:81
msgid "^[nN]"
msgstr "^[nN]"

#: lib/unicodeio.c:159
msgid "iconv function not usable"
msgstr "fonction iconv n'est pas utilisable"

#: lib/unicodeio.c:161
msgid "iconv function not available"
msgstr "fonction iconv n'est pas disponible"

#: lib/unicodeio.c:168
msgid "character out of range"
msgstr "caractère hors plage"

#: lib/unicodeio.c:231
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "ne peut convertir U+%04X à un jeu local de caractères"

#: lib/unicodeio.c:233
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "ne peut convertir U+%04X au jeu local de caractères: %s"

#: lib/userspec.c:178
msgid "invalid user"
msgstr "usager invalide"

#: lib/userspec.c:179
msgid "invalid group"
msgstr "groupe invalide"

#: lib/userspec.c:181
msgid "cannot get the login group of a numeric UID"
msgstr ""
"ne peut obtenir le group d'établissement de session à partir du UID numérique"

#: lib/userspec.c:183
msgid "cannot omit both user and group"
msgstr "ne peut omettre ensemble l'usager et le groupe"

#: lib/version-etc.c:61
#, c-format
msgid "Written by %s.\n"
msgstr "Écrit par %s.\n"

#: lib/version-etc.c:67
msgid ""
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"Ce logiciel est libre; voir les sources pour les conditions de\n"
"reproduction. AUCUNE garantie n'est donnée; tant pour des raisons\n"
"COMMERCIALES que pour RÉPONDRE À UN BESOIN PARTICULIER.\n"

#: lib/xmemcoll.c:61
msgid "string comparison failed"
msgstr "échec de comparaison de chaîne"

#: lib/xmemcoll.c:62
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Définir LC_ALL=« C » pour contourner le problème."

#: lib/xmemcoll.c:64
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Les chaînes comparées étaient %s et %s."

#: src/cat.c:42 src/split.c:42
msgid "Torbjorn Granlund and Richard M. Stallman"
msgstr "Torbjorn Granlund et Richard M. Stallman"

#: src/cat.c:88 src/cksum.c:276 src/comm.c:69 src/csplit.c:1490 src/cut.c:163
#: src/expand.c:106 src/fmt.c:267 src/fold.c:63 src/head.c:84 src/join.c:140
#: src/md5sum.c:121 src/nl.c:172 src/od.c:287 src/paste.c:399 src/pr.c:2752
#: src/ptx.c:1855 src/sort.c:275 src/split.c:91 src/sum.c:56 src/tac.c:123
#: src/tail.c:234 src/tr.c:323 src/tsort.c:93 src/unexpand.c:371
#: src/uniq.c:130 src/wc.c:124
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pour en savoir davantage, faites: « %s --help ».\n"

#: src/cat.c:92
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Usage: %s [OPTION] [FICHIER]...\n"

#: src/cat.c:96
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
msgstr ""
"Concaténer le(s) FICHIER(s), ou de l'ENTRÉE standard, vers la sortie "
"standard.\n"
"\n"
"  -A, --show-all           équivalent à -vET\n"
"  -b, --number-nonblank    numéroter que les lignes non vides\n"
"  -e                       équivalent à -vE\n"
"  -E, --show-ends          afficher $ à la fin de chaque ligne\n"
"  -n, --number             numéroter toutes les lignes\n"
"  -s, --squeeze-blank      afficher jamais plus qu'une seule ligne vide\n"

#: src/cat.c:106
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       équivalent à -vT\n"
"  -T, --show-tabs          afficher les caractères TAB comme ^I\n"
"  -u                       (ignoré)\n"
"  -v, --show-nonprinting   utiliser la notation ^ et M- ,\n"
"                            excepté pour LFD et TAB\n"

#: src/cat.c:114 src/sum.c:72
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/cat.c:119
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             écrire en binaire sur la console.\n"
"\n"

#: src/cat.c:124 src/cksum.c:291 src/comm.c:86 src/csplit.c:1532 src/cut.c:208
#: src/expand.c:131 src/fmt.c:297 src/fold.c:86 src/head.c:115 src/join.c:180
#: src/md5sum.c:157 src/nl.c:227 src/od.c:374 src/paste.c:423 src/pr.c:2864
#: src/sort.c:346 src/split.c:123 src/sum.c:76 src/tac.c:146 src/tail.c:304
#: src/tr.c:396 src/tsort.c:105 src/unexpand.c:394 src/uniq.c:169 src/wc.c:146
#, c-format
msgid ""
"\n"
"Report bugs to <%s>.\n"
msgstr ""
"\n"
"Rapporter toutes anomalies à <%s>.\n"

#: src/cat.c:308
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "Ne peut exécuter « ioctl » sur « %s »"

#: src/cat.c:647 src/od.c:1014
msgid "standard output"
msgstr "sortie standard"

#: src/cat.c:778
#, c-format
msgid "%s: input file is output file"
msgstr "%s: le fichier à l'entrée est le même qu'à la sortie."

#: src/cksum.c:234
#, c-format
msgid "%s: file too long"
msgstr "%s: fichier trop long"

#: src/cksum.c:280
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Usage: %s [FICHIER]...\n"
"  or:  %s [OPTION]\n"

#: src/cksum.c:285
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
"FICHIER.\n"
"\n"

#: src/comm.c:35 src/uniq.c:38
msgid "Richard Stallman and David MacKenzie"
msgstr "Richard Stallman et David MacKenzie"

#: src/comm.c:73
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "Usage: %s [OPTION]... FICHIER_GAUCHE  FICHIER_DROIT\n"

#: src/comm.c:77
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines that appear in both files\n"
msgstr ""
"Comparer les fichiers triés GAUCHE et DROITE ligne par ligne.\n"
"\n"
"  -1              supprimer les lignes uniques du fichier de gauche\n"
"  -2              supprimer les lignes uniques du fichier de droite\n"
"  -3              supprimer les lignes uniques des 2 fichiers\n"

#: src/csplit.c:41
msgid "Stuart Kemp and David MacKenzie"
msgstr "Stuart Kemp et David MacKenzie"

#: src/csplit.c:290 src/csplit.c:1479 src/tac-pipe.c:57 src/tr.c:1609
#: src/tr.c:1712 src/tr.c:1755
msgid "read error"
msgstr "Erreur de lecture."

#: src/csplit.c:584
msgid "input disappeared"
msgstr "L'entrée est disparue."

#: src/csplit.c:706 src/csplit.c:717
#, c-format
msgid "%s: line number out of range"
msgstr "%s: numéro de ligne hors plage."

#: src/csplit.c:744
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: « %s »: numéro de ligne hors plage."

#: src/csplit.c:747 src/csplit.c:793
#, c-format
msgid " on repetition %d\n"
msgstr " par répétition %d\n"

#: src/csplit.c:789
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: « %s »: concordance non trouvée."

#: src/csplit.c:850 src/csplit.c:890 src/tac.c:262
msgid "error in regular expression search"
msgstr "Erreur dans l'expression régulière recherchée."

#: src/csplit.c:993
#, c-format
msgid "write error for `%s'"
msgstr "Erreur d'écriture sur « %s »"

#: src/csplit.c:1065
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: « + » ou « - » attendu après le délimiteur."

#: src/csplit.c:1069
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: entier attendu après « %c »"

#: src/csplit.c:1089
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: « } » est requis pour un compteur de répétition."

#: src/csplit.c:1099
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: entier requis entre « { » et « } »"

#: src/csplit.c:1126
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: délimiteur de fermeture « %c » manquant."

#: src/csplit.c:1142
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: expression régulière invalide: %s"

#: src/csplit.c:1175
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: patron invalide."

#: src/csplit.c:1178
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: le numéro de ligne doit être plus grand que zéro."

#: src/csplit.c:1184
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "le numéro de ligne « %s » est plus petit que le numéro précédent %s"

#: src/csplit.c:1190
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "AVERTISSEMENT: le numéro de ligne « %s » est le même que le précédent."

#: src/csplit.c:1312
msgid "missing conversion specifier in suffix"
msgstr "Symbole de conversion manquant dans le suffixe."

#: src/csplit.c:1318
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "Le symbole de conversion %c est invalide dans le suffixe."

#: src/csplit.c:1321
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "Le symbole de conversion \\%.3o est invalide dans le suffixe."

#: src/csplit.c:1353
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "La spéfication de conversion %% est manquante dans le suffixe."

#: src/csplit.c:1356
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "Trop de spécifications  %% de conversion dans le suffixe."

#: src/csplit.c:1439
#, c-format
msgid "%s: invalid number"
msgstr "%s: nombre invalide."

#: src/csplit.c:1462
msgid "too few arguments"
msgstr "Trop peu de arguments."

#: src/csplit.c:1494
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Usage: %s [OPTION]... FICHIER  PATRON...\n"

#: src/csplit.c:1498
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
msgstr ""
"Produire des morceaux de FICHIER séparées par PATRON(s) vers les fichiers\n"
"« xx01 », « xx02 », ... et le nombre d'octets de chaque morceau sur la "
"sortie standard.\n"
"\n"

#: src/csplit.c:1503 src/cut.c:175 src/expand.c:119 src/fmt.c:277
#: src/fold.c:76 src/head.c:98 src/nl.c:185 src/paste.c:413 src/pr.c:2765
#: src/ptx.c:1867 src/sort.c:289 src/split.c:104 src/tac.c:136 src/tail.c:248
#: src/unexpand.c:384 src/uniq.c:143
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Les arguments obligatoires pour les options de formes longues le sont aussi\n"
"pour les options de formes courtes.\n"

#: src/csplit.c:1506
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=FORMAT utiliser sprintf FORMAT au lieu de %d\n"
"  -f, --prefix=PRÉFIXE       utiliser le PRÉFIXE au lieu de « xx »\n"
"  -k, --keep-files           ne pas détruire les fichiers \n"
"                              lorsqu'il y a erreur\n"

#: src/csplit.c:1511
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=NOMBRE        utiliser NOMBRE de chiffres au lieu de 2\n"
"  -s, --quiet, --silent      ne pas afficher la taille des fichiers\n"
"                             de sortie\n"
"  -z, --elide-empty-files    détruire les fichiers de sortie vides\n"

#: src/csplit.c:1518
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"Lire de l'entrée standard si le FICHIER est -.  Chaque PATRON peut être:\n"

#: src/csplit.c:1522
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"\n"
"  ENTIER             copier jusqu'à mais sans inclure le nombre spécifiée\n"
"                     de lignes\n"
"  /REGEXP/[SAUT]     copier jusqu'à la détection d'une ligne identique\n"
"                     mais sans l'inclure\n"
"  %%REGEXP%%[SAUT]     escamoter jusqu'à, mais sans inclure une\n"
"                     ligne identique\n"
"  {ENTIER}           répéter le patron précédent un nombre de fois\n"
"  {*}                répéter le patron précédent le plus souvent possible\n"
"\n"
"Une ligne de SAUT a besoin d'un « + » ou « - » suivi d'un entier positif.\n"

#: src/cut.c:39
msgid "David Ihnat, David MacKenzie, and Jim Meyering"
msgstr "David Ihnat, David MacKenzie et Jim Meyering"

#: src/cut.c:167 src/expand.c:110 src/fold.c:67 src/head.c:88 src/nl.c:176
#: src/paste.c:403 src/pr.c:2756 src/sort.c:279 src/sum.c:60 src/tac.c:127
#: src/tail.c:238 src/unexpand.c:375 src/wc.c:128
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Usage: %s [OPTION]... [FICHIER]...\n"

#: src/cut.c:171
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
msgstr ""
"Afficher des parties de lignes de chaque FICHIER vers la sortie standard.\n"
"\n"

#: src/cut.c:178
msgid ""
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=LISTE       afficher seulement la LISTE des octets\n"
"  -c, --characters=LISTE  afficher seulement la LISTE des caractères\n"
"  -d, --delimiter=DÉLIM   utiliser le DÉLIMiteur au lieu d'une tabulation\n"
"                          comme délimiteur de champs\n"

#: src/cut.c:183
msgid ""
"  -f, --fields=LIST       output only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=LISTE      afficher seulement la LISTE des champs; afficher "
"aussi\n"
"                          les lignes qui ne contiennent pas de caractère "
"délimiteur,\n"
"                          à moins que l'option -s soit spécifiée\n"
"  -n                      (ignoré)\n"

#: src/cut.c:189
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    ne pas afficher les lignes ne\n"
"                          contenant pas de délimiteurs\n"
"      --output-delimiter=CHAÎNE\n"
"                          utiliser la CHAÎNE comme délimiteur de sortie\n"
"                          par défaut le délimiteur de l'entrée est utilisée\n"

#: src/cut.c:196
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Utiliser une seule des options -b, -c ou -f.  Chaque LISTE se compose d'une\n"
"intervalle, ou de plusieurs séparées par des virgules.  Chaque intervalle\n"
"se compose de:\n"
"\n"
"  N     Nième octet, caractère ou champ, compté à partir de 1\n"
"  N-    du Nième octet, caractère ou champ, jusqu'à la fin de la ligne\n"
"  N-M   du Nième au Mième (inclus) octet, caractère ou champ\n"
"  -M    du premier au Mième (inclus) octet, caractère ou champ\n"
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/cut.c:263 src/cut.c:294 src/cut.c:354
msgid "invalid byte or field list"
msgstr "Octet ou champ de liste invalide."

#: src/cut.c:624 src/cut.c:633
msgid "only one type of list may be specified"
msgstr "Un seul type de liste peut être spécifié."

#: src/cut.c:627
msgid "missing list of positions"
msgstr "Liste des positions manquante."

#: src/cut.c:636
msgid "missing list of fields"
msgstr "Liste des champs manquante."

#: src/cut.c:643
msgid "the delimiter must be a single character"
msgstr "Le délimiteur doit être un caractère simple."

#: src/cut.c:673
msgid "you must specify a list of bytes, characters, or fields"
msgstr "Une liste d'octets, de caractères, ou de champs doit être spécifiée."

#: src/cut.c:676
msgid "a delimiter may be specified only when operating on fields"
msgstr "Un délimiteur peut être spécifié lorsqu'opérant sur des champs."

#: src/cut.c:679
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"La suppression des lignes non-délimitées est permise\n"
"\tseulement lorsqu'opérant sur des champs."

#: src/expand.c:114
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les tabulations de chaque FICHIER par des blancs d'espacement,\n"
"en écrivant sur la sortie standard.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/expand.c:122
msgid ""
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       ne pas convertir les tabulations après des non blancs\n"
"  -t, --tabs=N        utiliser N caractères de tabulations, et non 8\n"

#: src/expand.c:126
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
"                       de tabulation\n"
"                       séparées par des virgules\n"

#: src/expand.c:173 src/unexpand.c:153
msgid "tab size contains an invalid character"
msgstr "La taille de la tabulation contient un caractère invalide."

#: src/expand.c:191 src/unexpand.c:171
msgid "tab size cannot be 0"
msgstr "La taille de la tabulation ne peut être 0."

#: src/expand.c:193 src/unexpand.c:173
msgid "tab sizes must be ascending"
msgstr "Les tailles de tabulation doivent être croissantes."

#: src/expand.c:386
msgid "`-LIST' option is obsolete; use `-t LIST'"
msgstr "option « -LIST » est obsolète; utiliser « -t LIST »"

#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "Usage: %s [-CHIFFRES] [OPTION]... [FICHIER]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
msgstr ""
"Reformater chaque paragraphe de FICHIER(s), en écrivant sur la\n"
"sortie standard.\n"
"Si aucun FICHIER ou si FICHIER est « - », lire de l'entrée standard.\n"
"\n"

#: src/fmt.c:280
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        préserver l'indentation des 2 premières lignes\n"
"  -p, --prefix=CHAÎNE       combiner les lignes ayant CHAÎNE comme préfixe\n"
"  -s, --split-only          briser les longues lignes mais sans les remplir\n"

#: src/fmt.c:286
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
msgstr ""
"  -t, --tagged-paragraph    indenter différemment la 1ère ligne de la 2ème\n"
"  -u, --uniform-spacing     séparer d'un blanc les mots,\n"
"                            puis de deux après chaque phrase\n"
"  -w, --width=N             utiliser une largeur de N colonnes pour une\n"
"                            pour une ligne (par défaut 75 colonnes)\n"

#: src/fmt.c:293
msgid ""
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"\n"
"Pour -wNOMBRE, l'option « w » peut être omise.\n"

#: src/fmt.c:345
#, c-format
msgid "invalid width option: `%s'"
msgstr "L'option largeur est invalide: « %s »."

#: src/fmt.c:385
#, c-format
msgid "invalid width: `%s'"
msgstr "Largeur invalide: « %s »"

#: src/fold.c:71
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
msgstr ""
"Limiter la longueur de chaque ligne de chaque FICHIER (entrée standard par\n"
"défaut) et forcer le bouclage en écrivant sur la sortie standard.\n"
"\n"

#: src/fold.c:79
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         compter les octets au lieu des colonnes\n"
"  -s, --spaces        briser la ligne sur des blancs\n"
"  -w, --width=N       utiliser N colonnes au lieu de 80\n"

#: src/fold.c:267
#, c-format
msgid "`%s' option is obsolete; use `%s'"
msgstr "option « %s » est obsolète; utiliser « %s »"

#: src/fold.c:295
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "Le nombre de colonnes « %s » est invalide."

#: src/head.c:92
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les 10 premières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un fichier FICHIER, précéder chacun d'une en-tête donnant le "
"nom.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/head.c:101
msgid ""
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
msgstr ""
"  -c, --bytes=N            afficher les N premiers octets\n"
"  -n, --lines=N            afficher les N premières lignes au lieu de 10\n"

#: src/head.c:105
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    ne pas afficher les en-têtes avec les\n"
"                            noms de fichiers\n"
"  -v, --verbose            toujours afficher les en-têtes avec les\n"
"                            noms de fichiers\n"

#: src/head.c:111 src/split.c:119
msgid ""
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"\n"
"La TAILLE peut être suivie d'un suffixe multiplicateur:\n"
"b pour 512, k pour 1K, m pour 1 Meg.\n"

#: src/head.c:189
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "ne peut repositionner le pointeur de fichier pour %s"

#: src/head.c:220 src/md5sum.c:334 src/md5sum.c:675 src/od.c:960 src/od.c:2000
#: src/pr.c:1166 src/pr.c:1373 src/pr.c:1495 src/tac.c:484 src/tac.c:490
#: src/tr.c:2028 src/tsort.c:585
msgid "standard input"
msgstr "entrée standard"

#: src/head.c:255 src/tail.c:1378
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s est tellement grande qu'elle n'est pas représentable."

#: src/head.c:256 src/tail.c:1380
msgid "number of lines"
msgstr "Nombre de lignes"

#: src/head.c:256 src/tail.c:1381
msgid "number of bytes"
msgstr "Nombre d'octets"

#: src/head.c:263 src/tail.c:1467
msgid "invalid number of lines"
msgstr "nombre invalide de lignes."

#: src/head.c:264 src/tail.c:1468
msgid "invalid number of bytes"
msgstr "nombre d'octets invalide."

#: src/head.c:340
#, c-format
msgid "unrecognized option `-%c'"
msgstr "L'option « -%c » n'est pas reconnue."

#: src/head.c:347
#, c-format
msgid "`-%s' option is obsolete; use `-%c %.*s%.*s%s'"
msgstr "option « -%s » est obsolète; utiliser « -%c %.*s%.*s%s »"

#: src/join.c:144
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Usage: %s [OPTION]... FICHIER1  FICHIER2\n"

#: src/join.c:148
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Pour chaque paire de lignes en entrée ayant un champ de fusion identique,\n"
"écrire une ligne sur la sortie standard.\n"
"Le champ de fusion est le premier, délimité par un blanc.\n"
"Si FICHIER1 ou FICHIER2 (pas les 2) est -, lire de l'entrée standard.\n"
"\n"
"  -a COTÉ           afficher les lignes non repérables venant du \n"
"                    fichier COTÉ\n"
"  -e VIDE           remplacer les champs d'entrée manquants par VIDE\n"

#: src/join.c:156
msgid ""
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case ignorer la casse des caractères lors de la\n"
"                    comparaison des champs\n"
"  -j CHAMP          option désuète équivalente à « -1 CHAMP -2 CHAMP »\n"
"  -j1 CHAMP         option désuète équivalente à « -1 CHAMP »\n"
"  -j2 CHAMP         option désuète équivalente à « -2 CHAMP »\n"
"  -o FORMAT         respecter le FORMAT lors de la construction\n"
"                    de sortie\n"
"  -t CAR            utiliser CAR comme délimiteur de champs à l'entrée\n"
"                    et à la sortie\n"

#: src/join.c:164
msgid ""
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
msgstr ""
"  -v COTÉ           comme -a COTÉ, mais supprimer les lignes\n"
"                    de sortie fusionnées\n"
"  -1 CHAMP          fusionner sur le champs CHAMP du fichier 1\n"
"  -2 CHAMP          fusionner sur le champs CHAMP du fichier 2\n"

#: src/join.c:171
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"\n"
"À moins que -t CAR ne soit fourni, les blancs de tête séparant\n"
"les champs sont ignorés sinon les champs sont séparés par CAR.\n"
"Chaque CHAMP est un champ compté numériquement à partir de 1.\n"
"FORMAT est une spécification contenant une ou plusieurs virgules ou blancs\n"
"chacune étant « COTÉ.CHAMP » ou « 0 ».  Par défaut FORMAT affiche des\n"
"champs fusionnés,\n"
"les champs restants de FICHIER1 ou FICHIER2 sont tous séparés par CAR.\n"

#: src/join.c:644
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "Le symbole de champ « %s » est invalide."

#: src/join.c:658 src/join.c:771 src/join.c:807
#, c-format
msgid "invalid field number: `%s'"
msgstr "Le numéro de champ « %s » est invalide."

#: src/join.c:671
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "Le numéro de fichier « %s » est invalide dans le champ spécifié."

#: src/join.c:791
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "Le numéro de champ « %s » est invalide pour le fichier 1."

#: src/join.c:800
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "Le numéro de champ « %s » est invalide pour le fichier 2."

#: src/join.c:832
msgid "too many non-option arguments"
msgstr "Trop de arguments sont des options non reconnues."

#: src/join.c:854
msgid "too few non-option arguments"
msgstr "Trop peu de arguments sont des options non reconnues."

#: src/join.c:865
msgid "both files cannot be standard input"
msgstr "Les deux fichiers ne peuvent pas être à l'entrée standard."

#: src/md5sum.c:38
msgid "Ulrich Drepper and Scott Miller"
msgstr "Ulrich Drepper et Scott Miller"

#: src/md5sum.c:125
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Usage: %s [OPTION] [FICHIER]...\n"
"  ou:  %s [OPTION] --check [FICHIER]\n"
"Afficher ou vérifier les sommes de contrôle %s (%d-bits).\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"

#: src/md5sum.c:134
#, c-format
msgid ""
"\n"
"  -b, --binary            read files in binary mode (default on DOS/"
"Windows)\n"
"  -c, --check             check %s sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
msgstr ""
"\n"
"  -b, --binary            lire les fichiers en mode binaire \n"
"                          (par défaut sous DOS/WIndows)\n"
"  -c, --check             vérifier les sommes %s par rapport à la liste\n"
"  -t, --text              lire les fichiers en mode texte (par défaut)\n"
"\n"

#: src/md5sum.c:142
msgid ""
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated checksum lines\n"
"\n"
msgstr ""
"Les deux options suivantes sont utiles seulement lors de la vérification\n"
"des sommes de contrôle:\n"
"      --status            ne rien afficher, sauf le constat\n"
"                          de fin d'exécution\n"
"  -w, --warn              avertir si les lignes de contrôle MD5\n"
"                          sont mal formatées\n"
"\n"

#: src/md5sum.c:150
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"\n"
"Les sommes sont calculées selon la description de %s.  Lors de la "
"vérification,\n"
"l'entrée devrait être formellement une sortie de ce programme.  Le mode par "
"défaut\n"
"est d'afficher la ligne avec la somme de contrôle, un caractère indiquant\n"
"le type (« * » pour binaire, « » pour texte) et un nom pour chaque FICHIER.\n"

#: src/md5sum.c:379
#, c-format
msgid "%s: %lu: improperly formatted %s checksum line"
msgstr "%s: %lu: ligne de somme de contrôle %s mal formatée."

#: src/md5sum.c:401
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: ÉCHEC d'ouverture ou de lecture.\n"

#: src/md5sum.c:425
msgid "FAILED"
msgstr "ÉCHEC"

#: src/md5sum.c:425
msgid "OK"
msgstr "OK"

#: src/md5sum.c:438
#, c-format
msgid "%s: read error"
msgstr "%s: erreur de lecture."

#: src/md5sum.c:451
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: aucune ligne de somme de contrôle %s repérée."

#: src/md5sum.c:464
#, c-format
msgid "WARNING: %d of %d listed %s could not be read"
msgstr "AVERTISSEMENT: %d des %d affichés %s n'a pu être lu."

#: src/md5sum.c:467
msgid "file"
msgstr "fichier"

#: src/md5sum.c:467
msgid "files"
msgstr "fichiers"

#: src/md5sum.c:473
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "AVERTISSEMENT: %d des %d sommes de contrôle %s ne concordent pas."

#: src/md5sum.c:476
msgid "checksum"
msgstr "checksum"

#: src/md5sum.c:476
msgid "checksums"
msgstr "checksums"

#: src/md5sum.c:558
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"Les options --binary et --text sont sans effet lors de la\n"
"la vérification des sommes de contrôle."

#: src/md5sum.c:566
msgid "the --string and --check options are mutually exclusive"
msgstr "les options --string et --check sont mutuellement exclusives"

#: src/md5sum.c:573
msgid "the --status option is meaningful only when verifying checksums"
msgstr ""
"L'option --status n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:580
msgid "the --warn option is meaningful only when verifying checksums"
msgstr ""
"L'option --warn n'a de sens que si la vérification des sommes\n"
"de contrôle est demandée."

#: src/md5sum.c:590
msgid "no files may be specified when using --string"
msgstr "Aucun fichier ne peut être spécifié lorsque --string est utilisée."

#: src/md5sum.c:612
msgid "only one argument may be specified when using --check"
msgstr "Un seul argument peut être spécifié lorsque --check est utilisée."

#: src/nl.c:39
msgid "Scott Bartram and David MacKenzie"
msgstr "Scott Bartram et David MacKenzie"

#: src/nl.c:180
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher chaque FICHIER sur la sortie standard, avec numéros de ligne.\n"
"Sans FICHIER, ou FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/nl.c:188
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=STYLE      utiliser STYLE pour numéroter les lignes\n"
"  -d, --section-delimiter=CC      utiliser CC pour séparer les pages\n"
"                                  logiques\n"
"  -f, --footer-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  de bas de page\n"

#: src/nl.c:193
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=STYLE    utiliser STYLE pour numéroter les lignes\n"
"                                  d'en-tête\n"
"  -i, --page-increment=N          incrémenter de N de lignes à chaque ligne\n"
"  -l, --join-blank-lines=N        regrouper N de lignes vides\n"
"                                  en une seule ligne\n"
"  -n, --number-format=FORMAT      insérer un numéro de ligne selon FORMAT\n"
"  -p, --no-renumber               ne pas réinitialiser le nombre de lignes\n"
"                                  aux pages logiques\n"
"  -s, --number-separator=CHAÎNE   ajouter la CHAÎNE après (si possible)\n"
"                                  le numéro de ligne\n"

#: src/nl.c:201
msgid ""
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
"                                   sur chaque page logique\n"
"  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
"                                   numéroter les lignes\n"

#: src/nl.c:207
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
"CC se compose de deux caractères délimiteurs pour séparer les pages "
"logiques\n"
"un deuxième caractère manquant implique que:\n"
"taper \\\\ pour  \\.  STYLE est une des options parmi:\n"
"\n"

#: src/nl.c:213
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         numéroter toutes les lignes\n"
"  t         numéroter seulement les lignes non vides\n"
"  n         numéroter n lignes\n"
"  pEXPREG   numéroter seulement les lignes ayant une concordance à EXPREG\n"
"\n"
"FORMAT doit être choisi parmi:\n"
"\n"
"  ln   justifié à gauche, sans zéro de préfixe\n"
"  rn   justifié à droite, sans zéro de préfixe\n"
"  rz   justifié à droite, avec zéros de préfixe\n"
"\n"

#: src/nl.c:500
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "Le numéro de ligne de départ « %s » est invalide."

#: src/nl.c:510
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "L'incrément du nombre de ligne « %s » est invalide."

#: src/nl.c:523
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "Le nombre de lignes blanches « %s » est invalide."

#: src/nl.c:537
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "La largeur du champ de la numérotation de ligne « %s » est invalide."

#: src/od.c:291
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"Usage: %s [OPTION]... [FICHIER]...\n"
"  ou:  %s --traditional [FICHIER] [[+]SAUT [[+]ÉTIQUETTE]]\n"

#: src/od.c:296
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"Afficher le contenu du FICHIER selon une représentation non ambiguë\n"
"par un affichage des octets en octal par défaut sur la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/od.c:303
msgid "All arguments to long options are mandatory for short options.\n"
msgstr ""
"Tous les arguments obligatoires pour les options de formes longues\n"
"le sont aussi pour les options de formes courtes.\n"

#: src/od.c:306
msgid ""
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=BASE    afficher les octets selon un adressage\n"
"                              relatif dans la BASE sélectionnée\n"
"  -j, --skip-bytes=N          escamoter les N premiers octets de chaque\n"
"                              fichier\n"

#: src/od.c:310
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in traditional form\n"
msgstr ""
"  -N, --read-bytes=N          limiter la vidange à N octets lus à l'entrée\n"
"  -s, --strings[=N]           afficher la chaîne d'au moins N caractères\n"
"                              graphiques\n"
"  -t, --format=TYPE           sélectionner les formats de sortie\n"
"  -v, --output-duplicates     ne pas utiliser * pour marquer la\n"
"                              suppression de ligne\n"
"  -w, --width[=N]             afficher N octets par ligne de sortie\n"
"      --traditional           accepter les arguments selon la forme "
"traditionnelle\n"

#: src/od.c:320
msgid ""
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
msgstr ""
"\n"
"Les spécifications de format traditionnels peuvent être entremêlées;\n"
"ils sont alors cumulées:\n"
"  -a   identique à -t a,    sélectionner les caractères nommés\n"
"  -b   identique à -t oC,   sélectionner les octets en octal\n"
"  -c   identique à -t c,    sélectionner les caractères ASCII ou\n"
"                            les barres obliques inverses\n"
"  -d   identique à -t u2,   sélectionner les entiers courts non signés\n"

#: src/od.c:328
msgid ""
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"  -f   identique à -t fF,   identifier en nombre flottant\n"
"  -h   identique à -t x2,   identifier en hexadécimal court\n"
"  -i   identique à -t d2,   identifier en décimal court\n"
"  -l   identique à -t d4,   identifier en décimal long\n"
"  -o   identique à -t o2,   identifier en octal court\n"
"  -x   identique à -t x2,   identifier en hexadécimal court\n"

#: src/od.c:336
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes may be . for octal and b for multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"Pour la syntaxe plus ancienne (deuxième format d'appel), SAUT\n"
"signifie -j SAUT.  ÉTIQUETTE est une pseudo adresse du premier octet "
"imprimé\n"
"incrémentée lorsque la vidange s'effectue.  Pour le SAUT et l'ÉTIQUETTE, un\n"
"préfixe 0x ou 0X indique un format hexadécimal,  les suffixes peuvent\n"
"être . pour l'octal et b pour un multiple de 512 octets.\n"
"\n"
"Le TYPE est composé d'une ou plusieurs spécifications suivantes:\n"
"\n"
"  a          caractère nommé\n"
"  c          caractère ASCII ou barre oblique inverse\n"

#: src/od.c:348
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[N]       décimal signé, N octets par entier\n"
"  f[N]       point flottant, N octets par entier\n"
"  o[N]       octal, N octets par entier\n"
"  u[N]       décimal non signé N octets par entier\n"
"  x[N]       hexadécimal, N octets par entier\n"

#: src/od.c:355
msgid ""
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"N est un nombre.  Le TYPE est soit d, o, u ou x, N peut être aussi C pour\n"
"sizeof(char), S pour sizeof(short), I pour sizeof(int) ou L pour\n"
"sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float),\n"
"D pour sizeof(double) ou L pour sizeof(long double).\n"

#: src/od.c:362
msgid ""
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  "
msgstr ""
"\n"
"BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour aucun.\n"
"OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un\n"
"multiple de 512 avec le suffixe b, de 1024 avec k et de 1048576 avec m.\n"
"L'ajout du suffixe « z » à chacun de ces types affiche des caractères\n"
"imprimables à la fin de chaque ligne sur la sortie."

#: src/od.c:370
msgid ""
"--string without a number implies 3.  --width without a number\n"
"implies 32.  By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
"--string sans être suivi d'un nombre implique 3. --width sans \n"
"nombre implique 32. Par défaut, od utilise -A o -t d2 -w 16.\n"

#: src/od.c:726 src/od.c:845
#, c-format
msgid "invalid type string `%s'"
msgstr "Le type de chaîne « %s » est invalide."

#: src/od.c:736
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"le type de chaîne « %s » est invalide;\n"
"ce système ne permet pas le type entier %lu-byte"

#: src/od.c:855
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"le type de chaîne « %s » est invalide;\n"
"ce système ne permet pas le type en point flottant %lu-byte"

#: src/od.c:918
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "Le caractère « %c » est invalide dans le type de chaîne « %s »."

#: src/od.c:1145
msgid "cannot skip past end of combined input"
msgstr "Ne peut aller au delà de la fin combinée des fichiers."

#: src/od.c:1398
msgid "old-style offset"
msgstr "Vieux style de décalage."

#: src/od.c:1706
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""
"La base numérique de sortie est invalide « %c »:\n"
"une seule des options doit être sélectionnée parmi les choix [doxn]."

#: src/od.c:1716
msgid "skip argument"
msgstr "Argument escamoté."

#: src/od.c:1724
msgid "limit argument"
msgstr "Argument limite."

#: src/od.c:1734
msgid "minimum string length"
msgstr "Longueur minimum de la chaîne."

#: src/od.c:1739 src/od.c:1805
#, c-format
msgid "%s is too large"
msgstr "%s est trop grand"

#: src/od.c:1803
msgid "width specification"
msgstr "Spécification de la largeur."

#: src/od.c:1825
msgid "no type may be specified when dumping strings"
msgstr "Aucun type ne peut être spécifié lors de l'affichage brut des chaînes."

#: src/od.c:1873
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "La deuxième opérande « %s » est invalide en mode compatible."

#: src/od.c:1894
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr ""
"En mode compatible, les 2 derniers arguments doivent être des adresses "
"relatives."

#: src/od.c:1901
msgid "compatibility mode supports at most three arguments"
msgstr "Le mode compatible supporte au plus 3 arguments."

#: src/od.c:1974
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "AVERTISSEMENT: largeur invalide %lu; utilise %d à la place."

#: src/od.c:1990
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: fmt=« %s » largeur=%d\n"

#: src/paste.c:50
msgid "David M. Ihnat and David MacKenzie"
msgstr "David M. Ihnat et David MacKenzie"

#: src/paste.c:208
msgid "standard input is closed"
msgstr "L'entrée standard est fermée."

#: src/paste.c:407
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Coller séquentiellement les lignes correspondantes de chaque\n"
"FICHIER, séparé par des tabulations, vers la sortie standard.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/paste.c:416
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=LISTE  utiliser les caractères de la LISTE au lieu\n"
"                           de tabulations\n"
"  -s, --serial            copier un fichier à la fois au lieu de\n"
"                           le faire en parallèle\n"

#: src/pr.c:328
msgid "Pete TerMaat and Roland Huebner"
msgstr "Pete TerMaat et Roland Huebner"

#: src/pr.c:805
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "« --pages » intervalle des pages invalide: « %s »"

#: src/pr.c:817
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "« --pages » numéro de page de départ invalide: « %s »"

#: src/pr.c:829
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "« --pages » numéro de page finale invalide: « %s »"

#: src/pr.c:836
msgid "`--pages' starting page number is larger than ending page number"
msgstr ""
"« --pages » numéro de page de départ est plus grand que le no. de page finale"

#: src/pr.c:913
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "« --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE] » argument manquant"

#: src/pr.c:924
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "« --columns=N »    nombre invalide de colonnes: « %s »"

#: src/pr.c:978
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "« -l LONGUEUR_PAGE » contient un nombre invalide de lignes: « %s »."

#: src/pr.c:1002
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "« -N NUMBER » contient un nombre invalide de départ: « %s »."

#: src/pr.c:1014
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "« -o MARGIN » saut de ligne invalide: « %s »"

#: src/pr.c:1055
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr ""
"« -w LARGEUR_DE_PAGE » contient un nombre invalide de caractères: « %s »"

#: src/pr.c:1067
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr ""
"« -W LARGEUR_DE_PAGE » contient un nombre invalide de caractères: « %s »"

#: src/pr.c:1081
msgid "%b %e %H:%M %Y"
msgstr "%b %e %H:%M %Y"

#: src/pr.c:1090
msgid "Cannot specify number of columns when printing in parallel."
msgstr "Ne peut spécifier le nombre de colonnes lorsqu'imprimant en parallèle."

#: src/pr.c:1094
msgid "Cannot specify both printing across and printing in parallel."
msgstr "Ne peut faire un affichage à la fois croisée et en parallèle."

#: src/pr.c:1190
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr ""
"« -%c': caractères superflus ou nombre invalide dans les arguments: « %s »."

#: src/pr.c:1301
msgid "page width too narrow"
msgstr "La largeur de page est trop petite."

#: src/pr.c:2364
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr ""
"Le numéro de page de départ est plus grand que le nombre total de pages: « %"
"d »"

#: src/pr.c:2395
#, c-format
msgid "Page %d"
msgstr "Page %d"

#: src/pr.c:2761
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
msgstr ""
"Paginer ou mettre en colonne les FICHIERS pour impression.\n"
"\n"

#: src/pr.c:2768
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
msgstr ""
"  +PREMIÈRE_PAGE[:DERNIÈRE_PAGE], \n"
"      --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE]\n"
"                       débuter [stopper] l'impression à la PREMIÈRE_PAGE\n"
"                       ou à la DERNIÈRE_PAGE\n"
"  -COLUMN\n"
"      --columns=COLUMN\n"
"                       produire une sortie en COLONNES et imprimer les\n"
"                       les colonnes vers le bas à moins que -a ne soit\n"
"                       utilisé.  Équilibrer le nombre de lignes de chaque\n"
"                       colonne sur chaque page.\n"

#: src/pr.c:2776
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across         imprimer les colonnes horizontalement au lieu de\n"
"                       verticalement, utilisé ensemble avec -COLUMN\n"
"  -c, --show-control-chars\n"
"                       utiliser une notation par chapeau (^G) et octale\n"
"                       avec barre oblique inverse\n"
"  -d, --double-space\n"
"                       produire une sortie avec double espacement\n"

#: src/pr.c:2784
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=FORMAT\n"
"                          utiliser le FORMAT pour l'en-tête de la date\n"
"  -e[CAR[LARGEUR]], --expand-tabs[=CAR[LARGEUR]]\n"
"                       faire l'expansion des CARactères (ou de tabulation)\n"
"                       selon la LARGEUR de tabulation (par défaut 8)\n"
"  -F, -f,\n"
"      --form-feed\n"
"                       utiliser des sauts de page au lieu des sauts de \n"
"                       lignes pour séparer les pages (3 lignes par en-tête\n"
"                       avec -f ou 5 lignes par en-tête et bas de page sans -"
"f) \n"

#: src/pr.c:2794
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h EN-TÊTE, --header=EN-TÊTE\n"
"                       centrer l'EN-TÊTE au lieu du nom de fichier dans\n"
"                       l'en-tête de la page, \n"
"                        -h \"\" imprime une ligne blanche.\n"
"                       ne pas utiliser:  -h\"\"\n"
"  -i[CAR[LARGEUR]], --output-tabs[=CAR[LARGEUR]]\n"
"                       remplacer les blancs par des CARactères (ou\n"
"                       de tabulation) selon la LARGEUR de tabulation (8 par "
"défaut)\n"
"  -J, --join-lines\n"
"                       faire la fusion des lignes pleines, inhiber la \n"
"                       troncation des lignes -W, sans alignement des\n"
"                       colonnes -s-sep-string[=CHAÎNE] initialise les "
"séparateurs\n"

#: src/pr.c:2803
msgid ""
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l LONGUEUR_DE_PAGE, --length LONGUEUR_DE_PAGE\n"
"                       utiliser LONGUEUR_DE_PAGE au lieu de 66 lignes\n"
"                       (par défaut de lignes est de 56 pour un texte,\n"
"                       avec -f de 63)\n"
"  -m, --merge          imprimer tous les fichiers en parallèle un par\n"
"                       colonne, tronque les lignes, mais joint les\n"
"                       lignes de pleine longueur avec -j\n"

#: src/pr.c:2810
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n, --number-lines[=SÉP[CHIFFRES]]\n"
"                       numéroter les lignes, par des CHIFFRES (5), suivi de\n"
"                       SÉParateurs (TAB) par défaut le compteur débute\n"
"                       avec la première ligne du fichier d'entrée\n"
"  -N, --first-line-number=VALEUR\n"
"                       débuter le compteur avec la VALEUR avec la 1ère "
"ligne\n"
"                       de la 1ère page imprimée (voir +PREMIÈRE_PAGE)\n"

#: src/pr.c:2818
msgid ""
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=MARGE\n"
"                       débuter l'impression de chaque ligne après une\n"
"                       MARGE d'espacement  (n'affecte pas -w)\n"
"  -r, --no-file-warnings\n"
"                       inhiber les avertissements lorsqu'un fichier\n"
"                       ne peut être ouvert\n"

#: src/pr.c:2825
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[CAR], --separator[=CHAÎNE]\n"
"                       séparer les colonnes à l'aide d'un simple CARactère\n"
"                       par défaut le caractère de TABulation sans -w et 'no "
"char»\n"
"                       avec -w et -s[CAR] inhibe la troncation de ligne des "
"3 colonnes\n"
"                       options de 3 colonnes (-COLUMN|-a - COLUMN|-m) sauf "
"si -w est utilisé\n"

#: src/pr.c:2832
msgid "  -SSTRING, --sep-string[=STRING]\n"
msgstr "  -SSTRING, --sep-string[=CHAÎNE]\n"

#: src/pr.c:2835
msgid ""
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
msgstr ""
"                       séparer les colonnes à l'aide d'une CHAÎNE\n"
"                       sans -S: le séparateur par défaut est <TAB> avec -J "
"et <ESPACE>\n"
"                       autrement (identique as -S« »), sans effet sur les "
"options\n"
"                       des colonnes\n"
"  -t, --omit-header\n"
"                      inhiber l'en-tête et le bas de page\n"

#: src/pr.c:2841
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                       inhiber l'en-tête et le bas de page, éliminer\n"
"                       les agencements de page par saut de page indiqués\n"
"                       dans les fichiers d'entrée\n"
"  -v, --show-nonprinting\n"
"                       utiliser la notation octale avec barre oblique\n"
"                       inverse\n"
"  -w LARGEUR_DE_PAGE,\n"
"      --width=LARGEUR_DE_PAGE\n"
"                       utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\\n\"\n"
"                       tronquer les lignes (voir aussi l'option -j)\n"

#: src/pr.c:2851
msgid ""
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W LARGEUR_DE_PAGE,\n"
"       --page-width=LARGEUR_DE_PAGE\n"
"                       toujours utiliser une LARGEUR_DE_PAGE de 72 "
"caractères,\n"
"                       tronquer les lignes, sauf lorsque l'option -J est "
"utilisée\n"
"                       sans interférence avec -S ou -s\n"

#: src/pr.c:2859
msgid ""
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"\n"
"L'option -T est implicite lorsque -l N est utilisée et avec -f quand nn <= "
"10\n"
"ou <= 3. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"

#: src/ptx.c:410
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (pour regexp « %s »)"

#: src/ptx.c:1859
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Usage: %s [OPTION]... [ENTRÉE]...   (sans l'option -G)\n"
"  ou:  %s -G [OPTION]... [ÉNTRÉE [SORTIE]]\n"

#: src/ptx.c:1863
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
"\n"
msgstr ""
"Produire un index permuté, incluant le contexte des mots des fichiers "
"d'entrée.\n"
"\n"

#: src/ptx.c:1870
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A, --auto-reference           générer des références automatiquement\n"
"  -C, --copyright                afficher les Droits d'auteur et les "
"conditions\n"
"                                 de recopie\n"
"  -G, --traditional              faire fonctionner « ptx » comme en System "
"V\n"
"  -F, --flag-truncation=CHAÎNE   utiliser la CHAÎNE pour indiquer la "
"troncation\n"
"                                 des lignes\n"

#: src/ptx.c:1876
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=CHAÎNE        nom de la macro à utiliser au lieu de « xx "
"»\n"
"  -O, --format=roff              générer la sortie comme des directives "
"roff\n"
"  -R, --right-side-refs          placer les références à droite, sans "
"décompte -w\n"
"  -S, --sentence-regexp=REGEXP   pour la fin des lignes ou des phrases\n"
"  -T, --format=tex               générer la sortie comme des directives TeX\n"

#: src/ptx.c:1883
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       utiliser REGEXP pour établir la concordance "
"avec chaque mot\n"
"  -b, --break-file=FICHIER       utiliser les coupures de mots de ce "
"FICHIER\n"
"  -f, --ignore-case              ramener les minuscules en majuscules pour "
"le trie\n"
"  -g, --gap-size=N               espacer de N blancs les colonnes entre les "
"champs\n"
"  -i, --ignore-file=FICHIER      lire la liste des mots à ignorer de ce "
"FICHIER\n"
"  -o, --only-file=FICHIER        lire la liste des mots uniquement de ce "
"FICHIER\n"

#: src/ptx.c:1891
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               donner la référence du 1er champ de chaque "
"ligne\n"
"  -t, --typeset-mode               - option non implanté -\n"
"  -w, --width=N                  largeur des colonnes, références exclues\n"

#: src/ptx.c:1898
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard. -F par "
"défaut.\n"

#: src/ptx.c:1978
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
msgstr ""
"Ce programme est un logiciel libre; vous pouvez le redistribuer ou le\n"
"modifier selon les termes de la License Publique Générale de GNU, publiée\n"
"par la Free Software Foundation (soit la version 2 ou soit, à votre\n"
"discrétion, toute version ultérieure).\n"
"\n"

#: src/ptx.c:1985
msgid ""
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
msgstr ""
"Ce programme est distribué dans l'espoir qui'il soit utile,\n"
"mais AUCUNE garantie n'est donnée tant pour des raisons COMMERCIALES que\n"
"pour RÉPONDRE À UN BESOIN PARTICULIER.  Consulter la licence\n"
"GNU General Public License pour plus de détails.\n"
"\n"

#: src/ptx.c:1992
msgid ""
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"Vous devriez avoir reçu copie de la Licence Publique Générale de GNU\n"
"avec ce programme; sinon, écrire à la Free Software Foundation, Inc.,\n"
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"

#: src/sort.c:53
msgid "Mike Haertel and Paul Eggert"
msgstr "Mike Haertel et Paul Eggert"

#: src/sort.c:283
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"Ordering options:\n"
"\n"
msgstr ""
"Afficher la concaténation triée de tous les FICHIERS sur la sortie "
"standard.\n"
"\n"
"Options de tri:\n"
"\n"

#: src/sort.c:292
msgid ""
"  -b, --ignore-leading-blanks ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ignorer les blancs de tête\n"
"  -d, --dictionary-order      considérer seulement les blancs et\n"
"                              les caractères alphanumériques\n"
"  -f, --ignore-case           suivre les caractères minuscules et "
"majuscules\n"

#: src/sort.c:297
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < `JAN' < ... < `DEC'\n"
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -r, --reverse               reverse the result of comparisons\n"
"\n"
msgstr ""
"  -g, --general-numeric-sort  comparer selon la valeur numérique des "
"caractères\n"
"  -i, --ignore-nonprinting    considérer seulement les caractères "
"imprimables\n"
"  -M, --month-sort            comparer (inconnu) < « JAN » < ... < « DÉC »\n"
"  -n, --numeric-sort          comparer selon la valeur numérique de la "
"chaîne\n"
"  -r, --reverse               afficher dans l'ordre inverse le résultat\n"
"\n"

#: src/sort.c:305
msgid ""
"Other options:\n"
"\n"
"  -c, --check               check whether input is sorted; do not sort\n"
"  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin 1)\n"
"  -m, --merge               merge already sorted files; do not sort\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"Autres options:\n"
"\n"
"  -c, --check               vérifier si l'entrée est triée; ne pas trier\n"
"  -k, --key=POS1[,POS2]     débuter avec la clé à la POS1, terminer à POS 2 "
"(origine 1)\n"
"  -m, --merge               faire la fusion des fichiers déjà triés; ne pas "
"trier\n"
"  -o, --output=FICHIER      écrire le résultat au FICHIER au lieu de la "
"sortie standard\n"
"  -s, --stable              stabiliser le tri en inhibant la comparaison de "
"dernier recours\n"
"  -S, --buffer-size=TAILLE  utiliser la TAILLE pour le tampon mémoire "
"principal\n"

#: src/sort.c:315
#, c-format
msgid ""
"  -t, --field-separator=SEP use SEP instead of non- to whitespace "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s\n"
"                              multiple options specify multiple directories\n"
"  -u, --unique              with -c: check for strict ordering\n"
"                              otherwise: output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=SEP utiliser le SÉParateur au lieu de non- par les "
"transitions d'espace blancs\n"
"  -T, --temporary-directory=RÉP utiliser le RÉP pour les fichiers "
"temporaires, pas $TMPDIR ou %s\n"
"                            options multiples pour spécifier de multiples "
"répertoires\n"
"  -u, --unique              avec -c: vérifier l'ordonnancement strict\n"
"                            autrement: afficher les premiers d'une passe "
"équivalente\n"

#: src/sort.c:322
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     terminer les lignes avec l'octet 0, \n"
"                            et non pas par un retour de chariot\n"

#: src/sort.c:327
msgid ""
"\n"
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field.  OPTS is one or more single-letter ordering options, which\n"
"override global ordering options for that key.  If no key is given, use the\n"
"entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS est F[.C][OPTS], où F est le numéro du champ et C le caractère de la\n"
"position dans le champ.  OPTS se compose d'une ou plusieurs lettres "
"simples,\n"
"laquelle écrase l'ordonnancement global pour cette clé.\n"
"Si aucune clé n'est donnée, la ligne entière est utilisée comme clé.\n"
"\n"
"TAILLE peut être suivi d'un des suffixe multiplicatif suivant:\n"

#: src/sort.c:336
#, c-format
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% de mémoire, b 1, k 1024 (par défaut), et ainsi de suite pour M, G, T, "
"P, E, Z, Y.\n"
"\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"
"*** AVERTISSEMENT ***\n"
"La localisation utilisée dans l'environnement affecte l'ordre du tri.\n"
"Utiliser LC_ALL=C pour obtenir un tri selon un ordre traditionnel qui "
"utilise la valeur\n"
"native des octets.\n"

#: src/sort.c:447
msgid "cannot create temporary file"
msgstr "Ne peut créer de fichier temporaire"

#: src/sort.c:470
msgid "open failed"
msgstr "Échec d'ouverture"

#: src/sort.c:490 src/sort.c:2488
msgid "close failed"
msgstr "Échec de fermeture"

#: src/sort.c:498
msgid "write failed"
msgstr "Echec d'écriture."

#: src/sort.c:644
msgid "sort size"
msgstr "taille du tri"

#: src/sort.c:718
msgid "stat failed"
msgstr "Échec de stat()"

#: src/sort.c:970
msgid "read failed"
msgstr "Échec de lecture"

#: src/sort.c:1566
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: désordre: "

#: src/sort.c:1570
msgid "standard error"
msgstr "erreur standard"

#: src/sort.c:2028
#, c-format
msgid "%s: invalid field specification `%s'"
msgstr "%s: spécification invalide du champ « %s »"

#: src/sort.c:2054
#, c-format
msgid "%s: count `%.*s' too large"
msgstr "%s: décompte « %.*s » trop grand"

#: src/sort.c:2060
#, c-format
msgid "%s: invalid count at start of `%s'"
msgstr "%s: compteur invelide au départ de « %s »."

#: src/sort.c:2290
msgid "invalid number after `-'"
msgstr "nombre invalide après « - »"

#: src/sort.c:2293 src/sort.c:2339 src/sort.c:2366
msgid "invalid number after `.'"
msgstr "nombre invalide après « . »"

#: src/sort.c:2296 src/sort.c:2375
msgid "stray character in field spec"
msgstr "caractère égaré dans le champ de spécification"

#: src/sort.c:2330
msgid "invalid number at field start"
msgstr "nombre invalide dans le champ de départ"

#: src/sort.c:2334 src/sort.c:2362
msgid "field number is zero"
msgstr "numéro de champ est zéro"

#: src/sort.c:2343
msgid "character offset is zero"
msgstr "adresse relative du caractère est zéro"

#: src/sort.c:2358
msgid "invalid number after `,'"
msgstr "nombre invalide après « , »"

#: src/sort.c:2403
#, c-format
msgid "multi-character tab `%s'"
msgstr "tab multi-caractère « %s »"

#: src/sort.c:2471
#, c-format
msgid "extra operand `%s' not allowed with -c"
msgstr "opérande surnuméraire « %s » non permise avec -c"

#: src/split.c:95
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "Usage: %s [OPTION] [ENTRÉE [PRÉFIXE]]\n"

#: src/split.c:99
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
msgstr ""
"Afficher sur la sortie des morceaux de l'ENTRÉE de taille selon\n"
"PRÉFIXEaa, PRÉFIXEab, ...; le PRÉFIXE par défaut est « x ».\n"
"Sans ENTRÉE, ou quand l'ENTRÉE est -, lire l'entrée standard.\n"
"\n"

#: src/split.c:107
#, c-format
msgid ""
"  -a, --suffix-length=N   use suffixes of length N (default %d)\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
msgstr ""
"  -a, --suffix-length=N   utiliser les suffixes de longueur N (par défaut %"
"d)\n"
"  -b, --bytes=N           écrire N octets par fichier de sortie\n"
"  -C, --line-bytes=N      écrire au plus N octets par ligne\n"
"                          par fichier de sortie\n"
"  -l, --lines=N           écrire N lignes par fichier de sortie\n"

#: src/split.c:113
msgid ""
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
msgstr ""
"      --verbose           afficher un diagnostic sur la sortie standard "
"d'erreur\n"
"                            juste avant l'ouverture du fichier de sortie\n"

#: src/split.c:170
msgid "Output file suffixes exhausted"
msgstr "Produire les suffixes des fichiers épuisés"

#: src/split.c:188
#, c-format
msgid "creating file `%s'\n"
msgstr "Création du fichier « %s »\n"

#: src/split.c:407
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s: longueur de suffixe invalide"

#: src/split.c:416 src/split.c:432 src/split.c:448 src/split.c:474
msgid "cannot split in more than one way"
msgstr "Ne peut segmenter plus d'une façon."

#: src/split.c:423 src/split.c:456
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: nombre d'octets invalide."

#: src/split.c:439
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: nombre de lignes invalide."

#: src/split.c:499
#, c-format
msgid "`-%d' option is obsolete; use `-l %d'"
msgstr "option « -%d » est obsolète; utiliser « -l %d »"

#: src/split.c:512
msgid "invalid number"
msgstr "Nombre invalide."

#: src/split.c:527 src/tr.c:1849
msgid "too many arguments"
msgstr "Trop de arguments."

#: src/sum.c:36
msgid "Kayvan Aghaiepour and David MacKenzie"
msgstr "Kayvan Aghaiepour et David MacKenzie"

#: src/sum.c:64
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Imprimer la somme de contrôle et le nombre de blocs pour chaque FICHIER.\n"
"\n"
"  -r              annuler -s et utiliser l'algorithme de sommation BSD\n"
"                  avec des blocs de 1K octets\n"
"  -s, --sysv      utiliser l'algorithme de sommation du Système V\n"
"                  avec des blocs de 512 octets\n"

#: src/sys2.h:483
msgid "      --help     display this help and exit\n"
msgstr "      --help      afficher l'aide-mémoire\n"

#: src/sys2.h:485
msgid "      --version  output version information and exit\n"
msgstr "      --version   afficher le nom et la version du logiciel\n"

#: src/tac.c:54
msgid "Jay Lepreau and David MacKenzie"
msgstr "Jay Lepreau et David MacKenzie"

#: src/tac.c:131
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Écrire chaque FICHIER sur la sortie standard, la dernière ligne en premier.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tac.c:139
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before           placer le séparateur avant plutôt qu'après\n"
"  -r, --regex            interpréter le séparateur comme une expression\n"
"                          régulière\n"
"  -s, --separator=CHAÎNE utiliser la CHAÎNE comme séparateur au lieu\n"
"                          du saut de ligne\n"

#: src/tac.c:454 src/tac.c:593
msgid "stdin: read error"
msgstr "stdin: erreur de lecture."

#: src/tac.c:639
msgid "separator cannot be empty"
msgstr "Le séparateur ne peut être vide."

#: src/tail.c:242
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Afficher les %d dernières lignes de chaque FICHIER sur la sortie standard.\n"
"Avec plus d'un fichier FICHIER, précéder chacun d'une en-tête donnant le "
"nom.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"\n"

# src/tail.c:250
#: src/tail.c:251
msgid ""
"      --retry              keep trying to open a file even if it is\n"
"                           inaccessible when tail starts or if it becomes\n"
"                           inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
msgstr ""
"      --retry              continuer de tenter d'ouvrir le fichier même "
"s'il\n"
"                           est inaccessible lorsque tail démarre ou s'il "
"devient\n"
"                           inaccessible plus tard -- utile seulement avec -"
"f\n"
"  -c, --bytes=N            afficher les N derniers octets\n"

#: src/tail.c:257
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={nom|descripteur}]\n"
"                           afficher les dernières données ajoutées tant\n"
"                            que le fichier s'accroît; -f, --follow, et\n"
"                           --follow=descripteur sont équivalents\n"
"  -F                        identique à --follow=nom --retry\n"

#: src/tail.c:264
#, c-format
msgid ""
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files)\n"
msgstr ""
"  -n, --lines=N            afficher les N dernièreslignes, au lieu des %d\n"
"      --max-unchanged-stats=N\n"
"                           avec l'option --follow=nom, le FICHIER qui n'a "
"pas\n"
"                           changé de taille après N itérations (par défaut %"
"d)\n"
"                           afin de vérifier s'il a été détruit ou s'il a "
"changé\n"
"                           de nom (c'est le cas habituellement des fichiers\n"
"                           de journalisation dont on fait la rotation)\n"

#: src/tail.c:275
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
"                           (default 1) seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"      --pid=PID            avec -f, terminer après le processus ID, PID est "
"arrêté\n"
"  -q, --quiet, --silent    ne jamais afficher l'en-tête avec\n"
"                            les noms de fichiers\n"
"  -s, --sleep-interval=S   avec -f, attendre S secondes (1 par défaut)\n"
"                            entre les itérations\n"

#: src/tail.c:284
msgid ""
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).\n"
"\n"
msgstr ""
"\n"
"Si le premier caractère de N (le nombre d'octets ou de lignes) est un « + "
"»,\n"
"afficher à partir du Nième item depuis le début de chaque fichier,\n"
"autrement, afficher les derniers N items du fichier.\n"
"N peut avoir un suffixe multiplicateur:\n"
"b pour 512, k pour 1024, m pour 1048576 (1 Meg).\n"

# src/tail.c:290
#: src/tail.c:292
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  "
msgstr ""
"Avec l'option --follow (-f), tail utilise par défaut le descripteur de "
"fichier\n"
"qui permet de suivre l'évolution du fichier ciblé même s'il change de nom.\n"
"Tail continuera de suivre l'évolution du fichier jusqu'à la fin. "

#: src/tail.c:297
msgid ""
"This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
msgstr ""
"Ce comportement par défaut n'est pas désirable lorsqu'on désire suivre "
"l'évolution\n"
"d'un fichier à l'aide de son nom et non pas par le descripteur de fichier (i."
"e. cas\n"
"lors de la rotation des journaux). Utiliser --follow=nom dans ce cas.\n"
"À ce moment, tail suivra l'évolution du fichier en l'ouvrant périodiquement\n"
"afin de vérifier s'il a été détruit ou recréé par un autre programme.\n"

#: src/tail.c:335
#, c-format
msgid "closing %s (fd=%d)"
msgstr "fermeture %s (fd=%d)"

#: src/tail.c:400
#, c-format
msgid "%s: cannot seek to offset %s%s"
msgstr "%s: ne peut repérer le déplacement %s%s"

#: src/tail.c:404
#, c-format
msgid "%s: cannot seek to relative offset %s%s"
msgstr "%s: ne peut repérer selon le déplacement relatif %s%s"

#: src/tail.c:408
#, c-format
msgid "%s: cannot seek to end-relative offset %s%s"
msgstr "%s: ne peut repérer la fin selon le déplacement relatif %s%s"

#: src/tail.c:814
#, c-format
msgid "`%s' has become inaccessible"
msgstr "« %s » est devenu inaccessible"

#: src/tail.c:831
#, c-format
msgid "`%s' has been replaced with an untailable file; giving up on this name"
msgstr ""
"« %s » a été remplacé par un fichier dont on ne peut déterminer la taille; "
"abandon sur ce nom."

#: src/tail.c:852
#, c-format
msgid "`%s' has become accessible"
msgstr "%s» est devenu accessible"

#: src/tail.c:860
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "« %s » a été remplacé; à la suite de la fin d'un nouveau fichier"

#: src/tail.c:871
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "« %s » a été remplacé; à la suite de la fin d'un nouveau fichier"

#: src/tail.c:996
#, c-format
msgid "%s: file truncated"
msgstr "%s: fichier tronqué"

#: src/tail.c:1016
msgid "no files remaining"
msgstr "aucun fichier restant"

#: src/tail.c:1226
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr ""
"%s: ne peut déterminer la fin de ce type de fichier; abandon sur ce nom"

#: src/tail.c:1346
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: caractère invalide en suffixe dans une option désuète."

#: src/tail.c:1395
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"Trop de arguments; lors de l'utilisation d'une syntaxe désuète (%s) de tail\n"
"Il ne peut y avoir plus d'un fichier en argument. Utiliser l'option -n ou -"
"b\n"
"équivalente à la place."

#: src/tail.c:1404
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"AVERTISSEMENT: l'utilisation de 2 ou plusieurs fichiers en argument\n"
"avec une syntaxe désuète des options (%s) de tail n'est pas portable.\n"
"Utiliser les options équivalentes -n ou -c à la place."

#: src/tail.c:1413
#, c-format
msgid "`%s' option is obsolete; use `%s-%c %.*s'"
msgstr "option « %s » est obsolète; utiliser « %s-%c %.*s »"

#: src/tail.c:1473
#, c-format
msgid "%s: is so large that it is not representable"
msgstr "%s: est tellement grand qu'il n'est pas représentable."

#: src/tail.c:1477
#, c-format
msgid "%s is larger than the maximum file size on this system"
msgstr "%s est plus grand que la taille maximale possible sur ce système"

#: src/tail.c:1503
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr ""
"%s: nombre maximum invalide de changements d'états entre les ouvertures"

#: src/tail.c:1515
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s: nombre maximum invalide de changements consécutifs de taille"

#: src/tail.c:1527
#, c-format
msgid "%s: invalid PID"
msgstr "%s: PID invalide."

#: src/tail.c:1545
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: nombre de secondes invalide."

#: src/tail.c:1565
msgid "warning: --retry is useful only when following by name"
msgstr "AVERTISSEMENT: --retry est utile seulement si suivi par un nom"

#: src/tail.c:1569
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"AVERTISSEMENT: PID ignoré; --pid=PID est utile seulement lorsqu'il suit"

#: src/tail.c:1572
msgid "warning: --pid=PID is not supported on this system"
msgstr "AVERTISSEMENT: --pid=PID n'est pas supporté sur ce système"

#: src/tr.c:327
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Usage: %s [OPTION]... ENSEMBLE1 [ENSEMBLE2]\n"

#: src/tr.c:331
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Traduire, compresser, et/ou éliminer des caractères de l'entrée standard,\n"
"par écriture sur la sortie standard.\n"
"\n"
"  -c, --complement        complémenter à un l'ENSEMBLE1 \n"
"  -d, --delete            éliminer les caractères de l'ENSEMBLE1\n"
"                          et ne pas traduire\n"
"  -s, --squeeze-repeats   remplacer chaque séquence d'entrée de caractères "
"répétés\n"
"                          qui apparaît dans l'ENSEMBLE1 par une seule "
"occurence\n"
"                          de ce caractère\n"
"  -t, --truncate-set1     tronquer d'abord l'ENSEMBLE1 à la longueur\n"
"                          de l'ENSEMBLE2\n"

#: src/tr.c:344
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"Les ENSEMBLES sont spécifiés comme des chaînes de caractères.\n"
"La plupart se représente eux-mêmes.\n"
"Les séquences d'interprétation sont:\n"
"\n"
"  \\NNN            caractère ayant la valeur octale NNN (1 à 3 chiffres "
"octaux)\n"
"  \\\\             barre oblique inverse\n"
"  \\a              cloche sonore \n"
"  \\b              caractère d'effacement\n"
"  \\f              saut de page \n"
"  \\n              saut de ligne \n"
"  \\r              retour\n"
"  \\t              saut horizontal\n"

#: src/tr.c:358
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              saut vertical \n"
"  CAR1-CAR2       tous les caractères de CAR1 à CAR2 en ordre croissant\n"
"  [CAR*]          dans ENS2, copie de CAR jusqu'à longueur de ENS1\n"
"  [CAR*RÉP]       RÉPéter copies de CAR, RÉPéter en octal si débute par 0\n"
"  [:alnum:]       toutes les lettres et les chiffres\n"
"  [:alpha:]       toutes les lettres\n"
"  [:blank:]       tous les blancs horizontaux\n"
"  [:cntrl:]       tous les caractères de contrôle\n"
"  [:digit:]       tous les chiffres\n"

#: src/tr.c:369
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       tous les caractères imprimables, sans inclure les blancs\n"
"  [:lower:]       tous les lettres minuscules\n"
"  [:print:]       tous les caractères imprimables, incluant les blancs\n"
"  [:punct:]       tous les caractères de ponctuation\n"
"  [:space:]       tous les sauts verticaux ou horizontaux\n"
"  [:upper:]       toutes les lettres majuscules\n"
"  [:xdigit:]      tous les chiffres hexadécimaux\n"
"  [=CAR=]         tous les caractères équivalents à CAR\n"

#: src/tr.c:379
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  "
msgstr ""
"\n"
"La traduction survient si -d n'est pas fourni et si les deux ensembles\n"
"ENSEMBLE1 et ENSEMBLE2 sont fournis en argument.\n"
"L'option -t peut être utilisée seulement lors de la traduction.  "
"L'ENSEMBLE2\n"
"est dilaté selon la taille de l'ENSEMBLE1 par répétition des derniers\n"
"caractères si nécessaire."

#: src/tr.c:385
msgid ""
"Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  "
msgstr ""
"Les caractères en excès de l'ENSEMBLE2 sont ignorés.\n"
"Seuls [:lower:] et [:upper:] sont garants d'une expansion en ordre\n"
"en ordre croissant; utilisé dans l'ENSEMBLE2 lors de la traduction, ils "
"peuvent\n"
"seulement être utilisés par paire pour spécifier une conversion de la casse."

#: src/tr.c:391
msgid ""
"-s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"L'option -s s'emploie avec l'ENSEMBLE1 sinon il n'y a pas de traduction ou\n"
"d'élimination autrement la compression utilise l'ENSEMBLE2 et se produit "
"après\n"
"la traduction ou l'élimination.\n"

#: src/tr.c:557
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"AVERTISSEMENT: l'échappement ambigu octal \\%c%c%c est\n"
"               interprété comme une séquence de 2-octets \\0%c%c, « %c »"

#: src/tr.c:566
msgid "invalid backslash escape at end of string"
msgstr "Échappement barre oblique inverse invalide à la fin d'une chaîne."

#: src/tr.c:572
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "Échappement barre oblique inverse invalide « \\%c »"

#: src/tr.c:725
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr ""
"bornes d'intervalle de « %s-%s » sont en ordre inverse de séquence\n"
"de comparaison."

#: src/tr.c:906
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "compte de répétions « %s » invalide dans le construit [c*n]"

#: src/tr.c:999
msgid "missing character class name `[::]'"
msgstr "caractères de nom de classe « [::] » manquants"

#: src/tr.c:1002
msgid "missing equivalence class character `[==]'"
msgstr "caractères d'équivalence de classe « [==] » manquants"

#: src/tr.c:1025
#, c-format
msgid "invalid character class `%s'"
msgstr "caractère de classe « %s » invalide"

#: src/tr.c:1050
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: opérande d'équivalence de classe doit être un caractère simple"

#: src/tr.c:1522
msgid "the [c*] repeat construct may not appear in string1"
msgstr "le construit [c*] de répétition ne peut apparaître dans la chaîne1"

#: src/tr.c:1532
msgid "only one [c*] repeat construct may appear in string2"
msgstr "un seul construit de répétition [c*] peut apparaître dans chaîne2"

#: src/tr.c:1540
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr ""
"les expressions [=c=] ne peuvent apparaître dans chaîne2 lors de traductions"

#: src/tr.c:1553
msgid "when not truncating set1, string2 must be non-empty"
msgstr "lorsque que l'ensemble1 n'est pas tronqué, chaîne2 ne peut être vide"

#: src/tr.c:1562
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"lors de traduction avec des caractères complémentées de classes,\n"
"la chaîne2 doit ramener tous les caractères du domaine à un seul"

#: src/tr.c:1569
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"lors de traductions la seule classe de caractères pouvant apparaître\n"
"dans chaîne2 est « upper » ou « lower »"

#: src/tr.c:1578
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"le construit [c*] peut apparaître dans chaîne2 seulement lors d'une\n"
"traduction"

#: src/tr.c:1854
msgid "two strings must be given when translating"
msgstr "deux chaînes doivent être fournies lors de la traduction"

#: src/tr.c:1857
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr ""
"deux chaînes doivent être fournies lorsqu'il y a destruction\n"
"et réduction des répétitions"

#: src/tr.c:1871
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""
"seule une chaîne peut être fournie lors d'une destruction sans\n"
"réduction des répétitions"

#: src/tr.c:1877
msgid "at least one string must be given when squeezing repeats"
msgstr ""
"au moins une chaîne doit être fournie lors de réduction des répétitions"

#: src/tr.c:1968
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "construit [:upper:] et/ou [:lower:] mal aligné"

#: src/tr.c:1991
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"correspondance d'identité invalide:  lors de la traduction de contruits\n"
"[:lower:] ou [:upper:], le construit dans la chaîne1 doit être aligné\n"
"avec le construit correspondant ([:upper:] ou [:lower:] respectivement)\n"
"dans la chaîne2"

#: src/tsort.c:97
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Usage: %s [OPTION] [FICHIER]\n"
"Afficher une liste totalement ordonnée consistante avec l'ordenancement\n"
"partiel donné dans le FICHIER.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
"\n"

#: src/tsort.c:533
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: l'entrée contient une boucle:"

#: src/tsort.c:575
msgid "only one argument may be specified"
msgstr "Un seul argument peut être spécifié."

#: src/unexpand.c:379
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Convertir les blancs d'espacement de chaque FICHIER par des tabulations,\n"
"lors de l'écriture sur la sortie standard.\n"
"Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#: src/unexpand.c:387
msgid ""
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -a, --all           convertir tous les espaces blancs,\n"
"                      au lieu du blanc d'espacement initial\n"
"  -t, --tabs=N        utiliser N caractères de tabulations au lieu de 8\n"
"  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
"                      de tabulation\n"
"                      séparées par des virgules\n"

#: src/unexpand.c:463
msgid "`-LIST' option is obsolete; use `--first-only -t LIST'"
msgstr "option « -LIST » est obsolète; utiliser « --first-only -t LIST »"

#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Usage: %s [OPTION]... [ENTRÉE [SORTIE]]\n"

#: src/uniq.c:138
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
msgstr ""
"Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
"(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
"(ou vers la sortie standard).\n"
"\n"

#: src/uniq.c:146
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           préfixer les lignes par le nombre d'occurences\n"
"  -d, --repeated        afficher seulement les lignes ayant des duplicatats\n"

#: src/uniq.c:150
msgid ""
"  -D, --all-repeated[=delimit-method] print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines.\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -D, --all-repeated    afficher toutes les lignes qui ont des duplicatats\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        La délimitation est faite avec des lignes blanches.\n"
"  -f, --skip-fields=N   éviter de comparer les N premiers champs\n"
"  -i, --ignore-case     ignorer les différences de la casse\n"
"  -s, --skip-chars=N    éviter de comparer les N premiers caractères\n"
"  -u, --unique          afficher seulement les lignes uniques\n"

#: src/uniq.c:159
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=N   ne pas comparer plus de N caractères des lignes\n"

#: src/uniq.c:164
msgid ""
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"\n"
"Un champ est une suite de blancs, suivi de caractères non-blancs.\n"
"Les champs sont escamotés avant les caractères.\n"

#: src/uniq.c:377
#, c-format
msgid "error reading %s"
msgstr "Erreur lors de la lecture %s"

#: src/uniq.c:382
#, c-format
msgid "error writing %s"
msgstr "Erreur lors de l'écriture %s"

#: src/uniq.c:428 src/uniq.c:445
#, c-format
msgid "extra operand `%s'"
msgstr "opérande surnuméraire « %s »"

#: src/uniq.c:468 src/uniq.c:493
msgid "invalid number of fields to skip"
msgstr "nombre invalide de champs à escamoter"

#: src/uniq.c:502
msgid "invalid number of bytes to skip"
msgstr "nombre invalide d'octets à escamoter"

#: src/uniq.c:511
msgid "invalid number of bytes to compare"
msgstr "nombre invalide d'octets à comparer"

#: src/uniq.c:525
#, c-format
msgid "`-%lu' option is obsolete; use `-f %lu'"
msgstr "option « -%lu » est obsolète; utiliser « -f %lu »"

#: src/uniq.c:533
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"afficher toutes les lignes dupliquées et le décompte de répétition\n"
"est inutile"

#: src/wc.c:78
msgid "Paul Rubin and David MacKenzie"
msgstr "Paul Rubin et David MacKenzie"

#: src/wc.c:132
msgid ""
"Print byte, word, and newline counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Afficher le décompte d'octets, de mots et lignes de chaque FICHIER, et\n"
"le nombre total de ligne si plus d'un FICHIER est spécifié.\n"
"Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
"  -c, --bytes            afficher le nombre d'octets\n"
"  -m, --chars            afficher le nombre de caractères\n"
"  -l, --lines            afficher le nombre de lignes \n"

#: src/wc.c:140
msgid ""
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"  -L, --max-line-length  afficher la longueur de la ligne la plus longue\n"
"  -w, --words            afficher le nombre de mots\n"

#: src/wc.c:589
msgid "total"
msgstr "total"

#~ msgid ""
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"

#~ msgid ""
#~ "\n"
#~ "SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
#~ "If -VALUE is used as first OPTION, read -c VALUE when one of\n"
#~ "multipliers bkm follows concatenated, else read -n VALUE.\n"
#~ msgstr ""
#~ "\n"
#~ "N peut être suivi d'un suffixe multiplicateur:\n"
#~ "b pour 512, k pour 1K, m pour 1 Meg.\n"
#~ "Si -VALEUR est utilisé comme première OPTION, lire -c VALEUR lorsqu'un "
#~ "des\n"
#~ "multiples bkm suivent concaténée(s), sinon lire -n VALEUR.\n"

#~ msgid ""
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolete\n"
#~ msgstr ""
#~ "  +POS1 [-POS2]             débuter avec la clé de position POS1, et "
#~ "terminer\n"
#~ "                            avant POS2 (origine à 0)\n"
#~ "                            AVERTISSEMENT: cette option est obsolète\n"

#~ msgid ""
#~ "  -b, --bytes=SIZE        put SIZE bytes per output file\n"
#~ "  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output "
#~ "file\n"
#~ "  -l, --lines=NUMBER      put NUMBER lines per output file\n"
#~ "  -NUMBER                 same as -l NUMBER\n"
#~ "      --verbose           print a diagnostic to standard error just\n"
#~ "                            before each output file is opened\n"
#~ msgstr ""
#~ "  -b, --bytes=N           écrire N octets par fichier de sortie\n"
#~ "  -C, --line-bytes=N      écrire au plus N octets par ligne\n"
#~ "                          par fichier de sortie\n"
#~ "  -l, --lines=N           écrire N lignes par fichier de sortie\n"
#~ "  -NOMBRE                 identique à -l NOMBRE\n"
#~ "      --verbose           produire un diagnostic sur stderr\n"

#~ msgid ""
#~ "A first OPTION of -VALUE\n"
#~ "is treated like -n VALUE unless VALUE has one of the [bkm] suffix\n"
#~ "multipliers, in which case it is treated like -c VALUE.\n"
#~ msgstr ""
#~ "Une première OPTION de -VALEUR\n"
#~ "est traitée comme -n VALEUR à moins que VALEUR soit suivie d'un suffixe\n"
#~ "multiplicatif [bkm], laquelle dans ce cas est traitée comme -c VALEUR.\n"

#~ msgid ""
#~ "A first option of +VALUE is treated like -+VALUE, but this usage is "
#~ "obsolete\n"
#~ "and support for it will be withdrawn.\n"
#~ "\n"
#~ msgstr ""
#~ "Une première option de +VALEUR est traitée comme -+VALEUR, mais cet usage "
#~ "obsolète\n"
#~ "et son support sera abandonné.\n"
#~ "\n"

#~ msgid "warning: `tail %s' is obsolete; use -n or -c instead"
#~ msgstr "AVERTISSEMENT: `tail %s' est obsolète; utiliser -n ou -c à la place"

#~ msgid "  +N                    same as -s N (obsolete; will be withdrawn)\n"
#~ msgstr ""
#~ "  +N                    identique à -s N (obsolète; sera abandonné)\n"

#~ msgid "warning: `uniq %s' is obsolete; use `uniq -s %s' instead"
#~ msgstr ""
#~ "AVERTISSEMENT: `uniq %s' est obsolète; utiliser `uniq -s %s' à la place"

#~ msgid "\n"
#~ msgstr "\n"

#~ msgid ""
#~ "sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
#~ "for sizeof(double) or L for sizeof(long double).\n"
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
#~ msgstr ""
#~ "sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float), "
#~ "D\n"
#~ "pour sizeof(double) ou L pour sizeof(long double).\n"
#~ "\n"
#~ "BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour "
#~ "aucun.\n"
#~ "OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un "
#~ "multiple de 512\n"

#~ msgid ""
#~ "with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix "
#~ "to\n"
#~ "any type adds a display of printable characters to the end of each line\n"
#~ "of output.  -s without a number implies 3.  -w without a number implies "
#~ "32.\n"
#~ "By default, od uses -A o -t d2 -w 16.\n"
#~ msgstr ""
#~ "avec le suffixe b, de 1024 avec k et de 1048576 avec m. L'ajout du "
#~ "suffixe z à\n"
#~ "n'imporete quel type ajoute l'affichage de caractères imprimables à la "
#~ "fin de chaque ligne\n"
#~ "de sortie. -s non suivi d un nombre implique 3,  32 pour -w.\n"
#~ "Par défaut, od utilise -A o -t d2 -w 16.\n"

#~ msgid ""
#~ "Print CRC checksum and byte counts of each FILE.\n"
#~ "\n"
#~ "  --help      display this help and exit\n"
#~ "  --version   output version information and exit\n"
#~ msgstr ""
#~ "Afficher la somme de contrôle CRC et le décompte d'octets de chaque "
#~ "FICHIER.\n"
#~ "\n"
#~ "  --help      afficher l'aide-mémoire\n"
#~ "  --version   afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Convert tabs in each FILE to spaces, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -i, --initial       do not convert TABs after non whitespace\n"
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
#~ msgstr ""
#~ "Convertir les tabulations de chaque FICHIER par des blancs d'espacement,\n"
#~ "en écrivant sur la sortie standard.\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -i, --initial       ne pas convertir les tabulations après des non "
#~ "blancs\n"
#~ "  -t, --tabs=N        utiliser N caractères de tabulations, et non 8\n"

#~ msgid ""
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=LISTE    utiliser la LISTE explicite de positions\n"
#~ "                      de tabulation\n"
#~ "                      séparées par des virgules\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#~ msgid ""
#~ "Wrap input lines in each FILE (standard input by default), writing to\n"
#~ "standard output.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --bytes         count bytes rather than columns\n"
#~ "  -s, --spaces        break at spaces\n"
#~ "  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ msgstr ""
#~ "Limiter la longueur de chaque ligne de chaque FICHIER (entrée standard "
#~ "par\n"
#~ "défaut) et forcer le bouclage en écrivant sur la sortie standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -b, --bytes         compter les octets au lieu des colonnes\n"
#~ "  -s, --spaces        briser la ligne sur des blancs\n"
#~ "  -w, --width=N       utiliser N colonnes au lieu de 80\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ msgstr ""
#~ "  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
#~ "                                  sur chaque page logique\n"
#~ "  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
#~ "                                  numéroter les lignes\n"
#~ "      --help                      afficher l'aide-mémoire\n"
#~ "      --version                   afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
#~ "CC se compose de deux caractères délimiteurs pour séparer les pages "
#~ "logiques\n"
#~ "un deuxième caractère manquant implique que:\n"
#~ "taper \\\\ pour  \\.  STYLE est une des options parmi:\n"

#~ msgid ""
#~ "Write lines consisting of the sequentially corresponding lines from\n"
#~ "each FILE, separated by TABs, to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
#~ "  -s, --serial            paste one file at a time instead of in "
#~ "parallel\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Coller séquentiellement les lignes correspondantes de chaque\n"
#~ "FICHIER, séparé par des tabulations, vers la sortie standard.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -d, --delimiters=LISTE  utiliser les caractères de la LISTE au lieu\n"
#~ "                          de tabulations\n"
#~ "  -s, --serial            copier un fichier à la fois au lieu de\n"
#~ "                          le faire en parallèle\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "  -NUMBER                 same as -l NUMBER\n"
#~ "      --verbose           print a diagnostic to standard error just\n"
#~ "                            before each output file is opened\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
#~ msgstr ""
#~ "  -NOMBRE                 identique à -l NOMBRE\n"
#~ "      --verbose           produire un diagnostic sur stderr\n"
#~ "                          avant que chaque fichier de sortie ne soit "
#~ "ouvert \n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "La TAILLE peut être suivie d'un suffixe multiplicateur:\n"
#~ "b pour 512, k pour 1K, m pour 1 Meg.\n"

#~ msgid ""
#~ "Write each FILE to standard output, last line first.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -b, --before             attach the separator before instead of after\n"
#~ msgstr ""
#~ "Écrire chaque FICHIER sur la sortie standard, la dernière ligne en "
#~ "premier.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -b, --before           placer le séparateur avant plutôt qu'après\n"

#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                           inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                           inaccessible later -- useful only with -f\n"
#~ msgstr ""
#~ "Imprimer les dernières %d lignes de chaque FICHIER sur la sortie "
#~ "standard.\n"
#~ "Avec plus d'un FICHIER, précéder chacun par une en-tête contenant le nom "
#~ "du\n"
#~ "fichier. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "\n"
#~ "      --retry              continuer de tenter d'ouvrir le fichier même "
#~ "s'il\n"
#~ "                           est inaccessible lorsque tail démarre ou s'il "
#~ "devient\n"
#~ "                           inaccessible plus tard -- utile seulement avec "
#~ "-f\n"

#~ msgid ""
#~ "  -v, --verbose            always output headers giving file names\n"
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"

#~ msgid ""
#~ "Convert spaces in each FILE to tabs, writing to standard output.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -a, --all           convert all whitespace, instead of initial "
#~ "whitespace\n"
#~ msgstr ""
#~ "Convertir les blancs d'espacement de chaque FICHIER par des tabulations,\n"
#~ "lors de l'écriture sur la sortie standard.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -a, --all           convertir tous les espaces blancs,\n"
#~ "                      au lieu du blanc d'espacement initial\n"

#~ msgid ""
#~ "  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
#~ "  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
#~ "      --help          display this help and exit\n"
#~ "      --version       output version information and exit\n"
#~ "\n"
#~ "Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
#~ msgstr ""
#~ "  -t, --tabs=N        utiliser N caractères de tabulation au lieu de 8\n"
#~ "  -t, --tabs=LISTE    utiliser la LISTE séparée de virgules comme "
#~ "positions\n"
#~ "                      explicite des tabulations\n"
#~ "      --help          afficher l'aide-mémoire\n"
#~ "      --version       afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Au lieu de -t NOMBRE ou -t LISTE, -NOMBRE ou -LISTE peuvent être "
#~ "utilisés.\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "  -c, --count           prefix lines by the number of occurrences\n"
#~ "  -d, --repeated        only print duplicate lines\n"
#~ msgstr ""
#~ "Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
#~ "(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
#~ "(ou vers la sortie standard).\n"
#~ "\n"
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "  -c, --count           préfixer les lignes par le nombre d'occurences\n"
#~ "  -d, --repeated        afficher seulement les lignes ayant des "
#~ "duplicatats\n"

#~ msgid "Copyright (C) 2001 Free Software Foundation, Inc."
#~ msgstr "Copyright © 2001 Free Software Foundation, Inc."

#~ msgid ""
#~ "Output pieces of FILE separated by PATTERN(s) to files `xx01', "
#~ "`xx02', ...,\n"
#~ "and output byte counts of each piece to standard output.\n"
#~ "\n"
#~ "  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
#~ "  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
#~ "  -k, --keep-files           do not remove output files on errors\n"
#~ "  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
#~ "  -s, --quiet, --silent      do not print counts of output file sizes\n"
#~ "  -z, --elide-empty-files    remove empty output files\n"
#~ "      --help                 display this help and exit\n"
#~ "      --version              output version information and exit\n"
#~ "\n"
#~ "Read standard input if FILE is -.  Each PATTERN may be:\n"
#~ "\n"
#~ "  INTEGER            copy up to but not including specified line number\n"
#~ "  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
#~ "  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
#~ "  {INTEGER}          repeat the previous pattern specified number of "
#~ "times\n"
#~ "  {*}                repeat the previous pattern as many times as "
#~ "possible\n"
#~ "\n"
#~ "A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
#~ msgstr ""
#~ "Afficher les segments d'un FICHIER séparées par PATRON(s) vers\n"
#~ "les fichiers `xx01', `xx02', ..., ainsi que le nombre\n"
#~ "d'octets de chaque segment vers la sortie standard.\n"
#~ "\n"
#~ "  -b, --suffix-format=FORMAT utiliser sprintf FORMAT au lieu de %%d\n"
#~ "  -f, --prefix=PRÉFIXE       utiliser le PRÉFIXE au lieu de `xx'\n"
#~ "  -k, --keep-files           ne pas détruire les fichiers \n"
#~ "                             lorsqu'il y erreur\n"
#~ "  -n, --digits=NOMBRE        utiliser NOMBRE de chiffres au lieu de 2\n"
#~ "  -s, --quiet, --silent      ne pas afficher la taille des fichiers\n"
#~ "                             de sortie\n"
#~ "  -z, --elide-empty-files    détruire les fichiers de sortie vides\n"
#~ "      --help                 afficher l'aide-mémoire\n"
#~ "      --version              afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Lire de l'entrée standard si le FICHIER est -.  Chaque PATRON peut être:\n"
#~ "\n"
#~ "  ENTIER             copier jusqu'à mais sans inclure le nombre "
#~ "spécifiée\n"
#~ "                     de lignes\n"
#~ "  /REGEXP/[SAUT]     copier jusqu'à la détection d'une ligne identique\n"
#~ "                     mais sans l'inclure\n"
#~ "  %%REGEXP%%[SAUT]     escamoter jusqu'à, mais sans inclure une\n"
#~ "                     ligne identique\n"
#~ "  {ENTIER}           répéter le patron précédent un nombre de fois\n"
#~ "  {*}                répéter le patron précédent le plus souvent "
#~ "possible\n"
#~ "\n"
#~ "Une ligne de SAUT a besoin d'un `+' ou `-' suivi d'un entier positif.\n"

#~ msgid ""
#~ "Print selected parts of lines from each FILE to standard output.\n"
#~ "\n"
#~ "  -b, --bytes=LIST        output only these bytes\n"
#~ "  -c, --characters=LIST   output only these characters\n"
#~ "  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
#~ "  -f, --fields=LIST       output only these fields;  also print any line\n"
#~ "                            that contains no delimiter character, unless\n"
#~ "                            the -s option is specified\n"
#~ "  -n                      (ignored)\n"
#~ "  -s, --only-delimited    do not print lines not containing delimiters\n"
#~ "      --output-delimiter=STRING  use STRING as the output delimiter\n"
#~ "                            the default is to use the input delimiter\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
#~ "range, or many ranges separated by commas.  Each range is one of:\n"
#~ "\n"
#~ "  N     N'th byte, character or field, counted from 1\n"
#~ "  N-    from N'th byte, character or field, to end of line\n"
#~ "  N-M   from N'th to M'th (included) byte, character or field\n"
#~ "  -M    from first to M'th (included) byte, character or field\n"
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ msgstr ""
#~ "Afficher des parties de lignes de chaque FICHIER vers la sortie "
#~ "standard.\n"
#~ "\n"
#~ "  -b, --bytes=LISTE       afficher seulement la LISTE des octets\n"
#~ "  -c, --characters=LISTE  afficher seulement la LISTE des caractères\n"
#~ "  -d, --delimiter=DÉLIM   utiliser le DÉLIMiteur au lieu d'une "
#~ "tabulation\n"
#~ "                          comme délimiteur de champs\n"
#~ "  -f, --fields=LISTE      afficher seulement la LISTE des champs\n"
#~ "  -n                      (ignoré)\n"
#~ "  -s, --only-delimited    ne pas afficher les lignes ne\n"
#~ "                          contenant pas de délimiteurs\n"
#~ "      --output-delimiter=CHAÎNE\n"
#~ "                          utiliser la CHAÎNE comme délimiteur de sortie\n"
#~ "                          par défaut le délimiteur de l'entrée est "
#~ "utilisée\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Utiliser une seule des options -b, -c ou -f.  Chaque LISTE se compose "
#~ "d'une\n"
#~ "intervalle, ou de plusieurs séparées par des virgules.  Chaque "
#~ "intervalle\n"
#~ "se compose de:\n"
#~ "\n"
#~ "  N     Nième octet, caractère ou champ, compté à partir de 1\n"
#~ "  N-    du Nième octet, caractère ou champ, jusqu'à la fin de la ligne\n"
#~ "  N-M   du Nième au Mième (inclus) octet, caractère ou champ\n"
#~ "  -M    du premier au Mième (inclus) octet, caractère ou champ\n"
#~ "\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard.\n"

#~ msgid ""
#~ "For each pair of input lines with identical join fields, write a line to\n"
#~ "standard output.  The default join field is the first, delimited\n"
#~ "by whitespace.  When FILE1 or FILE2 (not both) is -, read standard "
#~ "input.\n"
#~ "\n"
#~ "  -a SIDE           print unpairable lines coming from file SIDE\n"
#~ "  -e EMPTY          replace missing input fields with EMPTY\n"
#~ "  -i, --ignore-case ignore differences in case when comparing fields\n"
#~ "  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
#~ "  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
#~ "  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
#~ "  -o FORMAT         obey FORMAT while constructing output line\n"
#~ "  -t CHAR           use CHAR as input and output field separator\n"
#~ "  -v SIDE           like -a SIDE, but suppress joined output lines\n"
#~ "  -1 FIELD          join on this FIELD of file 1\n"
#~ "  -2 FIELD          join on this FIELD of file 2\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
#~ "else fields are separated by CHAR.  Any FIELD is a field number counted\n"
#~ "from 1.  FORMAT is one or more comma or blank separated specifications,\n"
#~ "each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
#~ "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
#~ "separated by CHAR.\n"
#~ msgstr ""
#~ "Pour chaque paire de lignes en entrée ayant un champ de fusion "
#~ "identique,\n"
#~ "écrire une ligne sur la sortie standard.\n"
#~ "Le champ de fusion est le premier, délimité par un blanc.\n"
#~ "Si FICHIER1 ou FICHIER2 (pas les 2) est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -a COTÉ           afficher les lignes non repérables venant du \n"
#~ "                    fichier COTÉ\n"
#~ "  -e VIDE           remplacer les champs d'entrée manquants par VIDE\n"
#~ "  -i, --ignore-case ignorer la casse des caractères lors de la\n"
#~ "                    comparaison des champs\n"
#~ "  -j CHAMP          option désuète équivalente à `-1 CHAMP -2 CHAMP'\n"
#~ "  -j1 CHAMP         option désuète équivalente à `-1 CHAMP'\n"
#~ "  -j2 CHAMP         option désuète équivalente à `-2 CHAMP'\n"
#~ "  -o FORMAT         respecter le FORMAT lors de la construction\n"
#~ "                    de sortie\n"
#~ "  -t CAR            utiliser CAR comme délimiteur de champs à l'entrée\n"
#~ "                    et à la sortie\n"
#~ "  -v COTÉ           comme -a COTÉ, mais supprimer les lignes\n"
#~ "                    de sortie fusionnées\n"
#~ "  -1 CHAMP          fusionner sur le champs CHAMP du fichier 1\n"
#~ "  -2 CHAMP          fusionner sur le champs CHAMP du fichier 2\n"
#~ "     --help         afficher l'aide-mémoire\n"
#~ "     --version      afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "À moins que -t CAR ne soit donné, les blancs de tête séparant\n"
#~ "les champs sont ignorés sinon les champs sont séparés par CAR.\n"
#~ "Chaque CHAMP est un champ compté numériquement à partir de 1.\n"
#~ "FORMAT est une spécification contenant une ou plusieurs virgules ou "
#~ "blancs\n"
#~ "chacune étant `COTÉ.CHAMP' ou `0'.  Par défaut FORMAT affiche des\n"
#~ "champs fusionnés,\n"
#~ "les champs restants de FICHIER1 ou FICHIER2 sont tous séparés par CAR.\n"

#~ msgid ""
#~ "Usage: %s [OPTION] [FILE]...\n"
#~ "  or:  %s [OPTION] --check [FILE]\n"
#~ "Print or check %s (%d-bit) checksums.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "  -b, --binary            read files in binary mode (default on DOS/"
#~ "Windows)\n"
#~ "  -c, --check             check %s sums against given list\n"
#~ "  -t, --text              read files in text mode (default)\n"
#~ "\n"
#~ "The following two options are useful only when verifying checksums:\n"
#~ "      --status            don't output anything, status code shows "
#~ "success\n"
#~ "  -w, --warn              warn about improperly formated checksum lines\n"
#~ "\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "\n"
#~ "The sums are computed as described in %s.  When checking, the input\n"
#~ "should be a former output of this program.  The default mode is to print\n"
#~ "a line with checksum, a character indicating type (`*' for binary, ` ' "
#~ "for\n"
#~ "text), and name for each FILE.\n"
#~ msgstr ""
#~ "Usage: %s [OPTION] [FICHIER]...\n"
#~ "  ou:  %s [OPTION] --check [FICHIER]\n"
#~ "Afficher ou vérifier les sommes de contrôle %s (%d-bits).\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -b, --binary            lire les fichiers en mode binaire \n"
#~ "                          (par défaut sous DOS/WIndows)\n"
#~ "  -c, --check             vérifier les sommes %s par rapport à la liste\n"
#~ "  -t, --text              lire les fichiers en mode texte (par défaut)\n"
#~ "\n"
#~ "Les deux options suivantes sont utiles seulement lors de la vérification\n"
#~ "des sommes de contrôle:\n"
#~ "      --status            ne rien afficher, sauf le constat\n"
#~ "                          de fin d'exécution\n"
#~ "  -w, --warn              avertir si les lignes de contrôle MD5\n"
#~ "                          sont mal formatées\n"
#~ "\n"
#~ "      --help              afficher l'aide-mémoire\n"
#~ "      --version           afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Les sommes sont calculées selon la description de %s.  Lors de la "
#~ "vérification,\n"
#~ "l'entrée devrait être formellement une sortie de ce programme.  Le mode "
#~ "par défaut\n"
#~ "est d'afficher la ligne avec la somme de contrôle, un caractère "
#~ "indiquant\n"
#~ "le type (`*' pour binaire, ` ' pour texte) et un nom pour chaque "
#~ "FICHIER.\n"

#~ msgid ""
#~ "Write each FILE to standard output, with line numbers added.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
#~ "  -d, --section-delimiter=CC      use CC for separating logical pages\n"
#~ "  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
#~ "  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
#~ "  -i, --page-increment=NUMBER     line number increment at each line\n"
#~ "  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
#~ "one\n"
#~ "  -n, --number-format=FORMAT      insert line numbers according to "
#~ "FORMAT\n"
#~ "  -p, --no-renumber               do not reset line numbers at logical "
#~ "pages\n"
#~ "  -s, --number-separator=STRING   add STRING after (possible) line "
#~ "number\n"
#~ "  -v, --first-page=NUMBER         first line number on each logical page\n"
#~ "  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
#~ "      --help                      display this help and exit\n"
#~ "      --version                   output version information and exit\n"
#~ "\n"
#~ "By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
#~ "two delimiter characters for separating logical pages, a missing\n"
#~ "second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
#~ "\n"
#~ "  a         number all lines\n"
#~ "  t         number only nonempty lines\n"
#~ "  n         number no lines\n"
#~ "  pREGEXP   number only lines that contain a match for REGEXP\n"
#~ "\n"
#~ "FORMAT is one of:\n"
#~ "\n"
#~ "  ln   left justified, no leading zeros\n"
#~ "  rn   right justified, no leading zeros\n"
#~ "  rz   right justified, leading zeros\n"
#~ "\n"
#~ msgstr ""
#~ "Afficher chaque FICHIER sur la sortie standard, avec numéros de ligne.\n"
#~ "Sans FICHIER, ou FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -b, --body-numbering=STYLE      utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "  -d, --section-delimiter=CC      utiliser CC pour séparer les pages\n"
#~ "                                  logiques\n"
#~ "  -f, --footer-numbering=STYLE    utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "                                  de bas de page\n"
#~ "  -h, --header-numbering=STYLE    utiliser STYLE pour numéroter les "
#~ "lignes\n"
#~ "                                  d'en-tête\n"
#~ "  -i, --page-increment=N          incrémenter de N de lignes à chaque "
#~ "ligne\n"
#~ "  -l, --join-blank-lines=N        regrouper N de lignes vides\n"
#~ "                                  en une seule ligne\n"
#~ "  -n, --number-format=FORMAT      insérer un numéro de ligne selon "
#~ "FORMAT\n"
#~ "  -p, --no-renumber               ne pas réinitialiser le nombre de "
#~ "lignes\n"
#~ "                                  aux pages logiques\n"
#~ "  -s, --number-separator=CHAÎNE   ajouter la CHAÎNE après (si possible)\n"
#~ "                                  le numéro de ligne\n"
#~ "  -v, --first-page=NUMÉRO         utiliser comme premier NUMÉRO de ligne\n"
#~ "                                  sur chaque page logique\n"
#~ "  -w, --number-width=N            utiliser le NOMBRE de colonnes pour\n"
#~ "                                  numéroter les lignes\n"
#~ "      --help                      afficher l'aide-mémoire\n"
#~ "      --version                   afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Par défaut, -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn sont sélectionnées.\n"
#~ "CC se compose de deux caractères délimiteurs pour séparer les pages "
#~ "logiques\n"
#~ "un deuxième caractère manquant implique que:\n"
#~ "taper \\\\ pour  \\.  STYLE est une des options parmi:\n"
#~ "\n"
#~ "  a         numéroter toutes les lignes\n"
#~ "  t         numéroter seulement les lignes non vides\n"
#~ "  n         numéroter n lignes\n"
#~ "  pEXPREG   numéroter seulement les lignes ayant une concordance à "
#~ "EXPREG\n"
#~ "\n"
#~ "FORMAT doit être choisi parmi:\n"
#~ "\n"
#~ "  ln   justifié à gauche, sans zéro de préfixe\n"
#~ "  rn   justifié à droite, sans zéro de préfixe\n"
#~ "  rz   justifié à droite, avec zéros de préfixe\n"
#~ "\n"

#~ msgid ""
#~ "Write an unambiguous representation, octal bytes by default, of FILE\n"
#~ "to standard output.  With no FILE, or when FILE is -, read standard "
#~ "input.\n"
#~ "\n"
#~ "  -A, --address-radix=RADIX   decide how file offsets are printed\n"
#~ "  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n"
#~ "  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n"
#~ "  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
#~ "chars\n"
#~ "  -t, --format=TYPE           select output format or formats\n"
#~ "  -v, --output-duplicates     do not use * to mark line suppression\n"
#~ "  -w, --width[=BYTES]         output BYTES bytes per output line\n"
#~ "      --traditional           accept arguments in pre-POSIX form\n"
#~ "      --help                  display this help and exit\n"
#~ "      --version               output version information and exit\n"
#~ "\n"
#~ "Pre-POSIX format specifications may be intermixed, they accumulate:\n"
#~ "  -a   same as -t a,  select named characters\n"
#~ "  -b   same as -t oC, select octal bytes\n"
#~ "  -c   same as -t c,  select ASCII characters or backslash escapes\n"
#~ "  -d   same as -t u2, select unsigned decimal shorts\n"
#~ "  -f   same as -t fF, select floats\n"
#~ "  -h   same as -t x2, select hexadecimal shorts\n"
#~ "  -i   same as -t d2, select decimal shorts\n"
#~ "  -l   same as -t d4, select decimal longs\n"
#~ "  -o   same as -t o2, select octal shorts\n"
#~ "  -x   same as -t x2, select hexadecimal shorts\n"
#~ msgstr ""
#~ "Afficher le contenu du FICHIER selon une représentation non ambiguë\n"
#~ "par un affichage des octets en octal par défaut sur la sortie standard.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
#~ "\n"
#~ "  -A, --address-radix=BASE    afficher les octets selon un adressage\n"
#~ "                              relatif dans la BASE sélectionnée\n"
#~ "  -j, --skip-bytes=N          escamoter les N premiers octets de chaque\n"
#~ "                              fichier\n"
#~ "  -N, --read-bytes=N          limiter à N le nombre d'octets lus par\n"
#~ "                              fichier\n"
#~ "  -s, --strings[=N]           afficher la chaîne d'au moins N caractères\n"
#~ "                              graphiques\n"
#~ "  -t, --format=TYPE           sélectionner les formats de sortie\n"
#~ "  -v, --output-duplicates     ne pas utiliser * pour marquer la\n"
#~ "                              suppression de ligne\n"
#~ "  -w, --width[=N]             afficher N octets par ligne de sortie\n"
#~ "      --traditional           accepter les arguments de la forme pré-"
#~ "POSIX\n"
#~ "      --help                  afficher l'aide-mémore et quitter\n"
#~ "      --version               afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Les spécifications de format pré-POSIX peuvent être entremêlées,\n"
#~ "ils sont alors cumulées:\n"
#~ "  -a   identique à -t a,    identifier les caractères\n"
#~ "  -b   identique à -t oC,   identifier les octets en octal\n"
#~ "  -c   identique à -t c,    identifier les caractères ASCII ou\n"
#~ "                            la barre oblique inverse\n"
#~ "  -d   identique à -t u2,   identifier en entier court non signé\n"
#~ "  -f   identique à -t fF,   identifier en nombre flottant\n"
#~ "  -h   identique à -t x2,   identifier en hexadécimal court\n"
#~ "  -i   identique à -t d2,   identifier en décimal court\n"
#~ "  -l   identique à -t d4,   identifier en décimal long\n"
#~ "  -o   identique à -t o2,   identifier en octal court\n"
#~ "  -x   identique à -t x2,   identifier en hexadécimal court\n"

#~ msgid ""
#~ "\n"
#~ "For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
#~ "is the pseudo-address at first byte printed, incremented when dump is\n"
#~ "progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
#~ "hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
#~ "\n"
#~ "TYPE is made up of one or more of these specifications:\n"
#~ "\n"
#~ "  a          named character\n"
#~ "  c          ASCII character or backslash escape\n"
#~ "  d[SIZE]    signed decimal, SIZE bytes per integer\n"
#~ "  f[SIZE]    floating point, SIZE bytes per integer\n"
#~ "  o[SIZE]    octal, SIZE bytes per integer\n"
#~ "  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
#~ "  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
#~ "\n"
#~ "SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
#~ "sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
#~ "sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
#~ "for sizeof(double) or L for sizeof(long double).\n"
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
#~ "with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix "
#~ "to\n"
#~ "any type adds a display of printable characters to the end of each line\n"
#~ "of output.  -s without a number implies 3.  -w without a number implies "
#~ "32.\n"
#~ "By default, od uses -A o -t d2 -w 16.\n"
#~ msgstr ""
#~ "\n"
#~ "Pour respecter une vieille syntaxe (deuxième format d'appel), SAUT\n"
#~ "signifie -j SAUT.  ÉTIQUETTE est une pseudo adresse du premier octet "
#~ "imprimé\n"
#~ "incrémentée lorsque la vidange s'effectue.  Pour le SAUT et l'ÉTIQUETTE, "
#~ "un\n"
#~ "préfixe 0x ou 0X indique un format hexadécimal,  les suffixes peuvent\n"
#~ "être . pour l'octal et b pour un multiple de 512 octets.\n"
#~ "\n"
#~ "Le TYPE est composé d'une ou plusieurs spécifications suivantes:\n"
#~ "\n"
#~ "  a          identification des caractères\n"
#~ "  c          caractère ASCII ou barre oblique inverse\n"
#~ "  d[N]       décimal signé, N octets par entier\n"
#~ "  f[N]       point flottant, N octets par entier\n"
#~ "  o[N]       octal, N octets par entier\n"
#~ "  u[N]       décimal non signé N octets par entier\n"
#~ "  x[N]       hexadécimal, N octets par entier\n"
#~ "\n"
#~ "N est un nombre.  Le TYPE est soit d, o, u ou x, N peut être aussi C "
#~ "pour\n"
#~ "sizeof(char), S pour sizeof(short), I pour sizeof(int) ou L pour\n"
#~ "sizeof(long).  Si le TYPE est f, N peut aussi être F pour sizeof(float), "
#~ "D\n"
#~ "pour sizeof(double) ou L pour sizeof(long double).\n"
#~ "\n"
#~ "BASE est d pour décimal, o pour octal, x pour hexadécimal ou n pour "
#~ "aucun.\n"
#~ "OCTETS est de type hexadécimal si préfixé par 0x ou 0X, et est un "
#~ "multiple de\n"
#~ "512 avec le suffixe b, de 1024 avec k et de 1048576 avec m.\n"
#~ "-s non suivi d un nombre implique 3,  32 pour -w.\n"
#~ "Par défaut, od utilise -A o -t d2 -w 16.\n"

#~ msgid ""
#~ "Paginate or columnate FILE(s) for printing.\n"
#~ "\n"
#~ "  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
#~ "                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
#~ "  -COLUMN, --columns=COLUMN\n"
#~ "                    produce COLUMN-column output and print columns down,\n"
#~ "                    unless -a is used. Balance number of lines in the\n"
#~ "                    columns on each page.\n"
#~ "  -a, --across      print columns across rather than down, used together\n"
#~ "                    with -COLUMN\n"
#~ "  -c, --show-control-chars\n"
#~ "                    use hat notation (^G) and octal backslash notation\n"
#~ "  -d, --double-space\n"
#~ "                    double space the output\n"
#~ "  -D, --date-format=FORMAT\n"
#~ "                    use FORMAT for the header date\n"
#~ "  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
#~ "                    expand input CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -F, -f, --form-feed\n"
#~ "                    use form feeds instead of newlines to separate pages\n"
#~ "                    (by a 3-line page header with -F or a 5-line header\n"
#~ "                    and trailer without -F)\n"
#~ msgstr ""
#~ "Paginer ou mettre en colonne les FICHIERS pour impression.\n"
#~ "\n"
#~ "  +PREMIÈRE_PAGE[:DERNIÈRE_PAGE], \n"
#~ "      --pages=PREMIÈRE_PAGE[:DERNIÈRE_PAGE]\n"
#~ "                       débuter [stopper] l'impression à la PREMIÈRE_PAGE\n"
#~ "                       ou à la DERNIÈRE_PAGE\n"
#~ "  -COLUMN\n"
#~ "      --columns=COLUMN\n"
#~ "                       produire une sortie en COLONNES et imprimer les\n"
#~ "                       les colonnes vers le bas à moins que -a ne soit\n"
#~ "                       utilisé.  Équilibrer le nombre de lignes de "
#~ "chaque\n"
#~ "                       colonne sur chaque page.\n"
#~ "  -a, --across         imprimer les colonnes horizontalement au lieu de\n"
#~ "                       verticalement, utilisé ensemble avec -COLUMN\n"
#~ "  -c, --show-control-chars\n"
#~ "                       utiliser une notation par chapeau (^G) et octale\n"
#~ "                       avec barre oblique inverse\n"
#~ "  -d, --double-space\n"
#~ "                       produire une sortie avec double espacement\n"
#~ "  -e[CAR[LARGEUR]], --expand-tabs[=CAR[LARGEUR]]\n"
#~ "                       faire l'expansion des CARactères (ou de "
#~ "tabulation)\n"
#~ "                       selon la LARGEUR de tabulation (par défaut 8)\n"
#~ "  -F, -f,\n"
#~ "      --form-feed\n"
#~ "                       utiliser des sauts de page au lieu des sauts de \n"
#~ "                       lignes pour séparer les pages (3 lignes par en-"
#~ "tête\n"
#~ "                       avec -f ou 5 lignes par en-tête et bas de page "
#~ "sans -f) \n"

#~ msgid ""
#~ "  -h HEADER, --header=HEADER\n"
#~ "                    use a centered HEADER instead of filename in page "
#~ "header,\n"
#~ "                    -h \"\" prints a blank line, don't use -h\"\"\n"
#~ "  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
#~ "                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -J, --join-lines  merge full lines, turns off -W line truncation, no "
#~ "column\n"
#~ "                    alignment, -S[STRING] sets separators\n"
#~ "  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
#~ "                    set the page length to PAGE_LENGTH (66) lines\n"
#~ "                    (default number of lines of text 56, and with -F 63)\n"
#~ "  -m, --merge       print all files in parallel, one in each column,\n"
#~ "                    truncate lines, but join lines of full length with -"
#~ "J\n"
#~ "  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
#~ "                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
#~ "                    default counting starts with 1st line of input file\n"
#~ "  -N NUMBER, --first-line-number=NUMBER\n"
#~ "                    start counting with NUMBER at 1st line of first\n"
#~ "                    page printed (see +FIRST_PAGE)\n"
#~ "  -o MARGIN, --indent=MARGIN\n"
#~ "                    offset each line with MARGIN (zero) spaces, do not\n"
#~ "                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
#~ "  -r, --no-file-warnings\n"
#~ "                    omit warning when a file cannot be opened\n"
#~ msgstr ""
#~ "  -h EN-TÊTE, --header=EN-TÊTE\n"
#~ "                       centrer l'EN-TÊTE au lieu du nom de fichier dans\n"
#~ "                       l'en-tête de la page, avec de longues en-têtes\n"
#~ "                       une troncation du côté gauche peut survenir\n"
#~ "                        -h \\\"\\\" imprime une ligne blanche.\n"
#~ "                       Ne pas utiliser:  -h\\\"\\\"\\n\"\n"
#~ "  -i, --output-tabs[=CAR[LARGEUR]]\n"
#~ "                       remplacer les blancs par des CARactères (ou\n"
#~ "                       de tabulation) selon la LARGEUR de tabulation (8)\n"
#~ "  -J, --join-lines\n"
#~ "                       faire la fusion des lignes pleines, inhiber la \n"
#~ "                       troncation des lignes -w, sans alignement des\n"
#~ "                       colonnes -s[CHAÎNE] initialise les séparateurs\n"
#~ "  -l LONGUEUR_DE_PAGE, --length LONGUEUR_DE_PAGE\n"
#~ "                       utiliser LONGUEUR_DE_PAGE au lieu de 66 lignes\n"
#~ "                       (par défaut de lignes est de 56 pour un texte,\n"
#~ "                       avec -f de 63)\n"
#~ "  -m, --merge          imprimer tous les fichiers en parallèle un par\n"
#~ "                       colonne, tronque les lignes, mais joint les\n"
#~ "                       lignes de pleine longueur avec -j\n"
#~ "  -n, --number-lines[=SÉP[CHIFFRES]]\n"
#~ "                       numéroter les lignes, par des CHIFFRES (5), suivi "
#~ "de\n"
#~ "                       SÉParateurs (TAB) par défaut le compteur débute\n"
#~ "                       avec la première ligne du fichier d'entrée\n"
#~ "  -N, --first-line-number=VALEUR\n"
#~ "                       débuter le compteur avec la VALEUR avec la 1ère "
#~ "ligne\n"
#~ "                       de la 1ère page imprimée (voir +PREMIÈRE_PAGE)\n"
#~ "  -o, --indent=MARGE\n"
#~ "                       débuter l'impression de chaque ligne après une\n"
#~ "                       MARGE d'espacement  (n'affecte pas -w)\n"
#~ "  -r, --no-file-warnings\n"
#~ "                       inhiber les avertissements lorsqu'un fichier\n"
#~ "                       ne peut être ouvert\n"

#~ msgid ""
#~ "  -s[CHAR],--separator[=CHAR]\n"
#~ "                    separate columns by a single character, default for "
#~ "CHAR\n"
#~ "                    is the <TAB> character without -w and 'no char' with -"
#~ "w\n"
#~ "                    -s[CHAR] turns off line truncation of all 3 column\n"
#~ "                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
#~ "  -S[STRING], --sep-string[=STRING]\n"
#~ "                    separate columns by an optional STRING, don't use\n"
#~ "                    -S \"STRING\", -S only: No separator used (same as -S"
#~ "\"\"),\n"
#~ "                    without -S: Default separator <TAB> with -J and "
#~ "<space>\n"
#~ "                    otherwise (same as -S\" \"), no effect on column "
#~ "options\n"
#~ "  -t, --omit-header omit page headers and trailers\n"
#~ "  -T, --omit-pagination\n"
#~ "                    omit page headers and trailers, eliminate any "
#~ "pagination\n"
#~ "                    by form feeds set in input files\n"
#~ "  -v, --show-nonprinting\n"
#~ "                    use octal backslash notation\n"
#~ "  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters for\n"
#~ "                    multiple text-column output only, -s[char] turns off "
#~ "(72)\n"
#~ "  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
#~ "                    set page width to PAGE_WIDTH (72) characters always,\n"
#~ "                    truncate lines, except -J option is set, no "
#~ "interference\n"
#~ "                    with -S or -s\n"
#~ "  --help            display this help and exit\n"
#~ "  --version         output version information and exit\n"
#~ "\n"
#~ "-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
#~ "FILE is -, read standard input.\n"
#~ msgstr ""
#~ "  -s, --separator[=CHAÎNE]\n"
#~ "                       séparer les colonnes à l'aide d'une CHAÎNE "
#~ "optionnelle\n"
#~ "                       optionnelle, ne pas utiliser -s \\\"CHAÎNE\\\"\n"
#~ "                       sans -s utilise le séparateur (par défaut un "
#~ "blanc)\n"
#~ "                       identique à -s\\\" \\\"; -s seulement: aucun \n"
#~ "                       séparateur n'est utilisé, identique à  -s\\\"\\\"\n"
#~ "  -S[CHAÎNE],\n"
#~ "      --sep-string[=CHAÎNE]\n"
#~ "                       séparer les colonnes à l'aide d'une chaîne "
#~ "optionnelle\n"
#~ "                       ne pas utiliser -S \"CHAÎNE\", -S seulement: "
#~ "SANS \n"
#~ "                       utiliser de séparateur (identique à -S\"\"),\n"
#~ "                       sans -S: séparateur par défaut <TAB> avec -J et "
#~ "<space>\n"
#~ "                       autrement (identique as -S\" \"), sans effet sur "
#~ "les options\n"
#~ "                       des colonnes\n"
#~ "  -t, --omit-header\n"
#~ "                      inhiber l'en-tête et le bas de page\n"
#~ "  -T, --omit-pagination\n"
#~ "                       inhiber l'en-tête et le bas de page, éliminer\n"
#~ "                       les agencements de page par saut de page indiqués\n"
#~ "                       dans les fichiers d'entrée\n"
#~ "  -v, --show-nonprinting\n"
#~ "                       utiliser la notation octale avec barre oblique\n"
#~ "                       inverse\n"
#~ "  -w LARGEUR_DE_PAGE,\n"
#~ "      --width=LARGEUR_DE_PAGE\n"
#~ "                       utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\\n"
#~ "\"\n"
#~ "                       tronquer les lignes (voir aussi l'option -j)\n"
#~ "  -W LARGEUR_DE_PAGE,\n"
#~ "       --page-width=LARGEUR_DE_PAGE\n"
#~ "                       toujours utiliser une LARGEUR_DE_PAGE de 72 "
#~ "caractères,\n"
#~ "                       tronquer les lignes, sauf lorsque l'option -J est "
#~ "utilisée\n"
#~ "                       sans interférence avec -S ou -s\n"
#~ "      --help           afficher l'aide-mémore et quitter\n"
#~ "      --version        afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "L'option -T est implicite lorsque -l N est utilisée et avec -f quand nn "
#~ "<= 10\n"
#~ "ou <= 3. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"

#~ msgid ""
#~ "Mandatory arguments to long options are mandatory for short options too.\n"
#~ "\n"
#~ "  -A, --auto-reference           output automatically generated "
#~ "references\n"
#~ "  -C, --copyright                display Copyright and copying "
#~ "conditions\n"
#~ "  -G, --traditional              behave more like System V `ptx'\n"
#~ "  -F, --flag-truncation=STRING   use STRING for flagging line "
#~ "truncations\n"
#~ "  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
#~ "  -O, --format=roff              generate output as roff directives\n"
#~ "  -R, --right-side-refs          put references at right, not counted in -"
#~ "w\n"
#~ "  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
#~ "  -T, --format=tex               generate output as TeX directives\n"
#~ "  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
#~ "  -b, --break-file=FILE          word break characters in this FILE\n"
#~ "  -f, --ignore-case              fold lower case to upper case for "
#~ "sorting\n"
#~ "  -g, --gap-size=NUMBER          gap size in columns between output "
#~ "fields\n"
#~ "  -i, --ignore-file=FILE         read ignore word list from FILE\n"
#~ "  -o, --only-file=FILE           read only word list from this FILE\n"
#~ "  -r, --references               first field of each line is a reference\n"
#~ "  -t, --typeset-mode               - not implemented -\n"
#~ "  -w, --width=NUMBER             output width in columns, reference "
#~ "excluded\n"
#~ "      --help                     display this help and exit\n"
#~ "      --version                  output version information and exit\n"
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
#~ msgstr ""
#~ "Les arguments obligatoires pour les options de formes longues le sont "
#~ "aussi\n"
#~ "pour les options de formes courtes.\n"
#~ "\n"
#~ "  -A, --auto-reference           générer des références automatiquement\n"
#~ "  -C, --copyright                afficher les Droits d'auteur et les "
#~ "conditions\n"
#~ "                                 de recopie\n"
#~ "  -G, --traditional              faire fonctionner `ptx' comme en System "
#~ "V\n"
#~ "  -F, --flag-truncation=CHAÎNE   utiliser la CHAÎNE pour indiquer la "
#~ "troncation\n"
#~ "                                 des lignes\n"
#~ "  -M, --macro-name=CHAÎNE        nom de la macro à utiliser au lieu de "
#~ "`xx'\n"
#~ "  -O, --format=roff              générer la sortie comme des directives "
#~ "roff\n"
#~ "  -R, --right-side-refs          placer les références à droite, sans "
#~ "décompte -w\n"
#~ "  -S, --sentence-regexp=REGEXP   pour la fin des lignes ou des phrases\n"
#~ "  -T, --format=tex               générer la sortie comme des directives "
#~ "TeX\n"
#~ "  -W, --word-regexp=REGEXP       utiliser REGEXP pour établir la "
#~ "concordance avec chaque mot\n"
#~ "  -b, --break-file=FICHIER       utiliser les coupures de mots de ce "
#~ "FICHIER\n"
#~ "  -f, --ignore-case              ramener les minuscules en majuscules "
#~ "pour le trie\n"
#~ "  -g, --gap-size=N               espacer de N blancs les colonnes entre "
#~ "les champs\n"
#~ "  -i, --ignore-file=FICHIER      lire la liste des mots à ignorer de ce "
#~ "FICHIER\n"
#~ "  -o, --only-file=FICHIER        lire la liste des mots uniquement de ce "
#~ "FICHIER\n"
#~ "  -r, --references               donner la référence du 1er champ de "
#~ "chaque ligne\n"
#~ "  -t, --typeset-mode               - option non implanté -\n"
#~ "  -w, --width=N                  largeur des colonnes, références "
#~ "exclues\n"
#~ "      --help                     afficher l'aide-mémoire\n"
#~ "      --version                  afficher le nom et la version du "
#~ "logiciel\n"
#~ "\n"
#~ "Sans FICHIER, ou quand le FICHIER est -, lire de l'entrée standard. -F "
#~ "par défaut.\n"

#~ msgid ""
#~ "Other options:\n"
#~ "\n"
#~ "  -c, --check               check whether input is sorted; do not sort\n"
#~ "  -k, --key=POS1[,POS2]     start a key at POS1, end it at POS 2 (origin "
#~ "1)\n"
#~ "  -m, --merge               merge already sorted files; do not sort\n"
#~ "  -o, --output=FILE         write result to FILE instead of standard "
#~ "output\n"
#~ "  -s, --stable              stabilize sort by disabling last-resort "
#~ "comparison\n"
#~ "  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
#~ "  -t, --field-separator=SEP use SEP instead of non- to whitespace "
#~ "transition\n"
#~ "  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %"
#~ "s\n"
#~ "                              multiple options specify multiple "
#~ "directories\n"
#~ "  -u, --unique              with -c: check for strict ordering\n"
#~ "                              otherwise: output only the first of an "
#~ "equal run\n"
#~ "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
#~ "  +POS1 [-POS2]             start a key at POS1, end it before POS2 "
#~ "(origin 0)\n"
#~ "                              Warning: this option is obsolescent\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Autres options:\n"
#~ "\n"
#~ "  -c, --check               vérifier si l'entrée est triée; ne pas trier\n"
#~ "  -k, --key=POS1[,POS2]     débuter avec la clé à la POS1, terminer à POS "
#~ "2 (origine 1)\n"
#~ "  -m, --merge               faire la fusion des fichiers déjà triés; ne "
#~ "pas trier\n"
#~ "  -o, --output=FICHIER      écrire le résultat au FICHIER au lieu de la "
#~ "sortie standard\n"
#~ "  -s, --stable              stabiliser le tri en inhibant la comparaison "
#~ "de dernier recours\n"
#~ "  -S, --buffer-size=TAILLE  utiliser la TAILLE pour le tampon mémoire "
#~ "principal\n"
#~ "  -t, --field-separator=SEP utiliser le SÉParateur au lieu de non- par "
#~ "les transitions d'espace blancs\n"
#~ "  -T, --temporary-directory=RÉP utiliser le RÉP pour les fichiers "
#~ "temporaires, pas $TMPDIR ou %s\n"
#~ "                            options multiples pour spécifier de multiples "
#~ "répertoires\n"
#~ "  -u, --unique              avec -c: vérifier l'ordonnancement strict\n"
#~ "                            autrement: afficher les premiers d'une passe "
#~ "équivalente\n"
#~ "  -z, --zero-terminated     terminer les lignes avec l'octet 0, pas par "
#~ "le retour de chariot\n"
#~ "  +POS1 [-POS2]             débuter avec la clé à POS1, terminer  avant "
#~ "POS2 (origin 0)\n"
#~ "                            AVERTISSEMENT: cette option est désuète\n"
#~ "      --help                afficher l'aide-mémoire\n"
#~ "      --version             afficher le nom et la version du logiciel\n"
#~ "\n"

#~ msgid ""
#~ "Print the last %d lines of each FILE to standard output.\n"
#~ "With more than one FILE, precede each with a header giving the file "
#~ "name.\n"
#~ "With no FILE, or when FILE is -, read standard input.\n"
#~ "\n"
#~ "      --retry              keep trying to open a file even if it is\n"
#~ "                             inaccessible when tail starts or if it "
#~ "becomes\n"
#~ "                             inaccessible later -- useful only with -f\n"
#~ "  -c, --bytes=N            output the last N bytes\n"
#~ "  -f, --follow[={name|descriptor}] output appended data as the file "
#~ "grows;\n"
#~ "                             -f, --follow, and --follow=descriptor are\n"
#~ "                             equivalent\n"
#~ "  -n, --lines=N            output the last N lines, instead of the last %"
#~ "d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           with --follow=name, reopen a FILE which has "
#~ "not\n"
#~ "                             changed size after N (default %d) "
#~ "iterations\n"
#~ "                             to see if it has been unlinked or renamed\n"
#~ "                             (this is the usual case of rotated log "
#~ "files)\n"
#~ "      --pid=PID            with -f, terminate after process ID, PID dies\n"
#~ "  -q, --quiet, --silent    never output headers giving file names\n"
#~ "  -s, --sleep-interval=S   with -f, each iteration lasts approximately S\n"
#~ "                             (default 1) seconds\n"
#~ "  -v, --verbose            always output headers giving file names\n"
#~ "      --help               display this help and exit\n"
#~ "      --version            output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Imprimer les dernières %d lignes de chaque FICHIER sur la sortie "
#~ "standard.\n"
#~ "Avec plus d'un FICHIER, précéder chacun par une en-tête contenant le nom "
#~ "du\n"
#~ "fichier. Sans FICHIER, ou quand FICHIER est -, lire de l'entrée "
#~ "standard.\n"
#~ "\n"
#~ "      --retry              continuer de tenter d'ouvrir le fichier même "
#~ "s'il\n"
#~ "                           est inaccessible lorsque tail démarre ou s'il "
#~ "devient\n"
#~ "                           inaccessible plus tard -- utile seulement avec "
#~ "-f\n"
#~ "  -c, --bytes=N            afficher les N derniers octets \n"
#~ "  -f, --follow[={nom|descripteur}]\n"
#~ "                           afficher les dernières données ajoutées tant\n"
#~ "                           que le fichier s'accroît; -f, --follow, et\n"
#~ "                           --follow=descripteur sont équivalents\n"
#~ "  -n, --lines=N            afficher les dernières N lignes, au lieu des %"
#~ "d\n"
#~ "      --max-unchanged-stats=N\n"
#~ "                           voir la documentation de texinfo\n"
#~ "                           (le défaut est %d)\n"
#~ "      --pid=PID            avec -f, terminer après le processus ID, PID "
#~ "est arrêté\n"
#~ "  -q, --quiet, --silent    ne jamais afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "  -s, --sleep-interval=S   avec -f, attendre S secondes entre les "
#~ "itérations\n"
#~ "  -v, --verbose            toujours afficher l'en-tête avec\n"
#~ "                           les noms de fichiers\n"
#~ "      --help               afficher l'aide-mémoire\n"
#~ "      --version            afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Si le premier caractère de N (le nombre d octets ou lignes) est un `+',\n"
#~ "afficher à partir du Nième item depuis le début de chaque fichier,\n"
#~ "autrement, afficher les derniers N items dans le fichier.\n"
#~ "N peut comporter un suffixe de multiple:\n"
#~ "b pour 512, k pour 1024, m pour 1048576 (1 Meg).  Une première OPTION "
#~ "avec\n"
#~ "-VALEUR ou +VALEUR est traitée comme -n VALEUR ou -n + VALEUR\n"
#~ "à moins que VALEUR ait un suffixe multiplicateur [bkm],\n"
#~ "dans ce cas il est traité comme -c VALEUR ou -c +VALEUR.\n"
#~ "Option à décrire par le mainteneur: option non décrite en original.\n"
#~ "\n"
#~ "Avec l'option --follow (-f), tail utilise par défaut le descripteur de "
#~ "fichier\n"
#~ "qui permet de suivre l'évolution du fichier ciblé. Ce comportement n'est "
#~ "pas\n"
#~ "désirable lorsqu'on désire suivre l'évolution d'un fichier à l'aide de "
#~ "son\n"
#~ "nom (lors de la rotation des journaux). Utiliser --follow=nom dans ce "
#~ "cas.\n"
#~ "Cela forcera tail à suivre l'évolution du fichier en l'ouvrant "
#~ "périodiquement\n"
#~ "afin de vérifier s'il a été détruit ou recréé par un autre programme.\n"
#~ "\n"

#~ msgid ""
#~ "If the first character of N (the number of bytes or lines) is a `+',\n"
#~ "print beginning with the Nth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last N items in the file.  N may have a multiplier suffix:\n"
#~ "b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
#~ "or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
#~ "the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
#~ "or -c +VALUE.  Warning: a first option of +VALUE is obsolescent, and "
#~ "support\n"
#~ "for it will be withdrawn.\n"
#~ "\n"
#~ "With --follow (-f), tail defaults to following the file descriptor, "
#~ "which\n"
#~ "means that even if a tail'ed file is renamed, tail will continue to "
#~ "track\n"
#~ "its end.  This default behavior is not desirable when you really want to\n"
#~ "track the actual name of the file, not the file descriptor (e.g., log\n"
#~ "rotation).  Use --follow=name in that case.  That causes tail to track "
#~ "the\n"
#~ "named file by reopening it periodically to see if it has been removed "
#~ "and\n"
#~ "recreated by some other program.\n"
#~ "\n"
#~ msgstr ""
#~ "Si le premier caractère de N (le nombre d'octets ou de lignes) est `+',\n"
#~ "afficher le Nième item depuis le début de chaque fichier, autrement,\n"
#~ "afficher les derniers N items du fichier.  N peut avoir un suffixe "
#~ "multiplicateur:\n"
#~ "b pour 512, k pour 1024, m pour 1048576 (1 Meg).  Une 1è OPTION ayant -"
#~ "VALEUR\n"
#~ "ou +VALEUR est traitée comme -n VALEUR ou -n +VALEUR à moins que VALEUR "
#~ "ait un des\n"
#~ "suffixes multiplicateurs suivants [bkm], dans ce cas il est traité comme -"
#~ "c VALEUR\n"
#~ "ou -c +VALEUR.  AVERTISSEMENT: une 1ère option ayant la forme +VALEUR est "
#~ "désuète,\n"
#~ "dont le support ne sera plus disponible.\n"
#~ "\n"
#~ "Avec --follow (-f), suivre par défaut le descripteur de fichier, lequel\n"
#~ "signifie que même si le fichier est renommé alors qu'il est suivi à "
#~ "l'aide d'un `tail'\n"
#~ "le suivi sera poursuivi. Ce comportement par défaut n'est pas "
#~ "souhaitable\n"
#~ "lorsqu'on désire suivre un fichier à l'aide de son nom, pas le "
#~ "descripteur de fichier\n"
#~ "(i.e., rotation de journal).  Utiliser --follow=nom dans ce cas.  Cela "
#~ "amène `tail'\n"
#~ "à suivre le fichier en le réouvrant de façon périodique afin de voir s'il "
#~ "a été\n"
#~ "renommé ou détruit par un autre programme.\n"
#~ "\n"

#~ msgid ""
#~ "\n"
#~ "SETs are specified as strings of characters.  Most represent themselves.\n"
#~ "Interpreted sequences are:\n"
#~ "\n"
#~ "  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
#~ "  \\\\              backslash\n"
#~ "  \\a              audible BEL\n"
#~ "  \\b              backspace\n"
#~ "  \\f              form feed\n"
#~ "  \\n              new line\n"
#~ "  \\r              return\n"
#~ "  \\t              horizontal tab\n"
#~ "  \\v              vertical tab\n"
#~ "  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
#~ "  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
#~ "  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
#~ "  [:alnum:]       all letters and digits\n"
#~ "  [:alpha:]       all letters\n"
#~ "  [:blank:]       all horizontal whitespace\n"
#~ "  [:cntrl:]       all control characters\n"
#~ "  [:digit:]       all digits\n"
#~ "  [:graph:]       all printable characters, not including space\n"
#~ "  [:lower:]       all lower case letters\n"
#~ "  [:print:]       all printable characters, including space\n"
#~ "  [:punct:]       all punctuation characters\n"
#~ "  [:space:]       all horizontal or vertical whitespace\n"
#~ "  [:upper:]       all upper case letters\n"
#~ "  [:xdigit:]      all hexadecimal digits\n"
#~ "  [=CHAR=]        all characters which are equivalent to CHAR\n"
#~ msgstr ""
#~ "\n"
#~ "Les ENSEMBLES sont spécifiés comme des chaînes de caractères.\n"
#~ "La plupart se représente eux-mêmes.\n"
#~ "Les séquences d'interprétation sont:\n"
#~ "\n"
#~ "  \\NNN            caractère ayant la valeur octale NNN (1 à 3 chiffres "
#~ "octaux)\n"
#~ "  \\\\              barre oblique inverse\n"
#~ "  \\a              cloche sonore \n"
#~ "  \\b              caractère d'effacement\n"
#~ "  \\f              saut de page \n"
#~ "  \\n              saut de ligne \n"
#~ "  \\r              retour\n"
#~ "  \\t              saut horizontal\n"
#~ "  \\v              saut vertical \n"
#~ "  CAR1-CAR2       tous les caractères de CAR1 à CAR2 en ordre croissant\n"
#~ "  [CAR*]          dans ENS2, copie de CAR jusqu'à longueur de ENS1\n"
#~ "  [CAR*RÉP]       RÉPéter copies de CAR, RÉPéter en octal si débute par "
#~ "0\n"
#~ "  [:alnum:]       toutes les lettres et les chiffres\n"
#~ "  [:alpha:]       toutes les lettres\n"
#~ "  [:blank:]       tous les blancs horizontaux\n"
#~ "  [:cntrl:]       tous les caractères de contrôle\n"
#~ "  [:digit:]       tous les chiffres\n"
#~ "  [:graph:]       tous les caractères imprimables, sans inclure les "
#~ "blancs\n"
#~ "  [:lower:]       tous les lettres minuscules\n"
#~ "  [:print:]       tous les caractères imprimables, incluant les blancs\n"
#~ "  [:punct:]       tous les caractères de ponctuation\n"
#~ "  [:space:]       tous les sauts verticaux ou horizontaux\n"
#~ "  [:upper:]       toutes les lettres majuscules\n"
#~ "  [:xdigit:]      tous les chiffres hexadécimaux\n"
#~ "  [=CAR=]         tous les caractères équivalents à CAR\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ "  -c, --count           prefix lines by the number of occurrences\n"
#~ "  -d, --repeated        only print duplicate lines\n"
#~ "  -D, --all-repeated    print all duplicate lines\n"
#~ "  -f, --skip-fields=N   avoid comparing the first N fields\n"
#~ "  -i, --ignore-case     ignore differences in case when comparing\n"
#~ "  -s, --skip-chars=N    avoid comparing the first N characters\n"
#~ "  -u, --unique          only print unique lines\n"
#~ "  -w, --check-chars=N   compare no more than N characters in lines\n"
#~ "  -N                    same as -f N\n"
#~ "  +N                    same as -s N (obsolescent; will be withdrawn)\n"
#~ "      --help            display this help and exit\n"
#~ "      --version         output version information and exit\n"
#~ "\n"
#~ "A field is a run of whitespace, then non-whitespace characters.\n"
#~ "Fields are skipped before chars.\n"
#~ msgstr ""
#~ "Exclure toutes les lignes successives identiques sauf une du FICHIER\n"
#~ "(ou de l'entrée standard), lors de l'écriture dans un FICHIER\n"
#~ "(ou vers la sortie standard).\n"
#~ "\n"
#~ "  -c, --count           préfixer les lignes par le nombre d'occurences\n"
#~ "  -d, --repeated        afficher seulement les lignes ayant des "
#~ "duplicatats\n"
#~ "  -D, --all-repeated    afficher toutes les lignes qui ont des "
#~ "duplicatats\n"
#~ "  -f, --skip-fields=N   éviter de comparer les N premiers champs\n"
#~ "  -i, --ignore-case     ignorer les différences de la casse\n"
#~ "  -s, --skip-chars=N    éviter de comparer les N premiers caractères\n"
#~ "  -u, --unique          afficher seulement les lignes uniques\n"
#~ "  -w, --check-chars=N   ne pas comparer plus de N caractères des lignes\n"
#~ "  -N                    identique à -f N\n"
#~ "  +N                    identique à -s N\n"
#~ "      --help            afficher l'aide-mémoire\n"
#~ "      --version         afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "Un champ est une suite de blancs, suivi de caractères non-blancs.\n"
#~ "Les champs sont escamotés avant les caractères.\n"

#~ msgid "cannot chmod %s"
#~ msgstr "Ne peut changer la protection de %s"

#~ msgid "virtual memory exhausted"
#~ msgstr "Mémoire virtuelle épuisée"

#~ msgid "Memory exhausted"
#~ msgstr "Mémoire épuisée"

#~ msgid ""
#~ "specified number of bytes `%s' is larger than the maximum\n"
#~ "representable value of type `long'"
#~ msgstr ""
#~ "Le nombre d'octets spécifiés `%s' est plus grand que la valeur\n"
#~ "maximale représentable du type `long'"

#~ msgid "%s%*s%s%*sPage"
#~ msgstr "%s%*s%s%*sPage"

#~ msgid ""
#~ "Write sorted concatenation of all FILE(s) to standard output.\n"
#~ "\n"
#~ "  +POS1 [-POS2]    start a key at POS1, end it *before* POS2 "
#~ "(obsolescent)\n"
#~ "\t\t     field numbers and character offsets are numbered\n"
#~ "                     starting with zero (contrast with the -k option)\n"
#~ "  -b               ignore leading blanks in sort fields or keys\n"
#~ "  -c               check if given files already sorted, do not sort\n"
#~ "  -d               consider only [a-zA-Z0-9 ] characters in keys\n"
#~ "  -f               fold lower case to upper case characters in keys\n"
#~ "  -g               compare according to general numerical value, imply -"
#~ "b\n"
#~ "  -i               consider only [\\040-\\0176] characters in keys\n"
#~ "  -k POS1[,POS2]   start a key at POS1, end it *at* POS2\n"
#~ "\t\t     field numbers and character offsets are numbered\n"
#~ "                     starting with one (contrast with zero-based +POS "
#~ "form)\n"
#~ "  -m               merge already sorted files, do not sort\n"
#~ "  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n"
#~ "  -n               compare according to string numerical value, imply -b\n"
#~ "  -o FILE          write result on FILE instead of standard output\n"
#~ "  -r               reverse the result of comparisons\n"
#~ "  -s               stabilize sort by disabling last resort comparison\n"
#~ "  -t SEP           use SEParator instead of non- to whitespace "
#~ "transition\n"
#~ "  -T DIRECTORY     use DIRECTORY for temporary files, not $TMPDIR or %s\n"
#~ "  -u               with -c, check for strict ordering;\n"
#~ "                   with -m, only output the first of an equal sequence\n"
#~ "  -z               end lines with 0 byte, not newline, for find -print0\n"
#~ "      --help       display this help and exit\n"
#~ "      --version    output version information and exit\n"
#~ "\n"
#~ msgstr ""
#~ "Écrire la concaténation triée de tous les FICHIERS sur la sortie "
#~ "standard.\n"
#~ "\n"
#~ "  +POS1 [-POS2]    débuter avec la clé de position POS1, et terminer\n"
#~ "                   *à* POS2 (forme désuète), les numéros de champs \n"
#~ "                   et la position relative des caractères sont numérotés\n"
#~ "  -b               ignorer les blancs de tête dans les champs\n"
#~ "                   ou les clés triés\n"
#~ "  -c               vérifier si un fichier soumis a déjà été trié,\n"
#~ "                   si oui ne pas trier\n"
#~ "  -d               considérer seulement les caractères [a-zA-Z0-9 ]\n"
#~ "                   comme clés\n"
#~ "  -f               considérer les minuscules comme des majuscules\n"
#~ "                   comme clés\n"
#~ "  -g               comparer selon la valeur numérique générale, implique -"
#~ "b\n"
#~ "  -i               considérer seulement les caractères [\\040-\\0176]\n"
#~ "                   comme clés\n"
#~ "  -k POS1[,POS2]   identique à +POS1 [-POS2], mais toutes les positions\n"
#~ "                   comptées à partir de 1, les numéros de champs \n"
#~ "                   et la position relative des caractères sont numérotés\n"
#~ "  -m               fusionner les fichiers triés, ne pas trier \n"
#~ "  -M               comparer selon (inconnu) < `JAN' < ... < `DÉC',\n"
#~ "                   implique -b\n"
#~ "  -n               comparer selon la valeur numérique de la chaîne,\n"
#~ "                   implique -b\n"
#~ "  -o FICHIER       produire le résultat dans le FICHIER au lieu de la\n"
#~ "                   sortie standard\n"
#~ "  -r               inverser le résultat des comparaisons\n"
#~ "  -s               stabiliser le trie en inhibant la dernière "
#~ "comparaison\n"
#~ "  -t SÉP           utiliser le SÉParateur au lieu de la transition\n"
#~ "                   non blanc\n"
#~ "                   à blanc\n"
#~ "  -T RÉPERTOIRE    utiliser le RÉPERTOIRE temporaire, non pas $TMPDIR\n"
#~ "                   ou %s\n"
#~ "  -u               avec -c, vérifier l'ordonnancement strict\n"
#~ "                   avec -m, afficher seulement la première séquence\n"
#~ "                   identique\n"
#~ "  -z               terminer les lignes avec un octet de valeur 0,\n"
#~ "                   pour la commande find find -print0\n"
#~ "      --help       afficher l'aide-mémoire\n"
#~ "      --version    afficher le nom et la version du logiciel\n"

#~ msgid "flushing file"
#~ msgstr "Fichier rejeté"

#~ msgid "%s: write error"
#~ msgstr "%s: erreur d'écriture."

#~ msgid ""
#~ "when using the old-style +POS and -POS key specifiers,\n"
#~ "the +POS specifier must come first"
#~ msgstr ""
#~ "lorsque les options +POS et -POS de la vieille syntaxe\n"
#~ "sont utilisées, l'option +POS doit être spécifiée en premier"

#~ msgid "option `-k' requires an argument"
#~ msgstr "L'option `-k' requiert un argument."

#~ msgid ""
#~ "the starting field number argument to the `-k' option must be positive"
#~ msgstr ""
#~ "Le numéro du argument du champ de départ de l'option `-k' doit être "
#~ "positif."

#~ msgid "starting field spec has `.' but lacks following character offset"
#~ msgstr ""
#~ "La spécification du champ de départ contient `.' mais n'est pas suivi\n"
#~ "de caractères de saut."

#~ msgid ""
#~ "starting field character offset argument to the `-k' option\n"
#~ "must be positive"
#~ msgstr ""
#~ "Le caractère du champ de départ du argument de saut de l'option `-k'\n"
#~ "doit être positif."

#~ msgid "field specification has `,' but lacks following field spec"
#~ msgstr ""
#~ "La spécification du champ contient `,'\n"
#~ "mais n'est pas suivi de champs de spécification."

#~ msgid "ending field number argument to the `-k' option must be positive"
#~ msgstr ""
#~ "Le numéro du champ de terminaison de l'option `-k' doit être positif."

#~ msgid "ending field spec has `.' but lacks following character offset"
#~ msgstr ""
#~ "La spécification du champ de terminaison contient `.' mais n'est pas "
#~ "suivi\n"
#~ "de caractères de saut."

#~ msgid "option `-o' requires an argument"
#~ msgstr "L'option `-o' requiert un argument."

#~ msgid "option `-t' requires an argument"
#~ msgstr "L'option `-t' requiert un argument."

#~ msgid "option `-T' requires an argument"
#~ msgstr "L'option `-T' requiert un argument."

#~ msgid "%s: unrecognized option `-%c'\n"
#~ msgstr "%s: option non reconnue `-%c'\n"

#~ msgid "could not find loop"
#~ msgstr "ne peut trouver une boucle"

#~ msgid "%s: cannot follow end of non-regular file"
#~ msgstr "%s: ne peut suivre jusqu'à la fin d'un fichier non régulier."

#~ msgid ""
#~ "\n"
#~ "Report bugs to <textutils-bugs@gnu.org>."
#~ msgstr ""
#~ "\n"
#~ "Rapporter toutes anomalies à <textutils-bug@gnu.org>."

#~ msgid "`-w PAGE_WIDTH' invalid column number: `%s'"
#~ msgstr "`-w PAGE_WIDTH' contient un nombre de colonnes invalide: `%s'."

#~ msgid "`%s' has reappeared"
#~ msgstr "`%s' est réapparu"

#~ msgid ""
#~ "\n"
#~ "Report bugs to textutils-bugs@gnu.org"
#~ msgstr ""
#~ "\n"
#~ "Rapporter toutes anomalies à textutils-bug@gnu.org."

#~ msgid "%s: `%s' is so large that it is not representable"
#~ msgstr "%s, `%s' est trop grande qu'elle n'est pas représentable."

#~ msgid "argument"
#~ msgstr "argument"

#~ msgid "`+' requires a numeric argument"
#~ msgstr "`+' requiert un argument numérique."

#~ msgid "%s: extra characters in the argument to the `-%c' option: `%s'\n"
#~ msgstr ""
#~ "%s: caractères superflus dans les arguments de l'option `-%c': `%s'\n"

#~ msgid ""
#~ "Paginate or columnate FILE(s) for printing.\n"
#~ "\n"
#~ "  +PAGE             begin printing with page PAGE\n"
#~ "  -COLUMN           produce COLUMN-column output and print columns down\n"
#~ "  -a                print columns across rather than down\n"
#~ "  -b                balance columns on the last page\n"
#~ "  -c                use hat notation (^G) and octal backslash notation\n"
#~ "  -d                double space the output\n"
#~ "  -e[CHAR[WIDTH]]   expand input CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -f, -F            simulate formfeed with newlines on output\n"
#~ "  -h HEADER         use HEADER instead of filename in page headers\n"
#~ "  -i[CHAR[WIDTH]]   replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
#~ "  -l PAGE_LENGTH    set the page length to PAGE_LENGTH (66) lines\n"
#~ "  -m                print all files in parallel, one in each column\n"
#~ "  -n[SEP[DIGITS]]   number lines, use DIGITS (5) digits, then SEP (TAB)\n"
#~ "  -o MARGIN         offset each line with MARGIN spaces (do not affect -"
#~ "w)\n"
#~ "  -r                inhibit warning when a file cannot be opened\n"
#~ "  -s[SEP]           separate columns by character SEP (TAB)\n"
#~ "  -t                inhibit 5-line page headers and trailers\n"
#~ "  -v                use octal backslash notation\n"
#~ "  -w PAGE_WIDTH     set page width to PAGE_WIDTH (72) columns\n"
#~ "      --help        display this help and exit\n"
#~ "      --version     output version information and exit\n"
#~ "\n"
#~ "-t implied by -l N when N < 10.  Without -s, columns are separated by\n"
#~ "spaces.  With no FILE, or when FILE is -, read standard input.\n"
#~ msgstr ""
#~ "Paginer ou mettre en colonne des FICHIERS pour impression.\n"
#~ "\n"
#~ "  +N                   débuter l'impression à la page N\n"
#~ "  -COLONNE             produire un format de N colonnes et imprimer\n"
#~ "  -F, -f               simuler les sauts de pages avec des sauts de "
#~ "lignes\n"
#~ "  -a                   imprimer les colonnes en mode croisé plutôt que\n"
#~ "                       vers le bas\n"
#~ "  -b                   équilibrer les colonnes sur la dernière page\n"
#~ "  -c                   utiliser une notation par chapeau (^G) et octale\n"
#~ "                       avec barre oblique inverse\n"
#~ "  -d                   faire une sortie avec double espacement\n"
#~ "  -e[CAR[LARGEUR]]     dilater les CARactères (ou tabulation) selon la\n"
#~ "                       LARGEUR de tabulation (par défaut 8)\n"
#~ "  -h EN_TÊTE           afficher l'EN_TÊTE au lieu du nom de fichier\n"
#~ "  -i[CAR[LARGEUR]]     remplacer les blancs par des CARactères (ou\n"
#~ "                       tabulation) selon la LARGEUR de tabulation (8)\n"
#~ "  -l LONGUEUR_DE_PAGE  utiliser LONGUEUR_DE_PAGE au lieu de 66 "
#~ "lignes                        (par défaut)\n"
#~ "  -m                   imprimer tous les fichiers en parallèle\n"
#~ "                       un par colonne\n"
#~ "  -n[SÉP[CHIFFRES]]    numéroter les lignes, par des CHIFFRES (5), suivi "
#~ "de\n"
#~ "                       SÉParateurs (TAB)\n"
#~ "  -o MARGE             effectuer le saut de chaque ligne selon la "
#~ "MARGE                        d'espace (n'affecte pas -w)\n"
#~ "  -r                   inhiber les avertissements lorsqu'un fichier\n"
#~ "                       ne peut être ouvert\n"
#~ "  -s[SÉP]              séparer les colonnes par le SÉParateur (ou TAB)\n"
#~ "  -t                   inhiber les 5 lignes d'en-tête et de bas de page \n"
#~ "  -v                   utiliser la notation octale avec barre oblique\n"
#~ "                       inverse\n"
#~ "  -w LARGEUR_DE_PAGE   utiliser LARGEUR_DE_PAGE au lieu de 72 colonnes\n"
#~ "                       (défaut)\n"
#~ "      --help           afficher l'aide-mémoire\n"
#~ "      --version        afficher le nom et la version du logiciel\n"
#~ "\n"
#~ "L'option -t est implicite lorsque -l N est utilisé et quand N < 10.\n"
#~ "Sans -s, les colonnes sont séparées par des blancs.\n"
#~ "Sans FICHIER, ou quand FICHIER est -, lire de l'entrée standard.\n"
